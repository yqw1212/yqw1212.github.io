
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Solver Engine Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="states.html" />
    
    
    <link rel="prev" href="loading.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Introductory Errata
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../INSTALL.html">
            
                <a href="../INSTALL.html">
            
                    
                    Installing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../HACKING.html">
            
                <a href="../HACKING.html">
            
                    
                    How to Contribute
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../HELPWANTED.html">
            
                <a href="../HELPWANTED.html">
            
                    
                    What to Contribute
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="faq.html">
            
                <a href="faq.html">
            
                    
                    Frequently Asked Questions
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Core Concepts
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="toplevel.html">
            
                <a href="toplevel.html">
            
                    
                    Top Level Interfaces
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="loading.html">
            
                <a href="loading.html">
            
                    
                    Loading a Binary
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.3" data-path="solver.html">
            
                <a href="solver.html">
            
                    
                    Solver Engine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="states.html">
            
                <a href="states.html">
            
                    
                    Program State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="pathgroups.html">
            
                <a href="pathgroups.html">
            
                    
                    Simulation Managers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="simulation.html">
            
                <a href="simulation.html">
            
                    
                    Execution Engines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="analyses.html">
            
                <a href="analyses.html">
            
                    
                    Analyses
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="be_creative.html">
            
                <a href="be_creative.html">
            
                    
                    Remarks
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Built-in Analyses
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="analyses/cfg.html">
            
                <a href="analyses/cfg.html">
            
                    
                    CFG
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="analyses/backward_slice.html">
            
                <a href="analyses/backward_slice.html">
            
                    
                    Backward Slicing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="analyses/identifier.html">
            
                <a href="analyses/identifier.html">
            
                    
                    Function Identifier
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" >
            
                <span>
            
                    
                    Advanced Topics
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="gotchas.html">
            
                <a href="gotchas.html">
            
                    
                    Gotchas
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="pipeline.html">
            
                <a href="pipeline.html">
            
                    
                    The Whole Pipeline
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="mixins.html">
            
                <a href="mixins.html">
            
                    
                    The Mixin Pattern
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="speed.html">
            
                <a href="speed.html">
            
                    
                    Optimizing Symbolic Execution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="file_system.html">
            
                <a href="file_system.html">
            
                    
                    The Emulated Filesystem
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="ir.html">
            
                <a href="ir.html">
            
                    
                    Intermediate Representation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="structured_data.html">
            
                <a href="structured_data.html">
            
                    
                    Working with Data and Conventions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.8" data-path="claripy.html">
            
                <a href="claripy.html">
            
                    
                    Claripy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.9" data-path="concretization_strategies.html">
            
                <a href="concretization_strategies.html">
            
                    
                    Symbolic Memory Addressing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.10" data-path="java_support.html">
            
                <a href="java_support.html">
            
                    
                    Java Symbolic Execution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.11" data-path="symbion.html">
            
                <a href="symbion.html">
            
                    
                    Symbion
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" >
            
                <span>
            
                    
                    Extending angr
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="simprocedures.html">
            
                <a href="simprocedures.html">
            
                    
                    Programming SimProcedures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="state_plugins.html">
            
                <a href="state_plugins.html">
            
                    
                    Writing State Plugins
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="environment.html">
            
                <a href="environment.html">
            
                    
                    Extending the Environment Model
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="exploration_techniques.md">
            
                <span>
            
                    
                    TODO: Writing Exploration Techniques
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="analysis_writing.html">
            
                <a href="analysis_writing.html">
            
                    
                    Writing Analyses
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="angr-bf.md">
            
                <span>
            
                    
                    TODO: Adding Support for New Architectures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="angr_management.html">
            
                <a href="angr_management.html">
            
                    
                    Scripting angr management
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="examples.html">
            
                <a href="examples.html">
            
                    
                    Examples
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" >
            
                <span>
            
                    
                    Appendix
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="appendices/ops.html">
            
                <a href="appendices/ops.html">
            
                    
                    List of Claripy Operations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="appendices/options.html">
            
                <a href="appendices/options.html">
            
                    
                    List of State Options
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../CHANGELOG.html">
            
                <a href="../CHANGELOG.html">
            
                    
                    Changelog
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../MIGRATION.html">
            
                <a href="../MIGRATION.html">
            
                    
                    Migrating to angr 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="migration-7.html">
            
                <a href="migration-7.html">
            
                    
                    Migrating to angr 7
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Solver Engine</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="symbolic-expressions-and-constraint-solving">Symbolic Expressions and Constraint Solving</h1>
<p>angr&apos;s power comes not from it being an emulator, but from being able to execute with what we call <em>symbolic variables</em>.
Instead of saying that a variable has a <em>concrete</em> numerical value, we can say that it holds a <em>symbol</em>, effectively just a name.
Then, performing arithmetic operations with that variable will yield a tree of operations (termed an <em>abstract syntax tree</em> or <em>AST</em>, from compiler theory).
ASTs can be translated into constraints for an <em>SMT solver</em>, like z3, in order to ask questions like <em>&quot;given the output of this sequence of operations, what must the input have been?&quot;</em>
Here, you&apos;ll learn how to use angr to answer this.</p>
<h2 id="working-with-bitvectors">Working with Bitvectors</h2>
<p>Let&apos;s get a dummy project and state so we can start playing with numbers.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> angr, monkeyhex
<span class="hljs-meta">&gt;&gt;&gt; </span>proj = angr.Project(<span class="hljs-string">&apos;/bin/true&apos;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()
</code></pre>
<p>A bitvector is just a sequence of bits, interpreted with the semantics of a bounded integer for arithmetic.
Let&apos;s make a few.</p>
<pre><code class="lang-python"><span class="hljs-comment"># 64-bit bitvectors with concrete values 1 and 100</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>one = state.solver.BVV(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>one
 &lt;BV64 <span class="hljs-number">0x1</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>one_hundred = state.solver.BVV(<span class="hljs-number">100</span>, <span class="hljs-number">64</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>one_hundred
 &lt;BV64 <span class="hljs-number">0x64</span>&gt;

<span class="hljs-comment"># create a 27-bit bitvector with concrete value 9</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>weird_nine = state.solver.BVV(<span class="hljs-number">9</span>, <span class="hljs-number">27</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>weird_nine
&lt;BV27 <span class="hljs-number">0x9</span>&gt;
</code></pre>
<p>As you can see, you can have any sequence of bits and call them a bitvector.
You can do math with them too:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>one + one_hundred
&lt;BV64 <span class="hljs-number">0x65</span>&gt;

<span class="hljs-comment"># You can provide normal python integers and they will be coerced to the appropriate type:</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>one_hundred + <span class="hljs-number">0x100</span>
&lt;BV64 <span class="hljs-number">0x164</span>&gt;

<span class="hljs-comment"># The semantics of normal wrapping arithmetic apply</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>one_hundred - one*<span class="hljs-number">200</span>
&lt;BV64 <span class="hljs-number">0xffffffffffffff9c</span>&gt;
</code></pre>
<p>You <em>cannot</em> say <code>one + weird_nine</code>, though.
It is a type error to perform an operation on bitvectors of differing lengths.
You can, however, extend <code>weird_nine</code> so it has an appropriate number of bits:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>weird_nine.zero_extend(<span class="hljs-number">64</span> - <span class="hljs-number">27</span>)
&lt;BV64 <span class="hljs-number">0x9</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>one + weird_nine.zero_extend(<span class="hljs-number">64</span> - <span class="hljs-number">27</span>)
&lt;BV64 <span class="hljs-number">0xa</span>&gt;
</code></pre>
<p><code>zero_extend</code> will pad the bitvector on the left with the given number of zero bits.
You can also use <code>sign_extend</code> to pad with a duplicate of the highest bit, preserving the value of the bitvector under two&apos;s compliment signed integer semantics.</p>
<p>Now, let&apos;s introduce some symbols into the mix.</p>
<pre><code class="lang-python"><span class="hljs-comment"># Create a bitvector symbol named &quot;x&quot; of length 64 bits</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = state.solver.BVS(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">64</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>x
&lt;BV64 x_9_64&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>y = state.solver.BVS(<span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-number">64</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>y
&lt;BV64 y_10_64&gt;
</code></pre>
<p><code>x</code> and <code>y</code> are now <em>symbolic variables</em>, which are kind of like the variables you learned to work with in 7th grade algebra.
Notice that the name you provided has been been mangled by appending an incrementing counter and
You can do as much arithmetic as you want with them, but you won&apos;t get a number back, you&apos;ll get an AST instead.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x + one
&lt;BV64 x_9_64 + <span class="hljs-number">0x1</span>&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>(x + one) / <span class="hljs-number">2</span>
&lt;BV64 (x_9_64 + <span class="hljs-number">0x1</span>) / <span class="hljs-number">0x2</span>&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>x - y
&lt;BV64 x_9_64 - y_10_64&gt;
</code></pre>
<p>Technically <code>x</code> and <code>y</code> and even <code>one</code> are also ASTs - any bitvector is a tree of operations, even if that tree is only one layer deep.
To understand this, let&apos;s learn how to process ASTs.</p>
<p>Each AST has a <code>.op</code> and a <code>.args</code>.
The op is a string naming the operation being performed, and the args are the values the operation takes as input.
Unless the op is <code>BVV</code> or <code>BVS</code> (or a few others...), the args are all other ASTs, the tree eventually terminating with BVVs or BVSs.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>tree = (x + <span class="hljs-number">1</span>) / (y + <span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tree
&lt;BV64 (x_9_64 + <span class="hljs-number">0x1</span>) / (y_10_64 + <span class="hljs-number">0x2</span>)&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>tree.op
<span class="hljs-string">&apos;__floordiv__&apos;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tree.args
(&lt;BV64 x_9_64 + <span class="hljs-number">0x1</span>&gt;, &lt;BV64 y_10_64 + <span class="hljs-number">0x2</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span>tree.args[<span class="hljs-number">0</span>].op
<span class="hljs-string">&apos;__add__&apos;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tree.args[<span class="hljs-number">0</span>].args
(&lt;BV64 x_9_64&gt;, &lt;BV64 <span class="hljs-number">0x1</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span>tree.args[<span class="hljs-number">0</span>].args[<span class="hljs-number">1</span>].op
<span class="hljs-string">&apos;BVV&apos;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tree.args[<span class="hljs-number">0</span>].args[<span class="hljs-number">1</span>].args
(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>)
</code></pre>
<p>From here on out, we will use the word &quot;bitvector&quot; to refer to any AST whose topmost operation produces a bitvector.
There can be other data types represented through ASTs, including floating point numbers and, as we&apos;re about to see, booleans.</p>
<h2 id="symbolic-constraints">Symbolic Constraints</h2>
<p>Performing comparison operations between any two similarly-typed ASTs will yield another AST - not a bitvector, but now a symbolic boolean.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x == <span class="hljs-number">1</span>
&lt;Bool x_9_64 == <span class="hljs-number">0x1</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>x == one
&lt;Bool x_9_64 == <span class="hljs-number">0x1</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>x &gt; <span class="hljs-number">2</span>
&lt;Bool x_9_64 &gt; <span class="hljs-number">0x2</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>x + y == one_hundred + <span class="hljs-number">5</span>
&lt;Bool (x_9_64 + y_10_64) == <span class="hljs-number">0x69</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>one_hundred &gt; <span class="hljs-number">5</span>
&lt;Bool <span class="hljs-keyword">True</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>one_hundred &gt; <span class="hljs-number">-5</span>
&lt;Bool <span class="hljs-keyword">False</span>&gt;
</code></pre>
<p>One tidbit you can see from this is that the comparisons are unsigned by default.
The -5 in the last example is coerced to <code>&lt;BV64 0xfffffffffffffffb&gt;</code>, which is definitely not less than one hundred.
If you want the comparison to be signed, you can say <code>one_hundred.SGT(-5)</code> (that&apos;s &quot;signed greater-than&quot;).
A full list of operations can be found at the end of this chapter.</p>
<p>This snippet also illustrates an important point about working with angr - you should never directly use a comparison between variables in the condition for an if- or while-statement, since the answer might not have a concrete truth value.
Even if there is a concrete truth value, <code>if one &gt; one_hundred</code> will raise an exception.
Instead, you should use <code>solver.is_true</code> and <code>solver.is_false</code>, which test for concrete truthyness/falsiness without performing a constraint solve.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>yes = one == <span class="hljs-number">1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>no = one == <span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>maybe = x == y
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.is_true(yes)
<span class="hljs-keyword">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.is_false(yes)
<span class="hljs-keyword">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.is_true(no)
<span class="hljs-keyword">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.is_false(no)
<span class="hljs-keyword">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.is_true(maybe)
<span class="hljs-keyword">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.is_false(maybe)
<span class="hljs-keyword">False</span>
</code></pre>
<h2 id="constraint-solving">Constraint Solving</h2>
<p>You can treat any symbolic boolean as an assertion about the valid values of a symbolic variable by adding it as a <em>constraint</em> to the state.
You can then query for a valid value of a symbolic variable by asking for an evaluation of a symbolic expression.</p>
<p>An example will probably be more clear than an explanation here:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(x &gt; y)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(y &gt; <span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(<span class="hljs-number">10</span> &gt; x)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(x)
<span class="hljs-number">4</span>
</code></pre>
<p>By adding these constraints to the state, we&apos;ve forced the constraint solver to consider them as assertions that must be satisfied about any values it returns.
If you run this code, you might get a different value for x, but that value will definitely be greater than 3 (since y must be greater than 2 and x must be greater than y) and less than 10.
Furthermore, if you then say <code>state.solver.eval(y)</code>, you&apos;ll get a value of y which is consistent with the value of x that you got.
If you don&apos;t add any constraints between two queries, the results will be consistent with each other.</p>
<p>From here, it&apos;s easy to see how to do the task we proposed at the beginning of the chapter - finding the input that produced a given output.</p>
<pre><code class="lang-python"><span class="hljs-comment"># get a fresh state without constraints</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()
<span class="hljs-meta">&gt;&gt;&gt; </span>input = state.solver.BVS(<span class="hljs-string">&apos;input&apos;</span>, <span class="hljs-number">64</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>operation = (((input + <span class="hljs-number">4</span>) * <span class="hljs-number">3</span>) &gt;&gt; <span class="hljs-number">1</span>) + input
<span class="hljs-meta">&gt;&gt;&gt; </span>output = <span class="hljs-number">200</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(operation == output)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(input)
<span class="hljs-number">0x3333333333333381</span>
</code></pre>
<p>Note that, again, this solution only works because of the bitvector semantics.
If we were operating over the domain of integers, there would be no solutions!</p>
<p>If we add conflicting or contradictory constraints, such that there are no values that can be assigned to the variables such that the constraints are satisfied, the state becomes <em>unsatisfiable</em>, or unsat, and queries against it will raise an exception.
You can check the satisfiability of a state with <code>state.satisfiable()</code>.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(input &lt; <span class="hljs-number">2</span>**<span class="hljs-number">32</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.satisfiable()
<span class="hljs-keyword">False</span>
</code></pre>
<p>You can also evaluate more complex expressions, not just single variables.</p>
<pre><code class="lang-python"><span class="hljs-comment"># fresh state</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(x - y &gt;= <span class="hljs-number">4</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(y &gt; <span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(x)
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(y)
<span class="hljs-number">1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(x + y)
<span class="hljs-number">6</span>
</code></pre>
<p>From this we can see that <code>eval</code> is a general purpose method to convert any bitvector into a python primitive while respecting the integrity of the state.
This is why we use <code>eval</code> to convert from concrete bitvectors to python ints, too!</p>
<p>Also note that the x and y variables can be used in this new state despite having been created using an old state.
Variables are not tied to any one state, and can exist freely.</p>
<h2 id="floating-point-numbers">Floating point numbers</h2>
<p>z3 has support for the theory of IEEE754 floating point numbers, and so angr can use them as well.
The main difference is that instead of a width, a floating point number has a <em>sort</em>.
You can create floating point symbols and values with <code>FPV</code> and <code>FPS</code>.</p>
<pre><code class="lang-python"><span class="hljs-comment"># fresh state</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()
<span class="hljs-meta">&gt;&gt;&gt; </span>a = state.solver.FPV(<span class="hljs-number">3.2</span>, state.solver.fp.FSORT_DOUBLE)
<span class="hljs-meta">&gt;&gt;&gt; </span>a
&lt;FP64 FPV(<span class="hljs-number">3.2</span>, DOUBLE)&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>b = state.solver.FPS(<span class="hljs-string">&apos;b&apos;</span>, state.solver.fp.FSORT_DOUBLE)
<span class="hljs-meta">&gt;&gt;&gt; </span>b
&lt;FP64 FPS(<span class="hljs-string">&apos;FP_b_0_64&apos;</span>, DOUBLE)&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>a + b
&lt;FP64 fpAdd(<span class="hljs-string">&apos;RNE&apos;</span>, FPV(<span class="hljs-number">3.2</span>, DOUBLE), FPS(<span class="hljs-string">&apos;FP_b_0_64&apos;</span>, DOUBLE))&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>a + <span class="hljs-number">4.4</span>
&lt;FP64 FPV(<span class="hljs-number">7.6000000000000005</span>, DOUBLE)&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>b + <span class="hljs-number">2</span> &lt; <span class="hljs-number">0</span>
&lt;Bool fpLT(fpAdd(<span class="hljs-string">&apos;RNE&apos;</span>, FPS(<span class="hljs-string">&apos;FP_b_0_64&apos;</span>, DOUBLE), FPV(<span class="hljs-number">2.0</span>, DOUBLE)), FPV(<span class="hljs-number">0.0</span>, DOUBLE))&gt;
</code></pre>
<p>So there&apos;s a bit to unpack here - for starters the pretty-printing isn&apos;t as smart about floating point numbers.
But past that, most operations actually have a third parameter, implicitly added when you use the binary operators - the rounding mode.
The IEEE754 spec supports multiple rounding modes (round-to-nearest, round-to-zero, round-to-positive, etc), so z3 has to support them.
If you want to specify the rounding mode for an operation, use the fp operation explicitly (<code>solver.fpAdd</code> for example) with a rounding mode (one of <code>solver.fp.RM_*</code>) as the first argument.</p>
<p>Constraints and solving work in the same way, but with <code>eval</code> returning a floating point number:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(b + <span class="hljs-number">2</span> &lt; <span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.add(b + <span class="hljs-number">2</span> &gt; <span class="hljs-number">-1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.eval(b)
<span class="hljs-number">-2.4999999999999996</span>
</code></pre>
<p>This is nice, but sometimes we need to be able to work directly with the representation of the float as a bitvector.
You can interpret bitvectors as floats and vice versa, with the methods <code>raw_to_bv</code> and <code>raw_to_fp</code>:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a.raw_to_bv()
&lt;BV64 <span class="hljs-number">0x400999999999999a</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>b.raw_to_bv()
&lt;BV64 fpToIEEEBV(FPS(<span class="hljs-string">&apos;FP_b_0_64&apos;</span>, DOUBLE))&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.BVV(<span class="hljs-number">0</span>, <span class="hljs-number">64</span>).raw_to_fp()
&lt;FP64 FPV(<span class="hljs-number">0.0</span>, DOUBLE)&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>state.solver.BVS(<span class="hljs-string">&apos;x&apos;</span>, <span class="hljs-number">64</span>).raw_to_fp()
&lt;FP64 fpToFP(x_1_64, DOUBLE)&gt;
</code></pre>
<p>These conversions preserve the bit-pattern, as if you casted a float pointer to an int pointer or vice versa.
However, if you want to preserve the value as closely as possible, as if you casted a float to an int (or vice versa), you can use a different set of methods, <code>val_to_fp</code> and <code>val_to_bv</code>.
These methods must take the size or sort of the target value as a parameter, due to the floating-point nature of floats.</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a
&lt;FP64 FPV(<span class="hljs-number">3.2</span>, DOUBLE)&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>a.val_to_bv(<span class="hljs-number">12</span>)
&lt;BV12 <span class="hljs-number">0x3</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>a.val_to_bv(<span class="hljs-number">12</span>).val_to_fp(state.solver.fp.FSORT_FLOAT)
&lt;FP32 FPV(<span class="hljs-number">3.0</span>, FLOAT)&gt;
</code></pre>
<p>These methods can also take a <code>signed</code> parameter, designating the signedness of the source or target bitvector.</p>
<h2 id="more-solving-methods">More Solving Methods</h2>
<p><code>eval</code> will give you one possible solution to an expression, but what if you want several?
What if you want to ensure that the solution is unique?
The solver provides you with several methods for common solving patterns:</p>
<ul>
<li><code>solver.eval(expression)</code> will give you one possible solution to the given expression.</li>
<li><code>solver.eval_one(expression)</code> will give you the solution to the given expression, or throw an error if more than one solution is possible.</li>
<li><code>solver.eval_upto(expression, n)</code> will give you up to n solutions to the given expression, returning fewer than n if fewer than n are possible.</li>
<li><code>solver.eval_atleast(expression, n)</code> will give you n solutions to the given expression, throwing an error if fewer than n are possible.</li>
<li><code>solver.eval_exact(expression, n)</code> will give you n solutions to the given expression, throwing an error if fewer or more than are possible.</li>
<li><code>solver.min(expression)</code> will give you the minimum possible solution to the given expression.</li>
<li><code>solver.max(expression)</code> will give you the maximum possible solution to the given expression.</li>
</ul>
<p>Additionally, all of these methods can take the following keyword arguments:</p>
<ul>
<li><code>extra_constraints</code> can be passed as a tuple of constraints.
These constraints will be taken into account for this evaluation, but will not be added to the state.</li>
<li><code>cast_to</code> can be passed a data type to cast the result to.
Currently, this can only be <code>int</code> and <code>bytes</code>, which will cause the method to return the corresponding representation of the underlying data.
For example, <code>state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=bytes)</code> will return <code>b&apos;ABCD&apos;</code>.</li>
</ul>
<h2 id="summary">Summary</h2>
<p>That was a lot!!
After reading this, you should be able to create and manipulate bitvectors, booleans, and floating point values to form trees of operations, and then query the constraint solver attached to a state for possible solutions under a set of constraints.
Hopefully by this point you understand the power of using ASTs to represent computations, and the power of a constraint solver.</p>
<p><a href="appendices/ops.html">In the appendix</a>, you can find a reference for all the additional operations you can apply to ASTs, in case you ever need a quick table to look at.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="loading.html" class="navigation navigation-prev " aria-label="Previous page: Loading a Binary">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="states.html" class="navigation navigation-next " aria-label="Next page: Program State">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Solver Engine","level":"1.3.3","depth":2,"next":{"title":"Program State","level":"1.3.4","depth":2,"path":"docs/states.md","ref":"docs/states.md","articles":[]},"previous":{"title":"Loading a Binary","level":"1.3.2","depth":2,"path":"docs/loading.md","ref":"docs/loading.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"docs/solver.md","mtime":"2021-07-15T09:05:26.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2021-08-01T08:40:14.923Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

