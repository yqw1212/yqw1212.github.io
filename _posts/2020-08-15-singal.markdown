---
layout: post
title:  singal[网鼎杯2020青龙组]
date:   2020-08-15 00:01:01 +0300
image:  2020-08-15-couple.jpg
tags:   [ctf,reverse,网鼎杯]
---

ida打开文件，进入主函数，反编译查看代码

```assembly
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp+18h] [ebp-1D4h]

  __main();
  qmemcpy(&v4, &unk_403040, 0x1C8u);
  vm_operad(&v4, 114);
  puts("good,The answer format is:flag {}");
  return 0;
}
```

可以看到首先从内存给v4赋值

这里我由于不熟悉数据在内存中的储存，参考了别人的博客

 v4在内存中所copy的对象是db型数据，大小为0x1c8即456

为方便获取数据，进入内存数据16进制页面

![]({{site.baseurl}}/img/2020-08-15-a.jpg)

 0x403040+0x1c8等于0x403208，所以将0x403040到0x403208的这段数据拷贝出来

```assembly
0A 00 00 00 04 00 00 00  10 00 00 00 08 00 00 00
03 00 00 00 05 00 00 00  01 00 00 00 04 00 00 00
20 00 00 00 08 00 00 00  05 00 00 00 03 00 00 00
01 00 00 00 03 00 00 00  02 00 00 00 08 00 00 00
0B 00 00 00 01 00 00 00  0C 00 00 00 08 00 00 00
04 00 00 00 04 00 00 00  01 00 00 00 05 00 00 00
03 00 00 00 08 00 00 00  03 00 00 00 21 00 00 00
01 00 00 00 0B 00 00 00  08 00 00 00 0B 00 00 00
01 00 00 00 04 00 00 00  09 00 00 00 08 00 00 00
03 00 00 00 20 00 00 00  01 00 00 00 02 00 00 00
51 00 00 00 08 00 00 00  04 00 00 00 24 00 00 00
01 00 00 00 0C 00 00 00  08 00 00 00 0B 00 00 00
01 00 00 00 05 00 00 00  02 00 00 00 08 00 00 00
02 00 00 00 25 00 00 00  01 00 00 00 02 00 00 00
36 00 00 00 08 00 00 00  04 00 00 00 41 00 00 00
01 00 00 00 02 00 00 00  20 00 00 00 08 00 00 00
05 00 00 00 01 00 00 00  01 00 00 00 05 00 00 00
03 00 00 00 08 00 00 00  02 00 00 00 25 00 00 00
01 00 00 00 04 00 00 00  09 00 00 00 08 00 00 00
03 00 00 00 20 00 00 00  01 00 00 00 02 00 00 00
41 00 00 00 08 00 00 00  0C 00 00 00 01 00 00 00
07 00 00 00 22 00 00 00  07 00 00 00 3F 00 00 00
07 00 00 00 34 00 00 00  07 00 00 00 32 00 00 00
07 00 00 00 72 00 00 00  07 00 00 00 33 00 00 00
07 00 00 00 18 00 00 00  07 00 00 00 A7 FF FF FF
07 00 00 00 31 00 00 00  07 00 00 00 F1 FF FF FF
07 00 00 00 28 00 00 00  07 00 00 00 84 FF FF FF
07 00 00 00 C1 FF FF FF  07 00 00 00 1E 00 00 00
07 00 00 00 7A 00 00 00
```

4字节等于一个int，interl处理器是小端存储，刚好a1数组的值就是三个00之前那十六进制

```assembly
10, 4, 16, 8, 3, 5, 1, 4, 32, 8, 5, 3, 1, 3, 2, 8, 11, 1, 12, 8, 4, 4, 1, 5, 3, 8, 3, 33, 1, 11, 8, 11, 1, 4, 9, 8, 3, 32, 1, 2, 81, 8, 4, 36, 1, 12, 8, 11, 1, 5, 2, 8, 2, 37, 1, 2, 54, 8, 4, 65, 1, 2, 32, 8, 5, 1, 1, 5, 3, 8, 2, 37, 1, 4, 9, 8, 3, 32, 1, 2, 65, 8, 12, 1, 7, 34, 7, 63, 7, 52, 7, 50, 7, 114, 7, 51, 7, 24, 7, 167, 255, 255, 255, 7, 49, 7, 241, 255, 255, 255, 7, 40, 7, 132, 255, 255, 255, 7, 193, 255, 255, 255, 7, 30, 7, 122
```

接着查看vm_operad()函数代码

```assembly
int __cdecl vm_operad(int *a1, int a2)
{
  int result; // eax
  char v3[100]; // [esp+13h] [ebp-E5h]
  char v4[100]; // [esp+77h] [ebp-81h]
  char v5; // [esp+DBh] [ebp-1Dh]
  int v6; // [esp+DCh] [ebp-1Ch]
  int v7; // [esp+E0h] [ebp-18h]
  int v8; // [esp+E4h] [ebp-14h]
  int v9; // [esp+E8h] [ebp-10h]
  int v10; // [esp+ECh] [ebp-Ch]

  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  while ( 1 )
  {
    result = v10;
    if ( v10 >= a2 )
      return result;
    switch ( a1[v10] )
    {
      case 1:
        v4[v7] = v5;
        ++v10;
        ++v7;
        ++v9;
        break;
      case 2:
        v5 = a1[v10 + 1] + v3[v9];
        v10 += 2;
        break;
      case 3:
        v5 = v3[v9] - LOBYTE(a1[v10 + 1]);
        v10 += 2;
        break;
      case 4:
        v5 = a1[v10 + 1] ^ v3[v9];
        v10 += 2;
        break;
      case 5:
        v5 = a1[v10 + 1] * v3[v9];
        v10 += 2;
        break;
      case 6:
        ++v10;
        break;
      case 7:
        if ( v4[v8] != a1[v10 + 1] )
        {
          printf("what a shame...");
          exit(0);
        }
        ++v8;
        v10 += 2;
        break;
      case 8:
        v3[v6] = v5;
        ++v10;
        ++v6;
        break;
      case 10:
        read(v3);
        ++v10;
        break;
      case 11:
        v5 = v3[v9] - 1;
        ++v10;
        break;
      case 12:
        v5 = v3[v9] + 1;
        ++v10;
        break;
      default:
        continue;
    }
  }
}
```

函数名称中有vm，再结合函数中的代码，我们可以确定刚才从内存中复制的数组为vm指令。

这个函数的流程大致是输入一个字符串，再将其变换，最后与另外一些数字比较。

当vm指令为7时，v4数组的值会与a1数组的下一位进行比较，相等继续，不等报错。7后面的数字就是正确输入进行加密后需要与之比较的值，刚好7这个值在a1数组的最后，将这串值提取出来为

```assembly
34,63,52,50,114,51,24,167,49,241,40,132,193,30,122
```

想到可以通过暴力破解来求得输入的字符串

编写C语言脚本

```assembly
#include <stdio.h>

int main()
{
    int a1[125]={4, 16, 8, 3, 5, 1, 4, 32, 8, 5, 3, 1, 3, 2, 8, 11, 1, 12, 8, 4, 4, 1, 5, 3, 8, 3, 33, 1, 11, 8, 11, 1, 4, 9, 8, 3, 32, 1, 2, 81, 8, 4, 36, 1, 12, 8, 11, 1, 5, 2, 8, 2, 37, 1, 2, 54, 8, 4, 65, 1, 2, 32, 8, 5, 1, 1, 5, 3, 8, 2, 37, 1, 4, 9, 8, 3, 32, 1, 2, 65, 8, 12, 1, 7, 34, 7, 63, 7, 52, 7, 50, 7, 114, 7, 51, 7, 24, 7, 167, 255, 255, 255, 7, 49, 7, 241, 255, 255, 255, 7, 40, 7, 132, 255, 255, 255, 7, 193, 255, 255, 255, 7, 30, 7, 122};
    char v4[15] = {34,63,52,50,114,51,24,167,49,241,40,132,193,30,122};
    char target[15] = {34,63,52,50,114,51,24,167,49,241,40,132,193,30,122};
    int v3[15] = {0};

    char v5;

    for(int j=0;j<15;j++)
    {
        //printf("%d ",j);
        for(int i=30;i<127;i++)
        {
            v3[j]=i;

            int v6 = 0;
            int v7 = 0;
            int v9 = 0;
            int v10 = 0;
            int v8 = 0;
            while ( 1 )
            {
                if ( v10 >= 124 )
                    break;
                switch ( a1[v10] )
                {
                    case 1:
                    {
                        v4[v7] = v5;
                        ++v10;
                        ++v7;
                        ++v9;
                        break;
                    }
                    case 2:
                    {
                        v5 = a1[v10 + 1] + v3[v9];
                        v10 += 2;
                        break;
                    }
                    case 3:
                    {
                        v5 = v3[v9] - a1[v10 + 1];
                        v10 += 2;
                        break;
                    }
                    case 4:
                    {
                        v5 = a1[v10 + 1] ^ v3[v9];
                        v10 += 2;
                        break;
                    }
                    case 5:
                    {
                        v5 = a1[v10 + 1] * v3[v9];
                        v10 += 2;
                        break;
                    }
                    case 6:
                    {
                        ++v10;
                        break;
                    }
                    case 7:
                    {
                        ++v8;
                        v10 += 2;
                        break;
                    }
                    case 8:
                    {
                        v3[v6] = v5;
                        ++v10;
                        ++v6;
                        break;
                    }
                    case 11:
                    {
                        v5 = v3[v9] - 1;
                        ++v10;
                        break;
                    }
                    case 12:
                    {
                        v5 = v3[v9] + 1;
                        ++v10;
                        break;
                    }
                    default:
                    {
                        ++v10;
                        continue;
                    }
                }
            }
            if(target[j]==v4[j])
            {
                //printf("v3[%d]=%d\n",j,i);
                printf("%c",i);
                break;
            }
        }
    }
    /*
    for(int i=0;i<15;i++)
        printf("%d ",v4[i]);
    */

    return 0;
}

```

运行得到flag

flag{757515121f3d478}

当然这种题也可以通过算法逆向来解，有时间补。