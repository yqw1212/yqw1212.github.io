---
layout: post
title:  EasyVM
date:   2021-10-14 08:00:01 +0300
image:  2021-10-14-woman.jpg
tags:   [ctf,reverse,羊城杯,vm]
---

main

```assembly
int __cdecl main()
{
  _DWORD *v1; // [esp+18h] [ebp-10h]

  sub_80486BB();
  v1 = sub_8048F45();
  v1[8] = &unk_804B0C0;                         // pcode
  sub_80491C8();                                // 自解密
  ((void (__cdecl *)(_DWORD *))loc_80487A8)(v1);// dispatch
  return 0;
}
```

查看自解密函数

```assembly
unsigned int sub_80491C8()
{
  int v1[4]; // [esp+Ch] [ebp-1Ch] BYREF
  unsigned int v2; // [esp+1Ch] [ebp-Ch]

  v2 = __readgsdword(0x14u);
  v1[0] = 0x11;
  v1[1] = 0x22;
  v1[2] = 0x33;
  v1[3] = 0x44;
  mprotect(&dword_8048000, 0x2000u, 7);
  sub_8049008((unsigned int *)&loc_80487A8, 0x1E7, (int)v1);
  return __readgsdword(0x14u) ^ v2;
}
```

mprotect()修改调用进程内存页的保护属性，如果调用进程尝试以违反保护属性的方式访问该内存，则内核会发出一个SIGSEGV信号给该进程。

```assembly
#include <sys/mman.h>
int mprotect(void *addr, size_t len, int prot);
```

addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB == 4096字节）整数倍。
len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。
prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用：

| Symbolic Constant | Decimal Value | Description                                                  |
| :---------------- | :------------ | :----------------------------------------------------------- |
| PROT_READ         | 1             | Read access is allowed.                                      |
| PROT_WRITE        | 2             | Write access is allowed. Note that this value assumes PROT_READ also. |
| PROT_NONE         | 8             | No data access is allowed.                                   |
| PROT_EXEC         | 4             | This value is allowed, but is equivalent to PROT_READ.       |

sub_8049008

```assembly
unsigned int __cdecl sub_8049008(unsigned int *a1, int a2, int a3)
{
  unsigned int v4; // [esp+14h] [ebp-34h]
  unsigned int v5; // [esp+18h] [ebp-30h]
  int i; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  unsigned int v9; // [esp+2Ch] [ebp-1Ch]

  v9 = __readgsdword(0x14u);
  v7 = 0x22 / a2 + 9;
  v5 = 0x4E782FF0 * v7;
  v4 = *a1;
  do
  {
    v8 = (v5 >> 2) & 3;
    for ( i = a2 - 1; i; --i )
    {
      a1[i] -= (((2 * v4) ^ (a1[i + 0xFFFFFFFF] >> 4)) + ((v4 >> 3) ^ (0x20 * a1[i + 0xFFFFFFFF])) + 0x28) ^ ((v4 ^ v5 ^ 0x77) + (a1[i + 0xFFFFFFFF] ^ *(_DWORD *)(4 * (v8 ^ i & 3) + a3)) - 0xF);
      v4 = a1[i];
    }
    *a1 -= (((2 * v4) ^ (a1[a2 + 0xFFFFFFFF] >> 4)) + ((v4 >> 3) ^ (0x20 * a1[a2 + 0xFFFFFFFF])) + 0x28) ^ ((v4 ^ v5 ^ 0x77) + (a1[a2 + 0xFFFFFFFF] ^ *(_DWORD *)(4 * v8 + a3)) - 0xF);
    v4 = *a1;
    v5 -= 0x4E782FF0;
    --v7;
  }
  while ( v7 );
  return __readgsdword(0x14u) ^ v9;
}
```

是一个xxtea的代码自解密，我们可以在程序刚好自解密结束的地方下断点，然后将自解密的结果dump(Shift+E)下来。

>hex(0x80487A8+0x1E7-1)
>'0x804898e'

即0x80487A8~0x804898e部分

但是通过验证发现并不是到0x804898e的位置结束，而是到0x8048F44。

![]({{site.baseurl}}/img/2021-10-14-end.jpg)

```assembly
unsigned char ida_chars[] =
{
  0x55, 0x89, 0xE5, 0x53, 0x83, 0xEC, 0x34, 0x8B, 0x45, 0x08, 
  0x89, 0x45, 0xD4, 0x65, 0xA1, 0x14, 0x00, 0x00, 0x00, 0x89, 
  0x45, 0xF4, 0x31, 0xC0, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 
  0x0F, 0xB6, 0x00, 0x3C, 0x71, 0x75, 0x2F, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x18, 0x8D, 0x50, 0xFC, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x18, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x18, 0x8B, 0x55, 
  0xD4, 0x8B, 0x52, 0x20, 0x8B, 0x52, 0x01, 0x89, 0x10, 0x8B, 
  0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 0x05, 0x8B, 0x45, 
  0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 
  0x0F, 0xB6, 0x00, 0x3C, 0x41, 0x75, 0x23, 0x8B, 0x45, 0xD4, 
  0x8B, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x08, 0x01, 
  0xC2, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0x42, 0x75, 0x23, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 
  0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x10, 0x29, 0xC2, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0x43, 0x75, 0x24, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 0x04, 0x8B, 
  0x45, 0xD4, 0x8B, 0x40, 0x0C, 0x0F, 0xAF, 0xD0, 0x8B, 0x45, 
  0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 
  0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 
  0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x37, 
  0x75, 0x1B, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 0x14, 0x8B, 0x45, 
  0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 
  0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 
  0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x38, 
  0x75, 0x23, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 0x04, 0x8B, 0x45, 
  0xD4, 0x8B, 0x40, 0x10, 0x31, 0xC2, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 
  0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x39, 0x75, 0x23, 
  0x8B, 0x45, 0xD4, 0x8B, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 
  0x40, 0x14, 0x31, 0xC2, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x04, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x35, 0x75, 0x1B, 0x8B, 0x45, 
  0xD4, 0x8B, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x14, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x0F, 0xB6, 0x00, 0x3C, 0xF7, 0x75, 0x23, 0x8B, 0x45, 
  0xD4, 0x8B, 0x50, 0x24, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x04, 
  0x01, 0xC2, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x24, 0x8B, 0x45, 
  0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 
  0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 
  0xB6, 0x00, 0x3C, 0x44, 0x75, 0x2A, 0x8B, 0x45, 0xD4, 0x8B, 
  0x40, 0x04, 0x8B, 0x55, 0xD4, 0x8B, 0x5A, 0x14, 0xBA, 0x00, 
  0x00, 0x00, 0x00, 0xF7, 0xF3, 0x89, 0xC2, 0x8B, 0x45, 0xD4, 
  0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 
  0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 
  0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x80, 0x75, 
  0x33, 0x8B, 0x5D, 0xD4, 0x83, 0xEC, 0x08, 0x6A, 0x01, 0xFF, 
  0x75, 0xD4, 0xE8, 0x9E, 0xFD, 0xFF, 0xFF, 0x83, 0xC4, 0x10, 
  0xC1, 0xE0, 0x02, 0x8D, 0x14, 0x03, 0x8B, 0x45, 0xD4, 0x8B, 
  0x40, 0x20, 0x8B, 0x40, 0x02, 0x89, 0x02, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x06, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0x77, 0x75, 0x23, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 
  0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x24, 0x31, 0xC2, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0x53, 0x75, 0x27, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x0C, 0x0F, 
  0xB6, 0x00, 0x0F, 0xBE, 0xC0, 0x83, 0xEC, 0x0C, 0x50, 0xE8, 
  0x4A, 0xFB, 0xFF, 0xFF, 0x83, 0xC4, 0x10, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x02, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0x22, 0x75, 0x25, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 
  0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x08, 0x89, 0xC1, 0xD3, 
  0xEA, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0x23, 0x75, 0x25, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 
  0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x08, 0x89, 0xC1, 0xD3, 
  0xE2, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0x99, 0x0F, 0x84, 0x70, 0x04, 0x00, 0x00, 0x8B, 
  0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x76, 
  0x75, 0x38, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x18, 0x8B, 0x10, 
  0x8B, 0x45, 0xD4, 0x89, 0x50, 0x0C, 0x8B, 0x45, 0xD4, 0x8B, 
  0x40, 0x18, 0xC7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 
  0xD4, 0x8B, 0x40, 0x18, 0x8D, 0x50, 0x04, 0x8B, 0x45, 0xD4, 
  0x89, 0x50, 0x18, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 
  0x50, 0x05, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 
  0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x54, 0x75, 
  0x24, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x0C, 0x89, 0x45, 0xE0, 
  0xE8, 0x03, 0xFA, 0xFF, 0xFF, 0x89, 0xC2, 0x8B, 0x45, 0xE0, 
  0x88, 0x10, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 
  0x02, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x30, 0x75, 0x23, 
  0x8B, 0x45, 0xD4, 0x8B, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 
  0x40, 0x08, 0x09, 0xC2, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x04, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x31, 0x75, 0x23, 0x8B, 0x45, 
  0xD4, 0x8B, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x08, 
  0x21, 0xC2, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 
  0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 
  0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 
  0xB6, 0x00, 0x3C, 0x32, 0x75, 0x24, 0x8B, 0x45, 0xD4, 0x8B, 
  0x40, 0x20, 0x83, 0xC0, 0x01, 0x0F, 0xB6, 0x00, 0x0F, 0xB6, 
  0xD0, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x0C, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x02, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0x09, 0x75, 0x19, 0x8B, 0x45, 0xD4, 0xC7, 0x40, 
  0x04, 0x67, 0xF9, 0xEB, 0x6F, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0x10, 0x75, 0x1B, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 0x04, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x24, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0x33, 0x75, 0x1B, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 0x04, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x10, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0x34, 0x75, 0x24, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x83, 
  0xC0, 0x01, 0x0F, 0xB6, 0x00, 0x0F, 0xB6, 0xD0, 0x8B, 0x45, 
  0xD4, 0x89, 0x50, 0x08, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 
  0x8D, 0x50, 0x02, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 
  0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0xFE, 
  0x75, 0x1B, 0x8B, 0x45, 0xD4, 0x8B, 0x50, 0x24, 0x8B, 0x45, 
  0xD4, 0x89, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 
  0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 
  0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0x11, 
  0x75, 0x26, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x04, 0x83, 0xEC, 
  0x08, 0x50, 0x68, 0x40, 0x93, 0x04, 0x08, 0xE8, 0x5C, 0xF8, 
  0xFF, 0xFF, 0x83, 0xC4, 0x10, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0xA0, 0x75, 0x28, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x04, 0x3D, 
  0x67, 0xF9, 0xEB, 0x6F, 0x75, 0x11, 0x8B, 0x45, 0xD4, 0x8B, 
  0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 
  0x20, 0xEB, 0x0A, 0x83, 0xEC, 0x0C, 0x6A, 0x00, 0xE8, 0x55, 
  0xF8, 0xFF, 0xFF, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 
  0xB6, 0x00, 0x3C, 0xA1, 0x75, 0x42, 0x83, 0xEC, 0x04, 0x6A, 
  0x2C, 0x68, 0x40, 0xB3, 0x04, 0x08, 0x6A, 0x00, 0xE8, 0xE7, 
  0xF7, 0xFF, 0xFF, 0x83, 0xC4, 0x10, 0x83, 0xEC, 0x0C, 0x68, 
  0x40, 0xB3, 0x04, 0x08, 0xE8, 0x37, 0xF8, 0xFF, 0xFF, 0x83, 
  0xC4, 0x10, 0x83, 0xF8, 0x2C, 0x74, 0x0A, 0x83, 0xEC, 0x0C, 
  0x6A, 0x00, 0xE8, 0x15, 0xF8, 0xFF, 0xFF, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0xB1, 0x75, 0x1B, 0x8B, 0x15, 0x80, 0xB0, 0x04, 
  0x08, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x24, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0xB2, 0x75, 0x1B, 0x8B, 0x15, 0x84, 0xB0, 0x04, 
  0x08, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x24, 0x8B, 0x45, 0xD4, 
  0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 
  0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0xA4, 0x75, 0x37, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x83, 0xC0, 0x01, 0x0F, 0xB6, 0x00, 0x0F, 0xB6, 0xC0, 
  0x89, 0x45, 0xE4, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x04, 0x89, 
  0x45, 0xE8, 0x8B, 0x55, 0xE8, 0x8B, 0x45, 0xE4, 0x89, 0x14, 
  0x85, 0x80, 0xB0, 0x04, 0x08, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x04, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0xB3, 0x75, 0x1B, 0x8B, 0x15, 0x88, 0xB0, 0x04, 0x08, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x24, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0xB4, 0x75, 0x1B, 0x8B, 0x15, 0x8C, 0xB0, 0x04, 0x08, 0x8B, 
  0x45, 0xD4, 0x89, 0x50, 0x24, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 
  0xC1, 0x75, 0x35, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x83, 
  0xC0, 0x01, 0x0F, 0xB6, 0x00, 0x0F, 0xB6, 0xC0, 0x89, 0x45, 
  0xEC, 0x8B, 0x45, 0xEC, 0x05, 0x40, 0xB3, 0x04, 0x08, 0x0F, 
  0xB6, 0x00, 0x0F, 0xB6, 0xD0, 0x8B, 0x45, 0xD4, 0x89, 0x50, 
  0x04, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 0x02, 
  0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0x8B, 0x45, 0xD4, 0x8B, 
  0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0xC7, 0x75, 0x2B, 0x8B, 
  0x15, 0x60, 0xB0, 0x04, 0x08, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x04, 0x39, 0xC2, 0x75, 0x11, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x01, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0xEB, 0x0A, 0x83, 0xEC, 0x0C, 0x6A, 0x00, 0xE8, 0xA8, 0xF6, 
  0xFF, 0xFF, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 
  0x00, 0x3C, 0xC8, 0x75, 0x2B, 0x8B, 0x15, 0x64, 0xB0, 0x04, 
  0x08, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x04, 0x39, 0xC2, 0x75, 
  0x11, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 0x20, 0x8D, 0x50, 0x01, 
  0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 0xEB, 0x0A, 0x83, 0xEC, 
  0x0C, 0x6A, 0x00, 0xE8, 0x70, 0xF6, 0xFF, 0xFF, 0x8B, 0x45, 
  0xD4, 0x8B, 0x40, 0x20, 0x0F, 0xB6, 0x00, 0x3C, 0xC2, 0x0F, 
  0x85, 0xCF, 0xF8, 0xFF, 0xFF, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x83, 0xC0, 0x01, 0x8B, 0x00, 0x89, 0x45, 0xF0, 0x8B, 
  0x45, 0xF0, 0x0F, 0xB6, 0xD0, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x04, 0x39, 0xC2, 0x74, 0x0A, 0x83, 0xEC, 0x0C, 0x6A, 0x00, 
  0xE8, 0x37, 0xF6, 0xFF, 0xFF, 0x8B, 0x45, 0xD4, 0x8B, 0x40, 
  0x20, 0x8D, 0x50, 0x05, 0x8B, 0x45, 0xD4, 0x89, 0x50, 0x20, 
  0xE9, 0x93, 0xF8, 0xFF, 0xFF, 0x90, 0x90, 0x8B, 0x45, 0xF4, 
  0x65, 0x33, 0x05, 0x14, 0x00, 0x00, 0x00, 0x74, 0x05, 0xE8, 
  0xF0, 0xF5, 0xFF, 0xFF, 0x8B, 0x5D, 0xFC, 0xC9
};
```

虽然不是用脚本dump，但是还是保存一份脚本，万一以后用得上。

```assembly
start = 0x80487A8
for idx in range(0x1000):
	if idx%16 == 0:
		print("")
	
    print(hex(get_wide_byte(start+idx)),end=',')
```

网上说把结束动调，把dump出来的解密后的数据再patch回去，贴一个脚本

```assembly
start = 0x80487A8
a = [0x55,0x89,0xe5,0x53,0x83,0xec,0x34,0x8b,0x45,0x8,0x89,
	0x45,0xd4,0x65,0xa1,0x14,0x0,0x0,0x0,0x89,0x45,0xf4,0x31,
	0xc0,0x8b,0x45,0xd4,0x8b,0x40,0x20,0xf,0xb6,0x0,0x3c,0x71,
	0x75,0x2f,0x8b,0x45,0xd4,0x8b,0x40,0x18,0x8d,0x50,0xfc,
	0x8b,0x45,0xd4,0x89,0x50,0x18,0x8b,0x45,0xd4,0x8b,0x40,
	0x18,0x8b,0x55,0xd4,0x8b,0x52,0x20,0x8b,0x52,0x1,0x89,
	0x10,0x8b,0x45,0xd4,0x8b,0x40,0x20,0x8d,0x50,0x5,0x8b,
	0x45,0xd4,0x89,0x50,0x20,0x8b,0x45,0xd4,0x8b,0x40,0x20,
	0xf,0xb6,0x0,0x3c,0x41,0x75,0x23,0x8b,0x45,0xd4,0x8b,
	0x50,0x4,0x8b,0x45,0xd4,0x8b,0x40,0x8,0x1,0xc2,0x8b,0x45,
	0xd4,0x89,0x50,0x4,0x8b,0x45,0xd4,0x8b,0x40,0x20,0x8d,0x50,
	0x1,0x8b,0x45,0xd4,0x89,0x50,0x20,0x8b,0x45,0xd4,0x8b,0x40,
	0x20,0xf,0xb6,0x0,0x3c,0x42,0x75,0x23,0x8b,0x45,0xd4,0x8b,
	0x50,0x4,0x8b,0x45,0xd4,0x8b,0x40,0x10,0x29,0xc2,0x8b,0x45,
	0xd4,0x89,0x50,0x4,0x8b,0x45,0xd4,0x8b,0x40,0x20,0x8d,0x50,
	0x1,0x8b,0x45,0xd4,0x89,0x50,0x20,0x8b,0x45,0xd4,0x8b,0x40,
	0x20,0xf,0xb6,0x0,0x3c,0x43,0x75,0x24,0x8b,0x45,0xd4,0x8b,
	0x50,0x4,0x8b,0x45,0xd4,0x8b,0x40,0xc,0xf,0xaf,0xd0,0x8b,
	0x45,0xd4,0x89,0x50,0x4,0x8b,0x45,0xd4,0x8b,0x40,0x20,0x8d,
	0x50,0x1,0x8b,0x45,0xd4,0x89,0x50,0x20,0x8b,0x45,0xd4,0x8b,
	0x40,0x20,0xf,0xb6,0x0,0x3c,0x37,0x75,0x1b,0x8b,0x45,0xd4,
	0x8b,0x50,0x14,0x8b,0x45,0xd4,0x89,0x50,0x4,0x8b,0x45,0xd4,
	0x8b,0x40,0x20,0x8d,0x50,0x1,0x8b,0x45,0xd4,0x89,0x50,0x20,
	0x8b,0x45,0xd4,0x8b,0x40,0x20,0xf,0xb6,0x0,0x3c,0x38,0x75,
	0x23,0x8b,0x45,0xd4,0x8b,0x50,0x4,0x8b,0x45,0xd4,0x8b,0x40,
	0x10,0x31,0xc2,0x8b,0x45,0xd4,0x89,0x50,0x4,0x8b,0x45,0xd4,
	0x8b,0x40,0x20,0x8d,0x50,0x1,0x8b,0x45,0xd4,0x89,0x50,0x20,
	0x8b,0x45,0xd4,0x8b,0x40,0x20,0xf,0xb6,0x0,0x3c,0x39,0x75,
	0x23,0x8b,0x45,0xd4,0x8b,0x50,0x4,0x8b,0x45,0xd4,0x8b,0x40,
	0x14,0x31,0xc2,0x8b,0x45,0xd4,0x89,0x50,0x4,0x8b,0x45,0xd4,
	0x8b,0x40,0x20,0x8d,0x50,0x1,0x8b,0x45,0xd4,0x89,0x50,0x20,
	0x8b,0x45,0xd4,0x8b,0x40,0x20,0xf,0xb6,0x0,0x3c,0x35,0x75,
	0x1b,0x8b,0x45,0xd4,0x8b,0x50,0x4,0x8b,0x45,0xd4,0x89,0x50,
	0x14,0x8b,0x45,0xd4,0x8b,0x40,0x20,0x8d,0x50,0x1,0x8b,0x45,
	0xd4,0x89,0x50,0x20,0x8b,0x45,0xd4,0x8b,0x40,0x20,0xf,0xb6,
	0x0,0x3c,0xf7,0x75,0x23,0x8b,0x45,0xd4,0x8b,0x50,0x24,0x8b,
	0x45,0xd4,0x8b,0x40,0x4,0x1,0xc2,0x8b,0x45,0xd4,0x89,0x50,
	0x24,0x8b,0x45,0xd4,0x8b,0x40,0x20,0x8d,0x50,0x1,0x8b,0x45,
	0xd4,0x89,0x50,0x20,0x8b,0x45,0xd4,0x8b,0x40,0x20,0xf,0xb6,
	0x0,0x3c,0x44,0x75,0x2a,0x8b,0x45,0xd4,0x8b,0x40,0x4,0x8b,
	0x55,0xd4,0x8b,0x5a,0x14,0xba,0x0,0x0,0x0,0x0,0xf7,0xf3,0x89,0xc2]
for i in range(len(a)):
    ida_bytes.patch_byte(start+i, a[i])
```

但是其实不用这么麻烦，可以直接C将解密后的数据强制转为代码，再P强制转为函数，得到dispatch函数

```assembly
// positive sp value has been detected, the output may be wrong!
unsigned int __usercall sub_80487AF@<eax>(int a1@<ebp>)
{
  int v1; // ebx

  *(_DWORD *)(a1 - 0x2C) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 0xC) = __readgsdword(0x14u);
  while ( 1 )
  {
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x71 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x18) -= 4;
      **(_DWORD **)(*(_DWORD *)(a1 - 0x2C) + 0x18) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) + 1);
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 5;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x41 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) += *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 8);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x42 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) -= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x10);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x43 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) *= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0xC);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x37 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) = *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x14);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x38 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) ^= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x10);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x39 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) ^= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x14);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x35 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x14) = *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xF7 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x24) += *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x44 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) /= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x14);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x80 )
    {
      v1 = *(_DWORD *)(a1 - 0x2C);
      *(_DWORD *)(v1 + 4 * sub_804875F(v1, 1)) = *(_DWORD *)(*(_DWORD *)(v1 + 0x20) + 2);
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 6;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x77 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) ^= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x24);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x53 )
    {
      putchar(**(char **)(*(_DWORD *)(a1 - 0x2C) + 0xC));
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 2;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x22 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) >>= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 8);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x23 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) <<= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 8);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x99 )
      break;
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x76 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0xC) = **(_DWORD **)(*(_DWORD *)(a1 - 0x2C) + 0x18);
      **(_DWORD **)(*(_DWORD *)(a1 - 0x2C) + 0x18) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x18) += 4;
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 5;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x54 )
    {
      *(_DWORD *)(a1 - 0x20) = *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0xC);
      **(_BYTE **)(a1 - 0x20) = getchar();
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 2;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x30 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) |= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 8);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x31 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) &= *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 8);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x32 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0xC) = *(unsigned __int8 *)(*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) + 1);
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 2;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 9 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) = 0x6FEBF967;
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x10 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x24) = *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x33 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x10) = *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x34 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 8) = *(unsigned __int8 *)(*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) + 1);
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 2;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xFE )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) = *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x24);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0x11 )
    {
      printf("%x\n", *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4));
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xA0 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) != 0x6FEBF967 )
        exit(0);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xA1 )
    {
      read(0, s, 0x2Cu);
      if ( strlen(s) != 0x2C )
        exit(0);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xB1 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x24) = dword_804B080[0];
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xB2 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x24) = dword_804B084;
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xA4 )
    {
      *(_DWORD *)(a1 - 0x1C) = *(unsigned __int8 *)(*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) + 1);
      *(_DWORD *)(a1 - 0x18) = *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4);
      dword_804B080[*(_DWORD *)(a1 - 0x1C)] = *(_DWORD *)(a1 - 0x18);
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 4;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xB3 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x24) = dword_804B088;
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xB4 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x24) = dword_804B08C;
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xC1 )
    {
      *(_DWORD *)(a1 - 0x14) = *(unsigned __int8 *)(*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) + 1);
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) = *(unsigned __int8 *)(*(_DWORD *)(a1 - 0x14) + 0x804B340);
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 2;
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xC7 )
    {
      if ( dword_804B060 != *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) )
        exit(0);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xC8 )
    {
      if ( dword_804B064 != *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) )
        exit(0);
      ++*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20);
    }
    if ( **(_BYTE **)(*(_DWORD *)(a1 - 0x2C) + 0x20) == 0xC2 )
    {
      *(_DWORD *)(a1 - 0x10) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) + 1);
      if ( (unsigned __int8)*(_DWORD *)(a1 - 0x10) != *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 4) )
        exit(0);
      *(_DWORD *)(*(_DWORD *)(a1 - 0x2C) + 0x20) += 5;
    }
  }
  return __readgsdword(0x14u) ^ *(_DWORD *)(a1 - 0xC);
}
```

艹，发现代码可读性不高，按照wp的方法来，不知道哪个细节不对，还是不行，不过也能将就看。

因为a1是int类型，4个字节，所以

 \*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C))就是a1[0]

\*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C) + 0x04)就是a1[1]

\*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C) + 0x08)就是a1[2]

\*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C) + 0x0c)就是a1[3]

\*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C) + 0x10)就是a1[4]

\*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C) + 0x14)就是a1[5]

\*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C) + 0x18)就是a1[6]

\*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C) + 0x1c)就是a1[7]

\*\*(\_BYTE \*\*)(\*(\_DWORD \*)(a1 - 0x2C) + 0x20)就是a1[8]

…………………………

```assembly
// positive sp value has been detected, the output may be wrong!
unsigned int __usercall sub_80487AF@<eax>(int a1@<ebp>)
{
  int v1; // ebx

  *(_DWORD *)(a1 - 0x2C) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 0xC) = __readgsdword(0x14u);
  while ( 1 )
  {
    if ( *a1[8] == 0x71 )
    {
      a1[6] -= 4;
      *a1[6] = *(a1[8] + 1);
      a1[8] += 5;
    }
    if ( *a1[8] == 0x41 )
    {
      a1[1] += a1[2];
      ++a1[8];
    }
    if ( *a1[8] == 0x42 )
    {
      a1[1] -= a1[4];
      ++a1[8];
    }
    if ( *a1[8] == 0x43 )
    {
      a1[1] *= a1[3];
      ++a1[8];
    }
    if ( *a1[8] == 0x37 )
    {
      a1[1] = a1[5];
      ++a1[8];
    }
    if ( *a1[8] == 0x38 )
    {
      a1[1] ^= a1[4];
      ++a1[8];
    }
    if ( *a1[8] == 0x39 )
    {
      a1[1] ^= a1[5];
      ++a1[8];
    }
    if ( *a1[8] == 0x35 )
    {
      a1[5] = a1[1];
      ++a1[8];
    }
    if ( *a1[8] == 0xF7 )
    {
      a1[9] += a1[1];
      ++a1[8];
    }
    if ( *a1[8] == 0x44 )
    {
      a1[1] /= a1[5];
      ++a1[8];
    }
    if ( *a1[8] == 0x80 )
    {
      a1[sub_804875F(a1, 1) = *(a1[8] + 2);
      a1[8] += 6;
    }
    if ( *a1[8] == 0x77 )
    {
      a1[1] ^= a1[9];
      ++a1[8];
    }
    if ( *a1[8] == 0x53 )
    {
      putchar(*a1[3]);
      a1[8] += 2;
    }
    if ( *a1[8] == 0x22 )
    {
      a1[1] >>= a1[2];
      ++a1[8];
    }
    if ( *a1[8] == 0x23 )
    {
      a1[1] <<= a1[2];
      ++a1[8];
    }
    if ( a1[8] == 0x99 )
      break;
    if ( a1[8] == 0x76 )
    {
      a1[3] = *a1[6];
      a1[6] = 0;
      a1[6] += 4;
      a1[8] += 5;
    }
    if ( *a1[8] == 0x54 )
    {
      v2 = a1[3];
      *v2 = getchar();
      a1[8] += 2;
    }
    if ( *a1[8] == 0x30 )
    {
      a1[1] |= a1[2];
      ++a1[8];
    }
    if ( *a1[8] == 0x31 )
    {
      a1[1] &= a1[2];
      ++a1[8];
    }
    if ( *a1[8] == 0x32 )
    {
      a1[3] = *(a1[8] + 1);
      a1[8] += 2;
    }
    if ( *a1[8] == 9 )
    {
      a1[1] = 0x6FEBF967;
      ++a1[8];
    }
    if ( *a1[8] == 0x10 )
    {
      a1[9] = a1[1];
      ++a1[8];
    }
    if ( *a1[8] == 0x33 )
    {
      a1[4] = a1[1];
      ++a1[8];
    }
    if ( *a1[8] == 0x34 )
    {
      a1[2] = *(a1[8] + 1);
      a1[8] += 2;
    }
    if ( *a1[8] == 0xFE )
    {
      a1[1] = a1[9];
      ++a1[8];
    }
    if ( *a1[8] == 0x11 )
    {
      printf("%x\n", a1[1]);
      ++a1[8];
    }
    if ( *a1[8] == 0xA0 )
    {
      if ( a1[1] != 0x6FEBF967 )
        exit(0);
      ++a1[8];
    }
    if ( *a1[8] == 0xA1 )
    {
      read(0, s, 0x2Cu);
      if ( strlen(s) != 0x2C )
        exit(0);
      ++a1[8];
    }
    if ( *a1[8] == 0xB1 )
    {
      a1[9] = dword_804B080[0];
      ++a1[8];
    }
    if ( *a1[8] == 0xB2 )
    {
      a1[9] = dword_804B084;
      ++a1[8];
    }
    if ( *a1[8] == 0xA4 )
    {
      dword_804B084[*(a1[8] + 1)] = a1[1];
      a1[8] += 4;
    }
    if ( *a1[8] == 0xB3 )
    {
      a1[9] = dword_804B088;
      ++a1[8];
    }
    if ( *a1[8] == 0xB4 )
    {
      a1[9] = dword_804B08C;
      ++a1[8];
    }
    if ( *a1[8] == 0xC1 )
    {
      a1[1] = s[*(a1[8] + 1)];
      a1[8] += 2;
    }
    if ( *a1[8] == 0xC7 )
    {
      if ( dword_804B060 != a1[1] )
        exit(0);
      ++a1[8];
    }
    if ( *a1[8] == 0xC8 )
    {
      if ( dword_804B064 != a1[1] )
        exit(0);
      ++a1[8];
    }
    if ( *a1[8] == 0xC2 )
    {
      if ( *(a1[8] + 1) != a1[1] )
        exit(0);
      a1[8] += 5;
    }
  }
  return __readgsdword(0x14u) ^ *(_DWORD *)(a1 - 0xC);
}
```

dword_804B080

```assembly
.data:0804B080                 db  7Bh ; {
.data:0804B081                 db    0
.data:0804B082                 db    0
.data:0804B083                 db    0
.data:0804B084                 db  2Fh ; /
.data:0804B085                 db    0
.data:0804B086                 db    0
.data:0804B087                 db    0
.data:0804B088                 db  37h ; 7
.data:0804B089                 db    0
.data:0804B08A                 db    0
.data:0804B08B                 db    0
.data:0804B08C                 db 0E8h
.data:0804B08D                 db    0
.data:0804B08E                 db    0
.data:0804B08F                 db    0
```

dword_804B060

```assembly
.data:0804B060                 db 0DCh
.data:0804B061                 db    4
.data:0804B062                 db  13h
.data:0804B063                 db 0CFh
.data:0804B064                 db  84h
.data:0804B065                 db  8Eh
.data:0804B066                 db  3Bh ; ;
.data:0804B067                 db  28h ; (
```

即0x0CF1304DC和0x283B8E84

而关于sub_804875F简单分析一下

```assembly
int __cdecl sub_804875F(int a1, unsigned int a2)
{
  int result; // eax

  result = 0;
  if ( a2 <= 2 )
    result = *(unsigned __int8 *)(*(_DWORD *)(a1 + 0x20) + a2);
  return result;
}
```

我们知道*(_DWORD *)(a1 + 0x20)是a1[8]也就是opcode[i]，所以返回的结果就是opcode[i+a2]。

写脚本输出vm执行过程

```assembly
#include <stdio.h>

int main(){
    int opcode[550]={ 0xA1, 0xC1, 0x00, 0xB1, 0x77, 0xC2, 0x4A, 0x01, 0x00, 0x00,
                      0xC1, 0x01, 0xB2, 0x77, 0xC2, 0x19, 0x01, 0x00, 0x00, 0xC1,
                      0x02, 0xB4, 0x77, 0xC2, 0xDD, 0x01, 0x00, 0x00, 0xC1, 0x03,
                      0xB3, 0x77, 0xC2, 0x0F, 0x01, 0x00, 0x00, 0xC1, 0x04, 0xB2,
                      0x77, 0xC2, 0x1B, 0x01, 0x00, 0x00, 0xC1, 0x05, 0xB4, 0x77,
                      0xC2, 0x89, 0x01, 0x00, 0x00, 0xC1, 0x06, 0xB1, 0x77, 0xC2,
                      0x19, 0x01, 0x00, 0x00, 0xC1, 0x07, 0xB3, 0x77, 0xC2, 0x54,
                      0x01, 0x00, 0x00, 0xC1, 0x08, 0xB1, 0x77, 0xC2, 0x4F, 0x01,
                      0x00, 0x00, 0xC1, 0x09, 0xB1, 0x77, 0xC2, 0x4E, 0x01, 0x00,
                      0x00, 0xC1, 0x0A, 0xB3, 0x77, 0xC2, 0x55, 0x01, 0x00, 0x00,
                      0xC1, 0x0B, 0xB3, 0x77, 0xC2, 0x56, 0x01, 0x00, 0x00, 0xC1,
                      0x0C, 0xB4, 0x77, 0xC2, 0x8E, 0x00, 0x00, 0x00, 0xC1, 0x0D,
                      0xB2, 0x77, 0xC2, 0x49, 0x00, 0x00, 0x00, 0xC1, 0x0E, 0xB3,
                      0x77, 0xC2, 0x0E, 0x01, 0x00, 0x00, 0xC1, 0x0F, 0xB1, 0x77,
                      0xC2, 0x4B, 0x01, 0x00, 0x00, 0xC1, 0x10, 0xB3, 0x77, 0xC2,
                      0x06, 0x01, 0x00, 0x00, 0xC1, 0x11, 0xB3, 0x77, 0xC2, 0x54,
                      0x01, 0x00, 0x00, 0xC1, 0x12, 0xB2, 0x77, 0xC2, 0x1A, 0x00,
                      0x00, 0x00, 0xC1, 0x13, 0xB1, 0x77, 0xC2, 0x42, 0x01, 0x00,
                      0x00, 0xC1, 0x14, 0xB3, 0x77, 0xC2, 0x53, 0x01, 0x00, 0x00,
                      0xC1, 0x15, 0xB1, 0x77, 0xC2, 0x1F, 0x01, 0x00, 0x00, 0xC1,
                      0x16, 0xB3, 0x77, 0xC2, 0x52, 0x01, 0x00, 0x00, 0xC1, 0x17,
                      0xB4, 0x77, 0xC2, 0xDB, 0x00, 0x00, 0x00, 0xC1, 0x18, 0xB1,
                      0x77, 0xC2, 0x19, 0x01, 0x00, 0x00, 0xC1, 0x19, 0xB4, 0x77,
                      0xC2, 0xD9, 0x00, 0x00, 0x00, 0xC1, 0x1A, 0xB1, 0x77, 0xC2,
                      0x19, 0x01, 0x00, 0x00, 0xC1, 0x1B, 0xB3, 0x77, 0xC2, 0x55,
                      0x01, 0x00, 0x00, 0xC1, 0x1C, 0xB2, 0x77, 0xC2, 0x19, 0x00,
                      0x00, 0x00, 0xC1, 0x1D, 0xB3, 0x77, 0xC2, 0x00, 0x01, 0x00,
                      0x00, 0xC1, 0x1E, 0xB1, 0x77, 0xC2, 0x4B, 0x01, 0x00, 0x00,
                      0xC1, 0x1F, 0xB2, 0x77, 0xC2, 0x1E, 0x00, 0x00, 0x00, 0xC1,
                      0x20, 0x80, 0x02, 0x18, 0x00, 0x00, 0x00, 0x23, 0x10, 0xC1,
                      0x21, 0x80, 0x02, 0x10, 0x00, 0x00, 0x00, 0x23, 0xF7, 0xC1,
                      0x22, 0x80, 0x02, 0x08, 0x00, 0x00, 0x00, 0x23, 0xF7, 0xC1,
                      0x23, 0xF7, 0xFE, 0x80, 0x02, 0x05, 0x00, 0x00, 0x00, 0x22,
                      0x77, 0x10, 0x80, 0x02, 0x07, 0x00, 0x00, 0x00, 0x23, 0x80,
                      0x02, 0x23, 0x77, 0xF1, 0x98, 0x31, 0x77, 0x10, 0x80, 0x02,
                      0x18, 0x00, 0x00, 0x00, 0x23, 0x80, 0x02, 0x20, 0xB9, 0xE4,
                      0x35, 0x31, 0x77, 0x10, 0x80, 0x02, 0x12, 0x00, 0x00, 0x00,
                      0x22, 0x77, 0xA0, 0xC1, 0x24, 0x80, 0x02, 0x18, 0x00, 0x00,
                      0x00, 0x23, 0x10, 0xC1, 0x25, 0x80, 0x02, 0x10, 0x00, 0x00,
                      0x00, 0x23, 0xF7, 0xC1, 0x26, 0x80, 0x02, 0x08, 0x00, 0x00,
                      0x00, 0x23, 0xF7, 0xC1, 0x27, 0xF7, 0xFE, 0x32, 0x20, 0x43,
                      0x33, 0x77, 0x80, 0x02, 0x11, 0x00, 0x00, 0x00, 0x22, 0x35,
                      0x37, 0x38, 0x77, 0x80, 0x02, 0x0D, 0x00, 0x00, 0x00, 0x23,
                      0x77, 0x38, 0x39, 0x10, 0x32, 0x20, 0x43, 0x33, 0x77, 0x80,
                      0x02, 0x11, 0x00, 0x00, 0x00, 0x22, 0x35, 0x37, 0x38, 0x77,
                      0x80, 0x02, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x77, 0x38, 0x39,
                      0xC7, 0xC1, 0x28, 0x80, 0x02, 0x18, 0x00, 0x00, 0x00, 0x23,
                      0x10, 0xC1, 0x29, 0x80, 0x02, 0x10, 0x00, 0x00, 0x00, 0x23,
                      0xF7, 0xC1, 0x2A, 0x80, 0x02, 0x08, 0x00, 0x00, 0x00, 0x23,
                      0xF7, 0xC1, 0x2B, 0xF7, 0xFE, 0x32, 0x20, 0x43, 0x33, 0x77,
                      0x80, 0x02, 0x11, 0x00, 0x00, 0x00, 0x22, 0x35, 0x37, 0x38,
                      0x77, 0x80, 0x02, 0x0D, 0x00, 0x00, 0x00, 0x23, 0x77, 0x38,
                      0x39, 0x10, 0x32, 0x20, 0x43, 0x33, 0x77, 0x80, 0x02, 0x11,
                      0x00, 0x00, 0x00, 0x22, 0x35, 0x37, 0x38, 0x77, 0x80, 0x02,
                      0x0D, 0x00, 0x00, 0x00, 0x23, 0x77, 0x38, 0x39, 0xC8, 0x99 };
    int i = 0, a1[8] = {0};
    while ( 1 ){
        if ( opcode[i] == 0x71 ){
          //a1[6] = opcode[i+1];
          printf("a1[6] = %d\n", opcode[i+1]);
          i += 5;
        }
        if ( opcode[i] == 0x41 ){
          //a1[1] += a1[2];
          printf("a1[1] += a1[2]\n");
          ++i;
        }
        if ( opcode[i] == 0x42 ){
          //a1[1] -= a1[4];
          printf("a1[1] -= a1[4]\n");
          ++i;
        }
        if ( opcode[i] == 0x43 ){
          //a1[1] *= a1[3];
          printf("a1[1] *= a1[3]\n");
          ++i;
        }
        if ( opcode[i] == 0x37 ){
          //a1[1] = a1[5]
          printf("a1[1] = a1[5]\n");
          ++i;
        }
        if ( opcode[i] == 0x38 ){
          //a1[1] ^= a1[4]
          printf("a1[1] ^= a1[4]\n");
          ++i;
        }
        if ( opcode[i] == 0x39 ){
          //a1[1] ^= a1[5];
          printf("a1[1] ^= a1[5]\n");
          ++i;
        }
        if ( opcode[i] == 0x35 ){
          //a1[5] = a1[1];
          printf("a1[5] = a1[1]\n");
          ++i;
        }
        if ( opcode[i] == 0xF7 ){
          //a1[9] += a1[1]
          printf("a1[9] += a1[1]\n");
          ++i;
        }
        if ( opcode[i] == 0x44 ){
          //a1[1] /= a1[5];
          printf("a1[1] /= a1[5]\n");
          ++i;
        }
        if ( opcode[i] == 0x80 ){
          //a1[sub_804875F(a1, 1) = *(a1[8] + 2);
          //printf("a1[sub_804875F(a1, 1)] = %d\n", opcode[i+2]);
          printf("a1[%d] = %d\n", opcode[i+1], opcode[i+2]);
          i += 6;
        }
        if ( opcode[i] == 0x77 ){
          //a1[1] ^= a1[9];
          printf("a1[1] ^= a1[9]\n");
          ++i;
        }
        if ( opcode[i] == 0x53 ){
          //putchar(a1[3]);
          printf("putchar(a1[3])\n");
          i += 2;
        }
        if ( opcode[i] == 0x22 ){
          //a1[1] >>= a1[2];
          printf("a1[1] >>= a1[2]\n");
          ++i;
        }
        if ( opcode[i] == 0x23 ){
          //a1[1] <<= a1[2];
          printf("a1[1] <<= a1[2]\n");
          ++i;
        }
        if ( opcode[i] == 0x99 )
          break;
        if ( opcode[i] == 0x76 ){
          //a1[3] = a1[6];
          printf("a1[3] = a1[6]\n");
          //a1[6] = 4;
          printf("a1[6] = 4\n");
          i += 5;
        }
        if ( opcode[i] == 0x54 ){
          //a1[3] = getchar();
          printf("a1[3] = getchar()\n");
          i += 2;
        }
        if ( opcode[i] == 0x30 ){
          //a1[1] |= a1[2];
          printf("a1[1] |= a1[2]\n");
          ++i;
        }
        if ( opcode[i] == 0x31 ){
          //a1[1] &= a1[2];
          printf("a1[1] &= a1[2]\n");
          ++i;
        }
        if ( opcode[i] == 0x32 ){
          //a1[3] = opcode[i+1];
          printf("a1[3] = %d\n", opcode[i+1]);
          i += 2;
        }
        if ( opcode[i] == 9 ){
          //a1[1] = 0x6FEBF967;
          printf("a1[1] = 0x6FEBF967\n");
          ++i;
        }
        if ( opcode[i] == 0x10 ){
          //a1[9] = a1[1];
          printf("a1[9] = a1[1]\n");
          ++i;
        }
        if ( opcode[i] == 0x33 ){
          //a1[4] = a1[1];
          printf("a1[4] = a1[1]\n");
          ++i;
        }
        if ( opcode[i] == 0x34 ){
          //a1[2] = opcode[i+1];
          printf("a1[2] = &d\n", opcode[i+1]);
          i += 2;
        }
        if ( opcode[i] == 0xFE ){
          //a1[1] = a1[9];
          printf("a1[1] = a1[9]\n");
          ++i;
        }
        if ( opcode[i] == 0x11 ){
          //printf(\"%x\\n\", a1[1])
          printf("printf(\"%x\\n\", a1[1])\n");
          ++i;
        }
        if ( opcode[i] == 0xA0 ){
          //if ( a1[1] != 0x6FEBF967 )
          printf("if( a1[1] != 0x6FEBF967 )\n");
          printf("    exit(0)\n");
            //exit(0);
          ++i;
        }
        if ( opcode[i] == 0xA1 ){
          //read(0, s, 0x2Cu);
          printf("read(0, s, 0x2Cu)\n");
          printf("if ( strlen(s) != 0x2C )\n");
          //if ( strlen(s) != 0x2C )
          printf("    exit(0)\n");
            //exit(0);
          ++i;
        }
        if ( opcode[i] == 0xB1 ){
          //a1[9] = dword_804B080[0];
          printf("a1[9] = dword_804B080[0]\n");
          ++i;
        }
        if ( opcode[i] == 0xB2 ){
          //a1[9] = dword_804B084;
          printf("a1[9] = dword_804B084\n");
          ++i;
        }
        /*
        if ( opcode[i] == 0xA4 ){
          dword_804B084[opcode[i+1]] = a1[1];
          i += 4;
        }
        */
        if ( opcode[i] == 0xB3 ){
          //a1[9] = dword_804B088;
          printf("a1[9] = dword_804B088\n");
          ++i;
        }
        if ( opcode[i] == 0xB4 ){
          //a1[9] = dword_804B08C;
          printf("a1[9] = dword_804B08C\n");
          ++i;
        }
        if ( opcode[i] == 0xC1 ){
          //a1[1] = s[opcode[i+1]];
          printf("a1[1] = s[%d]\n", opcode[i+1]);
          i += 2;
        }
        if ( opcode[i] == 0xC7 ){
          //if ( 0x0CF1304DC != a1[1] )
          printf("if ( 0x0CF1304DC != a1[1] )\n");
          printf("    exit(0)\n");
            //exit(0);
          ++i;
        }
        if ( opcode[i] == 0xC8 ){
          //if ( 0x283B8E84 != a1[1] )
          printf("if ( 0x283B8E84 != a1[1] )\n");
          printf("    exit(0)\n");
            //exit(0);
          ++i;
        }
        if ( opcode[i] == 0xC2 ){
          //if ( opcode[i+1] != a1[1] )
          printf("if ( %d != a1[1] )\n", opcode[i+1]);
          printf("    exit(0)\n");
            //exit(0);
          i += 5;
        }
    }
    return 0;
}
```

得到vm程序执行流程

```assembly
read(0, s, 0x2Cu)
if ( strlen(s) != 0x2C )
    exit(0)
    
a1[1] = s[0]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 74 != a1[1] )
    exit(0)
    
a1[1] = s[1]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[2]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 221 != a1[1] )
    exit(0)
    
a1[1] = s[3]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 15 != a1[1] )
    exit(0)
    
a1[1] = s[4]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 27 != a1[1] )
    exit(0)
    
a1[1] = s[5]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 137 != a1[1] )
    exit(0)
    
a1[1] = s[6]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[7]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 84 != a1[1] )
    exit(0)
    
a1[1] = s[8]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 79 != a1[1] )
    exit(0)
    
a1[1] = s[9]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 78 != a1[1] )
    exit(0)
    
a1[1] = s[10]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 85 != a1[1] )
    exit(0)
    
a1[1] = s[11]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 86 != a1[1] )
    exit(0)
    
a1[1] = s[12]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 142 != a1[1] )
    exit(0)
    
a1[1] = s[13]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 73 != a1[1] )
    exit(0)
    
a1[1] = s[14]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 14 != a1[1] )
    exit(0)
    
a1[1] = s[15]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 75 != a1[1] )
    exit(0)
    
a1[1] = s[16]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 6 != a1[1] )
    exit(0)
    
a1[1] = s[17]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 84 != a1[1] )
    exit(0)
    
a1[1] = s[18]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 26 != a1[1] )
    exit(0)
    
a1[1] = s[19]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 66 != a1[1] )
    exit(0)
    
a1[1] = s[20]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 83 != a1[1] )
    exit(0)
    
a1[1] = s[21]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 31 != a1[1] )
    exit(0)
    
a1[1] = s[22]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 82 != a1[1] )
    exit(0)
    
a1[1] = s[23]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 219 != a1[1] )
    exit(0)
    
a1[1] = s[24]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[25]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 217 != a1[1] )
    exit(0)
    
a1[1] = s[26]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[27]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 85 != a1[1] )
    exit(0)
    
a1[1] = s[28]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[29]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 0 != a1[1] )
    exit(0)
    
a1[1] = s[30]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 75 != a1[1] )
    exit(0)
    
a1[1] = s[31]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 30 != a1[1] )
    exit(0)


a1[1] = s[32]
a1[2] = 24
a1[1] <<= a1[2]
a1[9] = a1[1]

a1[1] = s[33]
a1[2] = 16
a1[1] <<= a1[2]
a1[9] += a1[1]

a1[1] = s[34]
a1[2] = 8
a1[1] <<= a1[2]
a1[9] += a1[1]

a1[1] = s[35]
a1[9] += a1[1]

a1[1] = a1[9]  // a << 24 + b << 16 + c << 8 + d
a1[2] = 5
a1[1] >>= a1[2]  // (a << 24 + b << 16 + c << 8 + d) >> 5
a1[1] ^= a1[9]  // ((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d)
a1[9] = a1[1]  // ((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d)
a1[2] = 7
a1[1] <<= a1[2]  // (((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d)) << 7
a1[2] = 35
a1[1] &= a1[2]  // ((((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d)) << 7) & 35
a1[1] ^= a1[9] // (((((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d)) << 7) & 35) ^ (((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d))
a1[9] = a1[1]  // (((((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d)) << 7) & 35) ^ (((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d))
a1[2] = 24
a1[1] <<= a1[2]  // ((((((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d)) << 7) & 35) ^ (((a << 24 + b << 16 + c << 8 + d) >> 5) ^ (a << 24 + b << 16 + c << 8 + d))) << 24
a1[2] = 32
a1[1] &= a1[2]
a1[1] ^= a1[9]
a1[9] = a1[1]
a1[2] = 18
a1[1] >>= a1[2]
a1[1] ^= a1[9]
if( a1[1] != 0x6FEBF967 )
    exit(0)

a1[1] = s[36]
a1[2] = 24
a1[1] <<= a1[2]
a1[9] = a1[1]
a1[1] = s[37]
a1[2] = 16
a1[1] <<= a1[2]
a1[9] += a1[1]
a1[1] = s[38]
a1[2] = 8
a1[1] <<= a1[2]
a1[9] += a1[1]
a1[1] = s[39]
a1[9] += a1[1]
a1[1] = a1[9]
a1[3] = 32
a1[1] *= a1[3]
a1[4] = a1[1]
a1[1] ^= a1[9]
a1[2] = 17
a1[1] >>= a1[2]
a1[5] = a1[1]
a1[1] = a1[5]
a1[1] ^= a1[4]
a1[1] ^= a1[9]
a1[2] = 13
a1[1] <<= a1[2]
a1[1] ^= a1[9]
a1[1] ^= a1[4]
a1[1] ^= a1[5]
a1[9] = a1[1]
a1[3] = 32
a1[1] *= a1[3]
a1[4] = a1[1]
a1[1] ^= a1[9]
a1[2] = 17
a1[1] >>= a1[2]
a1[5] = a1[1]
a1[1] = a1[5]
a1[1] ^= a1[4]
a1[1] ^= a1[9]
a1[2] = 13
a1[1] <<= a1[2]
a1[1] ^= a1[9]
a1[1] ^= a1[4]
a1[1] ^= a1[5]
if ( 0x0CF1304DC != a1[1] )
    exit(0)

a1[1] = s[40]
a1[2] = 24
a1[1] <<= a1[2]
a1[9] = a1[1]
a1[1] = s[41]
a1[2] = 16
a1[1] <<= a1[2]
a1[9] += a1[1]
a1[1] = s[42]
a1[2] = 8
a1[1] <<= a1[2]
a1[9] += a1[1]
a1[1] = s[43]
a1[9] += a1[1]
a1[1] = a1[9]
a1[3] = 32
a1[1] *= a1[3]
a1[4] = a1[1]
a1[1] ^= a1[9]
a1[2] = 17
a1[1] >>= a1[2]
a1[5] = a1[1]
a1[1] = a1[5]
a1[1] ^= a1[4]
a1[1] ^= a1[9]
a1[2] = 13
a1[1] <<= a1[2]
a1[1] ^= a1[9]
a1[1] ^= a1[4]
a1[1] ^= a1[5]
a1[9] = a1[1]
a1[3] = 32
a1[1] *= a1[3]
a1[4] = a1[1]
a1[1] ^= a1[9]
a1[2] = 17
a1[1] >>= a1[2]
a1[5] = a1[1]
a1[1] = a1[5]
a1[1] ^= a1[4]
a1[1] ^= a1[9]
a1[2] = 13
a1[1] <<= a1[2]
a1[1] ^= a1[9]
a1[1] ^= a1[4]
a1[1] ^= a1[5]
if ( 0x283B8E84 != a1[1] )
    exit(0)
```

前32个字节直接异或

```assembly
flag = ""
result = [74, 25, 221, 15, 27, 137, 25, 84, 79, 78,
          85, 86, 142, 73, 14, 75, 6, 84, 26, 66,
          83, 31, 82, 219, 25, 217, 25, 85, 25, 0,
          75, 30]
dword = [0x7B, 0x2F, 0xE8, 0x37, 0x2F, 0xE8, 0x7B, 0x37, 0x7B, 0x7B,
         0x37, 0x37, 0xE8, 0x2F, 0x37, 0x7B, 0x37, 0x37, 0x2F, 0x7B,
         0x37, 0x7B, 0x37, 0xE8, 0x7B, 0xE8, 0x7B, 0x37, 0x2F, 0x37,
         0x7B, 0x2F]
for i in range(len(result)):
    flag += chr(result[i]^dword[i])


print(flag)
```

然后是接下来的12个字节，分为三组，简单分析了一下，加密过程有点复杂，所以直接爆破，但是我前面好像才了一个坑。

```
if ( *a1[8] == 0x80 )
{
    a1[sub_804875F(a1, 1) = *(a1[8] + 2);
    a1[8] += 6;
}
```

在处理这一步时，赋值操作只取了一个字节，但是应该是int是4个字节，修改后的vm执行流程应该是：

```assembly
read(0, s, 0x2Cu)
if ( strlen(s) != 0x2C )
    exit(0)
    
a1[1] = s[0]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 74 != a1[1] )
    exit(0)
    
a1[1] = s[1]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[2]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 221 != a1[1] )
    exit(0)
    
a1[1] = s[3]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 15 != a1[1] )
    exit(0)
    
a1[1] = s[4]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 27 != a1[1] )
    exit(0)
    
a1[1] = s[5]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 137 != a1[1] )
    exit(0)
    
a1[1] = s[6]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[7]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 84 != a1[1] )
    exit(0)
    
a1[1] = s[8]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 79 != a1[1] )
    exit(0)
    
a1[1] = s[9]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 78 != a1[1] )
    exit(0)
    
a1[1] = s[10]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 85 != a1[1] )
    exit(0)
    
a1[1] = s[11]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 86 != a1[1] )
    exit(0)
    
a1[1] = s[12]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 142 != a1[1] )
    exit(0)
    
a1[1] = s[13]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 73 != a1[1] )
    exit(0)
    
a1[1] = s[14]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 14 != a1[1] )
    exit(0)
    
a1[1] = s[15]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 75 != a1[1] )
    exit(0)
    
a1[1] = s[16]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 6 != a1[1] )
    exit(0)
    
a1[1] = s[17]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 84 != a1[1] )
    exit(0)
    
a1[1] = s[18]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 26 != a1[1] )
    exit(0)
    
a1[1] = s[19]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 66 != a1[1] )
    exit(0)
    
a1[1] = s[20]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 83 != a1[1] )
    exit(0)
    
a1[1] = s[21]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 31 != a1[1] )
    exit(0)
    
a1[1] = s[22]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 82 != a1[1] )
    exit(0)
    
a1[1] = s[23]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 219 != a1[1] )
    exit(0)
    
a1[1] = s[24]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[25]
a1[9] = dword_804B08C
a1[1] ^= a1[9]
if ( 217 != a1[1] )
    exit(0)
    
a1[1] = s[26]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[27]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 85 != a1[1] )
    exit(0)
    
a1[1] = s[28]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 25 != a1[1] )
    exit(0)
    
a1[1] = s[29]
a1[9] = dword_804B088
a1[1] ^= a1[9]
if ( 0 != a1[1] )
    exit(0)
    
a1[1] = s[30]
a1[9] = dword_804B080[0]
a1[1] ^= a1[9]
if ( 75 != a1[1] )
    exit(0)
    
a1[1] = s[31]
a1[9] = dword_804B084
a1[1] ^= a1[9]
if ( 30 != a1[1] )
    exit(0)


a1[1] = s[32]
a1[2] = 24
a1[1] <<= a1[2]
a1[9] = a1[1]

a1[1] = s[33]
a1[2] = 16
a1[1] <<= a1[2]
a1[9] += a1[1]

a1[1] = s[34]
a1[2] = 8
a1[1] <<= a1[2]
a1[9] += a1[1]

a1[1] = s[35]
a1[9] += a1[1]

a1[1] = a1[9]
a1[2] = 5
a1[1] >>= a1[2]
a1[1] ^= a1[9]
a1[9] = a1[1]
a1[2] = 7
a1[1] <<= a1[2]
a1[2] = 0x98f17723
a1[1] &= a1[2]
a1[1] ^= a1[9]
a1[9] = a1[1]
a1[2] = 24
a1[1] <<= a1[2]
a1[2] = 0x35e4b920
a1[1] &= a1[2]
a1[1] ^= a1[9]
a1[9] = a1[1]
a1[2] = 18
a1[1] >>= a1[2]
a1[1] ^= a1[9]
if( a1[1] != 0x6FEBF967 )
    exit(0)

a1[1] = s[36]
a1[2] = 24
a1[1] <<= a1[2]
a1[9] = a1[1]
a1[1] = s[37]
a1[2] = 16
a1[1] <<= a1[2]
a1[9] += a1[1]
a1[1] = s[38]
a1[2] = 8
a1[1] <<= a1[2]
a1[9] += a1[1]
a1[1] = s[39]
a1[9] += a1[1]
a1[1] = a1[9]
a1[3] = 32
a1[1] *= a1[3]
a1[4] = a1[1]
a1[1] ^= a1[9]
a1[2] = 17
a1[1] >>= a1[2]
a1[5] = a1[1]
a1[1] = a1[5]
a1[1] ^= a1[4]
a1[1] ^= a1[9]
a1[2] = 13
a1[1] <<= a1[2]
a1[1] ^= a1[9]
a1[1] ^= a1[4]
a1[1] ^= a1[5]
a1[9] = a1[1]
a1[3] = 32
a1[1] *= a1[3]
a1[4] = a1[1]
a1[1] ^= a1[9]
a1[2] = 17
a1[1] >>= a1[2]
a1[5] = a1[1]
a1[1] = a1[5]
a1[1] ^= a1[4]
a1[1] ^= a1[9]
a1[2] = 13
a1[1] <<= a1[2]
a1[1] ^= a1[9]
a1[1] ^= a1[4]
a1[1] ^= a1[5]
if ( 0x0CF1304DC != a1[1] )
    exit(0)

a1[1] = s[40]
a1[2] = 24
a1[1] <<= a1[2]
a1[9] = a1[1]
a1[1] = s[41]
a1[2] = 16
a1[1] <<= a1[2]
a1[9] += a1[1]
a1[1] = s[42]
a1[2] = 8
a1[1] <<= a1[2]
a1[9] += a1[1]
a1[1] = s[43]
a1[9] += a1[1]
a1[1] = a1[9]
a1[3] = 32
a1[1] *= a1[3]
a1[4] = a1[1]
a1[1] ^= a1[9]
a1[2] = 17
a1[1] >>= a1[2]
a1[5] = a1[1]
a1[1] = a1[5]
a1[1] ^= a1[4]
a1[1] ^= a1[9]
a1[2] = 13
a1[1] <<= a1[2]
a1[1] ^= a1[9]
a1[1] ^= a1[4]
a1[1] ^= a1[5]
a1[9] = a1[1]
a1[3] = 32
a1[1] *= a1[3]
a1[4] = a1[1]
a1[1] ^= a1[9]
a1[2] = 17
a1[1] >>= a1[2]
a1[5] = a1[1]
a1[1] = a1[5]
a1[1] ^= a1[4]
a1[1] ^= a1[9]
a1[2] = 13
a1[1] <<= a1[2]
a1[1] ^= a1[9]
a1[1] ^= a1[4]
a1[1] ^= a1[5]
if ( 0x283B8E84 != a1[1] )
    exit(0)
```

后12字节爆破

```assembly
#include <stdio.h>

int main(){
    int g_a1[10] = {0};

    for(int i=32; i<127; i++){
        //printf("\n%d ", i);
        for(int j=32; j<127; j++){
            for(int m=32; m<127; m++){
                for(int n=32; n<127; n++){
                    int a1[10] = {0};
                    a1[1] = i;
                    a1[2] = 24;
                    a1[1] <<= a1[2];
                    a1[9] = a1[1];

                    a1[1] = j;
                    a1[2] = 16;
                    a1[1] <<= a1[2];
                    a1[9] += a1[1];

                    a1[1] = m;
                    a1[2] = 8;
                    a1[1] <<= a1[2];
                    a1[9] += a1[1];

                    a1[1] = n;
                    a1[9] += a1[1];

                    a1[1] = a1[9];
                    a1[2] = 5;
                    a1[1] >>= a1[2];
                    a1[1] ^= a1[9];
                    a1[9] = a1[1];
                    a1[2] = 7;
                    a1[1] <<= a1[2];
                    a1[2] = 0x98f17723;
                    a1[1] &= a1[2];
                    a1[1] ^= a1[9];
                    a1[9] = a1[1];
                    a1[2] = 24;
                    a1[1] <<= a1[2];
                    a1[2] = 0x35e4b920;
                    a1[1] &= a1[2];
                    a1[1] ^= a1[9];
                    a1[9] = a1[1];
                    a1[2] = 18;
                    a1[1] >>= a1[2];
                    a1[1] ^= a1[9];
                    //printf("%x\n", a1[1]);
                    if( a1[1] == 0x6FEBF967 ){
                        printf("%c%c%c%c", i, j, m, n);
                        //puts("");
                        for(int k=0; k<10; k++){
                            //g_a1[k] = a1[k];
                            //printf("%d, ", a1[k]);
                        }
                        break;
                    }
                }
            }
        }
    }

    //for(int i=0; i<=0xffffffff; i++){

    for(int i=32; i<127; i++){
        for(int j=32; j<127; j++){
            for(int m=32; m<127; m++){
                for(int n=32; n<127; n++){

                    unsigned int a1[10] = {0};

                    a1[1] = i; // 0x62
                    a1[2] = 24;
                    a1[1] <<= a1[2];
                    a1[9] = a1[1];

                    a1[1] = j; // 0x30
                    a1[2] = 16;
                    a1[1] <<= a1[2];
                    a1[9] += a1[1];

                    a1[1] = m; // 0x36
                    a1[2] = 8;
                    a1[1] <<= a1[2];
                    a1[9] += a1[1];

                    a1[1] = n; // 0x63
                    a1[9] += a1[1];

                    //a1[9] = i;

                    a1[1] = a1[9]; // 0x62303663
                    a1[3] = 32;
                    a1[1] *= a1[3];
                    a1[4] = a1[1];
                    a1[1] ^= a1[9];
                    a1[2] = 17;
                    a1[1] >>= a1[2];
                    a1[5] = a1[1];
                    a1[1] = a1[5];
                    a1[1] ^= a1[4];
                    a1[1] ^= a1[9];
                    a1[2] = 13;
                    a1[1] <<= a1[2];
                    a1[1] ^= a1[9];
                    a1[1] ^= a1[4];
                    a1[1] ^= a1[5];
                    a1[9] = a1[1];
                    a1[3] = 32;
                    a1[1] *= a1[3];
                    a1[4] = a1[1];
                    a1[1] ^= a1[9];
                    a1[2] = 17;
                    a1[1] >>= a1[2];
                    a1[5] = a1[1];
                    a1[1] = a1[5];
                    a1[1] ^= a1[4];
                    a1[1] ^= a1[9];
                    a1[2] = 13;
                    a1[1] <<= a1[2];
                    a1[1] ^= a1[9];
                    a1[1] ^= a1[4];
                    a1[1] ^= a1[5];
                    //printf("%x\n", a1[1]);

                    if ( a1[1] == 0xCF1304DC ){
                        printf("%c%c%c%c", i, j, m, n);
                        //printf("%x", i);
                    }
                }
            }
        }
    }

    for(int i=32; i<127; i++){
        for(int j=32; j<127; j++){
            for(int m=32; m<127; m++){
                for(int n=32; n<127; n++){
                    unsigned int a1[10] = {0};

                    a1[1] = i;
                    a1[2] = 24;
                    a1[1] <<= a1[2];
                    a1[9] = a1[1];

                    a1[1] = j;
                    a1[2] = 16;
                    a1[1] <<= a1[2];
                    a1[9] += a1[1];

                    a1[1] = m;
                    a1[2] = 8;
                    a1[1] <<= a1[2];
                    a1[9] += a1[1];

                    a1[1] = n;
                    a1[9] += a1[1];

                    a1[1] = a1[9];
                    a1[3] = 32;
                    a1[1] *= a1[3];
                    a1[4] = a1[1];
                    a1[1] ^= a1[9];
                    a1[2] = 17;
                    a1[1] >>= a1[2];
                    a1[5] = a1[1];
                    a1[1] = a1[5];
                    a1[1] ^= a1[4];
                    a1[1] ^= a1[9];
                    a1[2] = 13;
                    a1[1] <<= a1[2];
                    a1[1] ^= a1[9];
                    a1[1] ^= a1[4];
                    a1[1] ^= a1[5];
                    a1[9] = a1[1];
                    a1[3] = 32;
                    a1[1] *= a1[3];
                    a1[4] = a1[1];
                    a1[1] ^= a1[9];
                    a1[2] = 17;
                    a1[1] >>= a1[2];
                    a1[5] = a1[1];
                    a1[1] = a1[5];
                    a1[1] ^= a1[4];
                    a1[1] ^= a1[9];
                    a1[2] = 13;
                    a1[1] <<= a1[2];
                    a1[1] ^= a1[9];
                    a1[1] ^= a1[4];
                    a1[1] ^= a1[5];
                    if ( 0x283B8E84 == a1[1] ){
                        printf("%c%c%c%c", i, j, m, n);
                    }
                }
            }
        }
    }

    return 0;
}
```

得到flag

16584abc45baff901c59dde3b1bb6701a254b06cdc23