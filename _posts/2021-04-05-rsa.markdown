---
layout: post
title:  RSA
date:   2021-04-05 00:01:01 +0300
image:  2021-04-05-couple.jpg
tags:   [rsa,crypto]
---

选取两个大素数p，q

计算n=pq，φ(n)=(p-1)(q-1)

随机选取正整数e，1<e<φ(n),且(e,φ(n))=1

计算d，满足ed≡1(mod φ(n))

p，q，φ(n)，d是保密的，n，e是公开的

加密：对明文m，1<m<n，加密后密文：c≡m<sup>e</sup>(mod n)

解密：对应密文1< c < n，解密后明文：n≡c<sup>d</sup>(mod n)

**证明：**

由欧拉定理a<sup>φ(p)</sup>≡1 (mod p)

由两端作k(φ(n)/φ(p))次幂得

a<sup>1+kφ(n)</sup>≡a(mod p)即a<sup>ed</sup>≡a(mod p)

同理a<sup>ed</sup>≡a(mod q)，

因为p，q是素数，故a<sup>ed</sup>≡a(mod n)

因此，c<sup>d</sup>≡(a<sup>e</sup>)<sup>d</sup>≡a(mod n)

证毕

------------------------------------

在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17

求解出d作为flga提交

```assembly
import primefac

p=473398607161
q=4511491
e=17
d = primefac.modinv(e,(p-1)*(q-1))%((p-1)*(q-1))
print(d)
```

### rsarsa

Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.


p =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e =  65537
c =  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034

Use RSA to find the secret message

```assembly
import primefac

p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e = 65537
c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034

d = primefac.modinv(e,(p-1)*(q-1))%((p-1)*(q-1))
m = pow(c,d,p*q)
print(m)
```

### RSA1

p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 

q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 

dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 

dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 

c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

### hectf-crypto-easyrsa(e,φ(n)不互素)

```python
from secret import flag
n = 155518463830560229644846724430836428995845620193574592170433241574666037137716528324571815369167049698698516255775616801764899976254095759074631817355320858739910069040009294893001147604941091673096339767232941480642397698104905644129961998649010457389845481973721204305241567277478343102339335893707164544801
e = 0x20002
print(len(str(n)))
print(len(str(d)))
c = pow(flag, e, n)
#c:69775954010477827342655007357413905879265207201140046408669586721885526123784907133716642304622235420317538384169817488136355157658329703705226141938991105912868209447036610553660972001461632840370922684108791263764483626927583087998066070299767122268085587208956687449243493403662943691619787801332549149107

```

使用yafu分解n

P155 = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633547

P155 = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633283

```python
import primefac

n = 155518463830560229644846724430836428995845620193574592170433241574666037137716528324571815369167049698698516255775616801764899976254095759074631817355320858739910069040009294893001147604941091673096339767232941480642397698104905644129961998649010457389845481973721204305241567277478343102339335893707164544801
e = 0x20002
c = 69775954010477827342655007357413905879265207201140046408669586721885526123784907133716642304622235420317538384169817488136355157658329703705226141938991105912868209447036610553660972001461632840370922684108791263764483626927583087998066070299767122268085587208956687449243493403662943691619787801332549149107

p=12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633547
q=12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633283

d = primefac.modinv(e, (p-1)*(q-1)) % ((p-1)*(q-1))
#print(d)

d = 123357367956541235910366848082954680942369023912336261949552186246203507554008514402925694648073300754339436792044793991530685877681201671418216585949906132782722863693470523720381308746725958767927889871265352465756641734898009634747876082325177030100504957895427206975585831940798724818936570135090861997377

m = pow(c, d, p*q)
print(m)
```

m = 5548303210159221016902556790416727746278662131239143650055176045198961772562305658698914160757176901664222150248352922728503663514101094930811786531956869087030990960798210695535443702025

但是求解的m却不正确。

验证发现，原来这道题中的e和φ(n)不互素。

e=0x20002=131074，偶数，所以自然我们求出的是不正确的。

下面进行等式运算：
$$
\begin{align*}
&gcd(e,φ(n)) = b\\
&e = a × b\\
&ed ≡ 1 (mod\;φ(n))\\
&abd ≡ 1 (mod\;φ(n))\\
&gcd(a,φ(n))=1\\
&bd唯一\\
&m^{abd}≡m^{1+kφ(n)}≡m(mod\; n)\\
&m^e ≡ c (mod\; n)\\
&m^{ab} ≡ c (mod\; n)\\
&c^{bd}≡m^{abbd}≡m^b(mod\; n)\\
\end{align*}
$$
下面求解：

```python
from Crypto.Util.number import *
import sympy
import primefac

def gcd(a,b):
    if a < b:
        a,b = b,a
    while b != 0:
        tem = a % b
        a = b
        b = tem
    return a

e = 0x20002

p = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633547

q = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633283

print(gcd(e,(p-1)*(q-1)))
# 2
print(e/gcd(e,(p-1)*(q-1)))
# 65537

bd = primefac.modinv(a, (p-1)*(q-1)) % ((p-1)*(q-1))
print(bd)
'''
123357367956541235910366848082954680942369023912336261949552186246203507554008514402925694648073300754339436792044793991530685877681201671418216585949906132782722863693470523720381308746725958767927889871265352465756641734898009634747876082325177030100504957895427206975585831940798724818936570135090861997377
'''
m_b = pow(c, bd, p*q)
print(m_b)
'''
5548303210159221016902556790416727746278662131239143650055176045198961772562305658698914160757176901664222150248352922728503663514101094930811786531956869087030990960798210695535443702025
'''

# m = pow(m_b,1/2)
# 2.355483646761153e+93
m = sympy.root(m_b,2)
plaintext = long_to_bytes(m)
print(m)
print(plaintext)
'''
2355483646761153172600545968353721956690144750945923875779713818161625500512978492175894930045
b'HECTF{ee709277385739acecbf0ebb06f0717b}'
'''
```

### 2021红明谷数据安全大赛

```assembly
from gmpy2 import *
from Crypto.Util.number import *
import sympy
import random
from secret import flag

p1 = getPrime(1024)
print(p1)
#p1=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649936031

p2 = p1 - random(999,99999)
print(p2)
#p2=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649902034

p_1=1
for i in range(1,p1+1):
    p_1*=i
p3 = sympy.nextPrime(p_1 % p2 )

p4 = p3 >> 50 << 50
p = p4
while(isPrime(P)!=1):
    P = p + random.randint(0,2**50)

Q = getPrime(1024)

e = 1+1+1
N = P * Q
print(N)
#N=28592245028568852124815768977111125874262599260058745599820769758676575163359612268623240652811172009403854869932602124987089815595007954065785558682294503755479266935877152343298248656222514238984548734114192436817346633473367019138600818158715715935132231386478333980631609437639665255977026081124468935510279104246449817606049991764744352123119281766258347177186790624246492739368005511017524914036614317783472537220720739454744527197507751921840839876863945184171493740832516867733853656800209669179467244407710022070593053034488226101034106881990117738617496520445046561073310892360430531295027470929927226907793

flag=bytes_to_long(flag)
c = pow(flag,e,N)
print(c)
#c=15839981826831548396886036749682663273035548220969819480071392201237477433920362840542848967952612687163860026284987497137578272157113399130705412843449686711908583139117413
```

因为c≡m<sup>e</sup>(mod n)，e很小，所以尝试低指数解密攻击，直接开方。

```assembly
from Crypto.Util.number import *
import gmpy2

e = 1+1+1
c = 15839981826831548396886036749682663273035548220969819480071392201237477433920362840542848967952612687163860026284987497137578272157113399130705412843449686711908583139117413
N = 28592245028568852124815768977111125874262599260058745599820769758676575163359612268623240652811172009403854869932602124987089815595007954065785558682294503755479266935877152343298248656222514238984548734114192436817346633473367019138600818158715715935132231386478333980631609437639665255977026081124468935510279104246449817606049991764744352123119281766258347177186790624246492739368005511017524914036614317783472537220720739454744527197507751921840839876863945184171493740832516867733853656800209669179467244407710022070593053034488226101034106881990117738617496520445046561073310892360430531295027470929927226907793

p = gmpy2.iroot(c,e)
print(p)
plaintext = long_to_bytes(p[0])
print(plaintext)
'''
(mpz(2511413510842166080065277487935235573010338102447558587517), True)
flag{w0_x1hu1n_y0u_b5st}
'''
```

