---
layout: post
title:  RSA
date:   2021-04-05 00:01:01 +0300
image:  2021-04-05-couple.jpg
tags:   [rsa,crypto]
---

选取两个大素数p，q

计算n=pq，φ(n)=(p-1)(q-1)

随机选取正整数e，1<e<φ(n),且(e,φ(n))=1

计算d，满足ed≡1(mod φ(n))

p，q，φ(n)，d是保密的，n，e是公开的

加密：对明文m，1<m<n，加密后密文：c≡m<sup>e</sup>(mod n)

解密：对应密文1< c < n，解密后明文：n≡c<sup>d</sup>(mod n)

**证明：**

由欧拉定理a<sup>φ(p)</sup>≡1 (mod p)

由两端作k(φ(n)/φ(p))次幂得

a<sup>1+kφ(n)</sup>≡a(mod p)即a<sup>ed</sup>≡a(mod p)

同理a<sup>ed</sup>≡a(mod q)，

因为p，q是素数，故a<sup>ed</sup>≡a(mod n)

因此，c<sup>d</sup>≡(a<sup>e</sup>)<sup>d</sup>≡a(mod n)

证毕

------------------------------------

在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17

求解出d作为flga提交

```assembly
import primefac

p=473398607161
q=4511491
e=17
d = primefac.modinv(e,(p-1)*(q-1))%((p-1)*(q-1))
print(d)
```

### rsarsa

Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.


p =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e =  65537
c =  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034

Use RSA to find the secret message

```assembly
import primefac

p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
e = 65537
c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034

d = primefac.modinv(e,(p-1)*(q-1))%((p-1)*(q-1))
m = pow(c,d,p*q)
print(m)
```

### RSA1

p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 

q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 

dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 

dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 

c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

### hectf-crypto-easyrsa(e,φ(n)不互素)

```python
from secret import flag
n = 155518463830560229644846724430836428995845620193574592170433241574666037137716528324571815369167049698698516255775616801764899976254095759074631817355320858739910069040009294893001147604941091673096339767232941480642397698104905644129961998649010457389845481973721204305241567277478343102339335893707164544801
e = 0x20002
print(len(str(n)))
print(len(str(d)))
c = pow(flag, e, n)
#c:69775954010477827342655007357413905879265207201140046408669586721885526123784907133716642304622235420317538384169817488136355157658329703705226141938991105912868209447036610553660972001461632840370922684108791263764483626927583087998066070299767122268085587208956687449243493403662943691619787801332549149107

```

使用yafu分解n

P155 = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633547

P155 = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633283

```python
import primefac

n = 155518463830560229644846724430836428995845620193574592170433241574666037137716528324571815369167049698698516255775616801764899976254095759074631817355320858739910069040009294893001147604941091673096339767232941480642397698104905644129961998649010457389845481973721204305241567277478343102339335893707164544801
e = 0x20002
c = 69775954010477827342655007357413905879265207201140046408669586721885526123784907133716642304622235420317538384169817488136355157658329703705226141938991105912868209447036610553660972001461632840370922684108791263764483626927583087998066070299767122268085587208956687449243493403662943691619787801332549149107

p=12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633547
q=12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633283

d = primefac.modinv(e, (p-1)*(q-1)) % ((p-1)*(q-1))
#print(d)

d = 123357367956541235910366848082954680942369023912336261949552186246203507554008514402925694648073300754339436792044793991530685877681201671418216585949906132782722863693470523720381308746725958767927889871265352465756641734898009634747876082325177030100504957895427206975585831940798724818936570135090861997377

m = pow(c, d, p*q)
print(m)
```

m = 5548303210159221016902556790416727746278662131239143650055176045198961772562305658698914160757176901664222150248352922728503663514101094930811786531956869087030990960798210695535443702025

但是求解的m却不正确。

验证发现，原来这道题中的e和φ(n)不互素。

e=0x20002=131074，偶数，所以自然我们求出的是不正确的。

下面进行等式运算：
$$
\begin{align*}
&gcd(e,φ(n)) = b\\
&e = a × b\\
&ed ≡ 1 (mod\;φ(n))\\
&abd ≡ 1 (mod\;φ(n))\\
&gcd(a,φ(n))=1\\
&bd唯一\\
&m^{abd}≡m^{1+kφ(n)}≡m(mod\; n)\\
&m^e ≡ c (mod\; n)\\
&m^{ab} ≡ c (mod\; n)\\
&c^{bd}≡m^{abbd}≡m^b(mod\; n)\\
\end{align*}
$$
下面求解：

```python
from Crypto.Util.number import *
import sympy
import primefac

def gcd(a,b):
    if a < b:
        a,b = b,a
    while b != 0:
        tem = a % b
        a = b
        b = tem
    return a

e = 0x20002

p = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633547

q = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633283

print(gcd(e,(p-1)*(q-1)))
# 2
print(e/gcd(e,(p-1)*(q-1)))
# 65537

bd = primefac.modinv(a, (p-1)*(q-1)) % ((p-1)*(q-1))
print(bd)
'''
123357367956541235910366848082954680942369023912336261949552186246203507554008514402925694648073300754339436792044793991530685877681201671418216585949906132782722863693470523720381308746725958767927889871265352465756641734898009634747876082325177030100504957895427206975585831940798724818936570135090861997377
'''
m_b = pow(c, bd, p*q)
print(m_b)
'''
5548303210159221016902556790416727746278662131239143650055176045198961772562305658698914160757176901664222150248352922728503663514101094930811786531956869087030990960798210695535443702025
'''

# m = pow(m_b,1/2)
# 2.355483646761153e+93
m = sympy.root(m_b,2)
plaintext = long_to_bytes(m)
print(m)
print(plaintext)
'''
2355483646761153172600545968353721956690144750945923875779713818161625500512978492175894930045
b'HECTF{ee709277385739acecbf0ebb06f0717b}'
'''
```

### 2021红明谷数据安全大赛

```assembly
from gmpy2 import *
from Crypto.Util.number import *
import sympy
import random
from secret import flag

p1 = getPrime(1024)
print(p1)
#p1=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649936031

p2 = p1 - random(999,99999)
print(p2)
#p2=172071201093945294154292240631809733545154559633386758234063824053438835958515543354911249971174172649606257936857627547311760174511316984409767738981247877005802155796623587461774104951797122995266217334158736848307655543970322950339988489801672160058805422153816950022590644650247595501280192205506649902034

p_1=1
for i in range(1,p1+1):
    p_1*=i
p3 = sympy.nextPrime(p_1 % p2 )

p4 = p3 >> 50 << 50
p = p4
while(isPrime(P)!=1):
    P = p + random.randint(0,2**50)

Q = getPrime(1024)

e = 1+1+1
N = P * Q
print(N)
#N=28592245028568852124815768977111125874262599260058745599820769758676575163359612268623240652811172009403854869932602124987089815595007954065785558682294503755479266935877152343298248656222514238984548734114192436817346633473367019138600818158715715935132231386478333980631609437639665255977026081124468935510279104246449817606049991764744352123119281766258347177186790624246492739368005511017524914036614317783472537220720739454744527197507751921840839876863945184171493740832516867733853656800209669179467244407710022070593053034488226101034106881990117738617496520445046561073310892360430531295027470929927226907793

flag=bytes_to_long(flag)
c = pow(flag,e,N)
print(c)
#c=15839981826831548396886036749682663273035548220969819480071392201237477433920362840542848967952612687163860026284987497137578272157113399130705412843449686711908583139117413
```

因为c≡m<sup>e</sup>(mod n)，e很小，所以尝试低指数解密攻击，直接开方。

```assembly
from Crypto.Util.number import *
import gmpy2

e = 1+1+1
c = 15839981826831548396886036749682663273035548220969819480071392201237477433920362840542848967952612687163860026284987497137578272157113399130705412843449686711908583139117413
N = 28592245028568852124815768977111125874262599260058745599820769758676575163359612268623240652811172009403854869932602124987089815595007954065785558682294503755479266935877152343298248656222514238984548734114192436817346633473367019138600818158715715935132231386478333980631609437639665255977026081124468935510279104246449817606049991764744352123119281766258347177186790624246492739368005511017524914036614317783472537220720739454744527197507751921840839876863945184171493740832516867733853656800209669179467244407710022070593053034488226101034106881990117738617496520445046561073310892360430531295027470929927226907793

p = gmpy2.iroot(c,e)
print(p)
plaintext = long_to_bytes(p[0])
print(plaintext)
'''
(mpz(2511413510842166080065277487935235573010338102447558587517), True)
flag{w0_x1hu1n_y0u_b5st}
'''
```

### 2021dasctf三月赛-crypto_threshold

```assembly
import random
from sympy import nextprime
from Crypto.Util.number import *
from secret import flag
from gmpy2 import gcd

def lcg(seed,params):
    (m,c,n)=params
    s = seed % n
    while True:
        s = (m * s + c) % n
        yield s
    

seed = getPrime(128)
m = getPrime(128)
c = getPrime(128)
n = getPrime(129)

print(m,c,n)
key_stream = lcg(seed,(m,c,n))
num=[]
for _ in range(6):
	num.append(next(key_stream))
	
print(num)
secret =  next(key_stream)

e = nextprime(secret)
p = getPrime(1024)
q = getPrime(1024)


_lambda = ((p-1)*(q-1)) / gcd(p-1,q-1)

flag = bytes_to_long(flag)


print(_lambda)
print(p*q)
print(pow(flag,e,p*q))
        
'''
(315926151576125492949520250047736865439L, 204423972944032372640132172728460755543L, 375402477603617093440157245062608289367L)
[345100389799760820174075838471701328893L, 354616152072197410104284828964580660629L, 262223452907927780613453340112396026524L, 36884243358932605284421044617284274488L, 293840768243490066897038832083154668562L, 287868671713011127830359814204794790287L]
457872764421730558978217109311884057410311335293040789670930865953404030084212226269947268155086034859079522508205099945996505165612539895857134158846470122889806235716457030336629794120415334028017836171608283093853784030348654118118278878881245838363354935523654666907698225985634469947076411404657018958617661794208646954882326918608011132295868155254980231015984288966599987516188265570396237695988003707515471895679008794498548940902202079105268931791776841539932961070351617834137017590635300615537152347169984974533340989459692132455611998382465644967355506104871655788359202461542101480022365857889833055840
27472365865303833538693026558713043444618680117582447380255851957204241805052733576196836089305162091544771350492305996759790309936752393751428049530788207373388374142987421820197787647224920041681070170296496985631227041820919247087096732732874750301801296131419280014461893559138068196824584684279421137517391204355597563871480257589096606865035259322614687417246708249170470689983675108996118328359454354818425772935513344465778617739729440207409124134831968562495435786944862849412776010947330752600405451073822977981611026975129395818269513358936682934286140359273764118787152676411486767003233858544159511154941
7187920142528335824861143203876908084067528690298329755497671248322277194754277305701102880967402859593937177306927235921616059382304183094350022713118203435560220591865274025991334717202171313133285253575822615616032441398946742994706880814251670668924098240782583026655923033371628284132606950034409888896558825512875084001031123558055489119898334591442547695833103046341283479780998109787754685881665949269402489768629140076361688313079919123642491566639820702501701460474001196941883819620040361365999896847153131825439764785309224799365130821807533936571946283436139142085798584001786665762720472918598961576836
'''
```

一般认为_lambda是(p-1)*(q-1)，但是用\_lambda=((p-1)\*(q-1)) / gcd(p-1,q-1)能够使解出的d更小。

```assembly
from Crypto.Util.number import *
from sympy import nextprime

m = 315926151576125492949520250047736865439
c = 204423972944032372640132172728460755543
n = 375402477603617093440157245062608289367
num = [345100389799760820174075838471701328893, 354616152072197410104284828964580660629, 262223452907927780613453340112396026524, 36884243358932605284421044617284274488, 293840768243490066897038832083154668562, 287868671713011127830359814204794790287]

secret = (m * num[-1] + c) % n
e = nextprime(secret)

lamda = 457872764421730558978217109311884057410311335293040789670930865953404030084212226269947268155086034859079522508205099945996505165612539895857134158846470122889806235716457030336629794120415334028017836171608283093853784030348654118118278878881245838363354935523654666907698225985634469947076411404657018958617661794208646954882326918608011132295868155254980231015984288966599987516188265570396237695988003707515471895679008794498548940902202079105268931791776841539932961070351617834137017590635300615537152347169984974533340989459692132455611998382465644967355506104871655788359202461542101480022365857889833055840
d = inverse(e, lamda)

c = 7187920142528335824861143203876908084067528690298329755497671248322277194754277305701102880967402859593937177306927235921616059382304183094350022713118203435560220591865274025991334717202171313133285253575822615616032441398946742994706880814251670668924098240782583026655923033371628284132606950034409888896558825512875084001031123558055489119898334591442547695833103046341283479780998109787754685881665949269402489768629140076361688313079919123642491566639820702501701460474001196941883819620040361365999896847153131825439764785309224799365130821807533936571946283436139142085798584001786665762720472918598961576836
n = 27472365865303833538693026558713043444618680117582447380255851957204241805052733576196836089305162091544771350492305996759790309936752393751428049530788207373388374142987421820197787647224920041681070170296496985631227041820919247087096732732874750301801296131419280014461893559138068196824584684279421137517391204355597563871480257589096606865035259322614687417246708249170470689983675108996118328359454354818425772935513344465778617739729440207409124134831968562495435786944862849412776010947330752600405451073822977981611026975129395818269513358936682934286140359273764118787152676411486767003233858544159511154941
p = pow(c, d, n)
plaintext = long_to_bytes(p)
print(plaintext)
```

