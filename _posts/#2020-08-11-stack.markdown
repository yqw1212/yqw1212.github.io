---
layout: post
title:  栈利用之对抗linux保护
date:   2020-08-11 00:01:01 +0300
image:  2020-08-11-girl.jpg
tags:   [ctf,reverse]
---

# Linux保护技术概述

* Canary

  函数开始执行的时候先往栈里插入canary值，当函数真正返回的时候会验证canary值是否合法，如果不合法就停止运行

* Fortify

  只要用来防止格式化字符串。包含%n的格式化字符串不能位于程序内存中的可写地址。当使用位置参数时，必须使用范围内的所有参数，如果要使用%7$x，必须同时使用1$,2$,3$,4$,5$和6$。

  编译选项：

  关闭：-D_FORTIFY_SOURCE=0

* NX/DEP

  将数据所在内存页标识为不可执行，当程序溢出成功后转入shellcode时，程序会尝试在

* PIE/ASLR

  使得程序地址空间分布随机化，增加ROP等利用的难度

  编译选项

  关闭：-no-pie

  开启：-pie-fPIC

* RELRO

  设置符号重定向表为只读并在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）表攻击。

  编译选项

  开启（部分）：-z lazy

  开启（完全）：-z now

### 对抗NX/DEP保护技术

用于保护函数调用信息和局部变量

x86：函数参数保存在栈上，在函数返回地址的而上方

x64：前六个整性或指针参数依次保存在RDI，RSI，RDX，RCX，R8和R9寄存器中，如果还有更多的参数的话才会存在栈上

栈溢出的基本前提

* 程序必须向栈上写入数据
* 写入的数据大小没有被良好地控制

#### ret2text

控制程序执行程序本身已有的代码

rbp

rip

#### ret2shellcode

控制程序执行shellcode代码

```python
shellcode = asm(shellcraft.sh())
```

然而有了NX保护之后，堆、栈、bss段就没有执行权限了

ROP，其主要思想是在栈溢出的基础上，利用程序中已有的小片段（gadgets）来改变某些寄存器或者变量的值，从而控制程序的执行流程。

ROP攻击一般的满足如下条件

* 程序存在溢出，并且可以控制返回地址
* 可以找到满足条件的gadgets以及相应gadgets的地址

大致过程

* 精心构造栈结构
* 利用返回地址ret的跳转特点
* 不在栈中或bss段执行代码，而是在程序的可执行段寻找可以执行的小组件（gadgets）
* 把小组件串起来，构造而成的就叫rop链

### 对抗ASLR/PIE保护技术

如果需要跳转的目标函数在程序中没有，如：system函数，Libc中应有尽有。

然而ASLR/PIE保护技术使得程序基地址和libc基地址每次加载的都不一样。

延迟绑定机制

只能泄露已经执行过一次函数的libc地址，因为动态链接库的加载机制……

利用思路

* 泄露GOT表中某个函数的libc地址
* 在libc中找到system，'/bin/sh'和这个函数的相对偏移
* 得到system的地址和'/bin/sh'的地址
* 构造ROP链，成功利用

在执行了一次某函数之后，GOT表中就会把一个函数在程序中的终极偏移存起来。
$$
终极偏移 = libc基址（每次加载都不一样）+库内函数相对偏移
$$
System = libc基址 + system在库中的相对偏移
'/bin/sh' = libc基址 + '/bin/sh'在库中的相对偏移

如果开启了PIE，使得程序基地址每次加载也不同，也就是连最基本的gadgets的地址都不知道，只能结合其他漏洞或者功能先进行泄露。

### 对抗Canary保护技术

* 泄露Canary值

  与泄露及地址的方法类似

* 泄露fs：28h内的值

* 复写副本值

  需要进行位置的爆破

* 劫持stack_chk_fail

  可以修改全局偏移表（GOT）中储存的函数

* stack smashing

  当canary被覆盖之后，会call到__stack_chk_fail打印ardv[0]这个指针指向的字符串，默认是程序的名字。

* 逐字节爆破（BROP）

  攻击条件：

  * 远程程序必须先存在一个已知的stack overflow的漏洞，而且攻击者知道如何触发这个漏洞

  * 服务器进程在crash之后会重新复活，并且复活的进程不会被re-rand（）。这个需求其实是合理的，因为当前像nginx，MySQL，Apache，OpenSSH等服务器应用都符合这种。

  核心就是想办法泄露程序的更多信息。通过某种方法从远程服务器dump出该程序的内存到本地。

  基本思路：

  * 判断栈溢出的长度
  * 逐字节爆破Canary（如果没有开，就跳过这一步）
  * 寻找stop gadget
  * 寻找userful gadget（尤其是Brop gadget）
  * 寻找可用的PLT表项
  * 利用PLT表中的puts（或者write）函数，配合useful gadget，来远程dump信息

* windows可以算出来
  $$
  canary= \_\_security\_cookie\land ebp
  $$

### 溢出长度不够——栈劫持

如果可以在.bss段等已知位置进行写入，就可以提前进行栈布局。通过覆盖栈上的存储的saved rbp和saved rip，将栈进行劫持。

leave

```assembly
mov rsp,rbp(把rsp弄回来)
pop rbp(把rbp弄回来)
```

ret

```assembly
pop rip(这个时候rip就被retaddr的值取代了)
```

### SROP

全程是Sigreturn Oriented Programming。在这里‘sigreturn’是一个系统调用……

内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入signal信息……

内核主要做的工作走就是为进程保存上下文……

#### 利用思路

如果希望执行一系列的函数，只需要做两处修改即可：

* 控制栈指针
* 把原来rip指向的syscall gadget换成syscall;ret gadget

在构造ROP攻击的时候需要满足下面的条件

* 可以通过栈溢出来控制栈的内容
* 需要知道相应的地址
  * /bin/sh
  * Signal Frame
  * syscall
  * sigreturn
* 需要有够大的空间来塞下整个sigal frame

### Linux内核

利用ROP，直接执行commit_creds(prepare_kernel_cred(0))……

# 格式化字符串漏洞利用技术

格式化字符串漏洞主要是printf函数家族的问题。printf、fprintf、sprintf、snprintf等格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。

重要特性

* printf()函数的参数个数不固定
* printf()函数的参数分为两部分（第一个参数中的格式化字符的数量决定了后面参数的数量）

如果printf的第一个参数被我控制，意味着后面的参数的个数任我定。

### 利用思路

%s不是直接打印栈中的内容，而是通过栈中指针寻址，再打印，实现任意地址读。

%n是一个不常用的格式符，它的作用是把前面已经打印的长度写入某个内存地址。利用%n向内存中写入任意值

$的使用

定位参数%11$n

%n：dword：4bytes

%hn：word：2bytes

%hhn：byte：1bytes

如何被保护

Fortify保护的作用

主要用来防止格式化字符串漏洞。包含%n的格式化字符串不能位于程序内存中的可用地址。当使用位置参数时，必须使用范围内的所有参数。

#### 进阶思路

一般的情况都是把格式化字符串放在栈上，这样就能把地址也放在格式化字符串中，通过偏移来索引到栈上的这个地址，就能实现向改地址写入；但是如果程序的格式化字符串是放在堆上的，那就没办法把一个任意地址放在栈上，再去通过栈偏移索引。

核心原理就是修改栈上的rbp数据的一个字节，由于该rbp数据值还是指向栈这一个字节的修改，就能让他指向栈上一片区域的任意一个地址，进一步就能将栈上的这片区域内构造出来一个“任意地址”，再利用这个任意地址结合格式化字符串去写任意值。

### dl_runtime_resolve高级利用技术

正常情况下，PWN类型的漏洞题目一般会提供一个可执行程序，同时会提供程序运行动态链接的libc库。通过libc.so可以得到库函数的偏移地址，再结合泄露GOT表中libc函数的地址，计算出进程中实际函数的地址，以绕过ASLR。也就是常用的ret2libc技术，如果题目只给了可执行程序，ret2_dl_runtime_resolve技术可以使我们不依赖libc的攻击手法。

ELF可执行文件由ELF头部，程序头部表和其对应的段，节区头部表和其对应的节组成。如果一个可执行文件参与动态链接，他的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节区，

其中Tag对应着每个节区。比如JMPREL对应着.rel.plt。节区中包含目标文件的所有信息。

类型为REL的节区包含重定位表项。

* .rel.plt节是用于函数重定位，.rel.dyn节是用于变量重定位。
* .dynsym节区包含了动态链接符号表。
* .dynstr节包含了动态链接的字符串。这个节区以\x00作为开始和结尾，中间每个字符也已\x00间隔。
* .plt节是过程链接表。过程链接表把独立的函数调用重定向到绝对位置。

漏洞利用流程

* 控制EIP为PLT[0]的地址，只需传递一个index_arg参数
* 控制index_arg的大小，使reloc的位置落在可控地址内
* 伪造reloc的内容，使sym落在可控地址内
* 伪造sym的内容，使name落在可控地址内
* 伪造name为任意库函数，如system

利用roputils上述伪造过程傻瓜式解决