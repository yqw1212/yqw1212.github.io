---
layout: post
title:  Software Watermarking using Return-Oriented Programming
date:   2023-12-06 00:08:01 +0300
image:  2023-12-06-cat.jpg
tags:   [note,paper]
---

# 使用面向返回编程的软件水印

## 摘要

提出了一种基于面向返回编程(Return-Oriented Programming, ROP)的动态软件水印设计方法。我们的设计将水印代码格式化为精心设计的数据安排，这些数据安排看起来像普通数据，但可以触发执行。一旦触发，预构造的ROP执行将恢复隐藏的水印消息。本文提出的基于ROP的水印技术比现有的水印技术更具隐潜性和弹性，因为水印代码是动态分配到数据区域的，因此不受基于代码分析的攻击。评估表明，我们的设计不仅达到了令人满意的隐身性和弹性，而且显著降低了水印程序的开销。

## 关键词

Software watermarking, return-oriented programming, reverse engineering, code obfuscation

## 1.介绍

软件盗窃和盗版一直是困扰软件行业的一个重要问题。在与此类侵犯知识产权的行为作斗争时，软件水印被认为是一个有价值的工具。像媒体水印，软件水印将一个秘密信息嵌入到一个主题程序中，这个秘密信息可以被提取出来，以识别该程序的版权所有者或真实用户。

现有的软件水印设计可分为静态水印和动态水印[10]。前者将水印信息直接嵌入到程序文本中，后者将水印信息隐藏在程序运行状态或动态数据中。由于动态水印通过沿着被水印程序的特定路径运行并检查其特定行为来检索隐藏信息，因此通常被认为是一种更可靠、更安全的解决方案[9]。

然而，尽管在动态水印方面取得了进展，但现有技术仍有充分的局限性[9]。**首先，现有的动态水印方案引入了特殊的数据结构和指令模式，攻击者可以利用这些数据结构和指令模式定位隐藏的水印。其次，通过动态水印插入的代码通常与程序的其他部分相当独立，因此可能是可疑的。最后，由于以前的设计，如[8,21,23]，使用外部提取器从程序的执行记录中恢复水印，有时被水印的程序需要留下一些信息供提取器找到隐藏的水印，这些信息也可能被攻击者利用来撤销它。**现有研究表明，这些问题可以通过整合其他保护技术来解决[23];然而，这样做也显著降低了水印技术的效率[9]。

一般来说，动态水印是给程序一个新的执行路径(表示水印)。然而，使用常规编程技术，几乎不可能隐藏这个新执行路径的存在。在本文中，我们提出了一种创新的解决方案——基于返回导向编程(以下简称ROP)的新颖动态水印设计，这是一种众所周知的软件开发技术[4,14,16,26,27]。我们表明，虽然最初是为了恶意目的而提出的，但ROP可以应用于软件水印等良性用途，并且效果惊人。

我们的方法是从一组从现有代码中挑选出来的小而特殊的指令片段中“组装”水印代码，从而产生一个意想不到的执行路径，只能与ROP链接。我们还修改了主体程序，以便它准备所有其他资源，以便在堆区域动态地链接此水印路径。只有当被秘密输入触发时，程序才会将其控制转移到隐藏的ROP路径，然后提取嵌入的水印。我们的方法保证了水印程序没有一个专门属于水印的显式代码流，所以当我们的水印模块潜伏时，它在功能上不存在，防止它被软件分析发现。

据我们所知，我们的方法是第一个动态水印技术，它只使用来自其他现有代码模块的指令来执行水印。这不仅使水印代码不受分析工具的影响，而且还有助于它在各种失真攻击中幸存下来。此外，由于ROP最初是为了防止代码注入漏洞而开发的，因此我们的方法也不涉及违反W⊕X、DEP或代码签名等可疑行为。我们在第4节中提出了对程序隐身性和弹性的评估。结果表明，该方法能够使水印语义无法被强大的静态分析工具追踪，从而成功地隐藏了水印行为。

以ROP形式安排水印模块的另一个好处是可以更好地与原始程序集成，而不会像大多数现有工作那样产生可疑的数据结构[11,21]。我们表明，作为ROP资源插入的水印组件可以更容易、更灵活地展开并与程序的其他运行时数据混合，从而最大限度地减少旨在定位它们的分析的怀疑。我们的评估表明，我们的设计在将水印合并到主体程序中实现了令人满意的静态隐身。

最后但并非最不重要的是，我们的方法不是使用外部提取器，而是在水印程序中植入一个ROP触发器来激活ROP执行并提取水印。这避免了像现有技术那样泄露可能有助于水印恢复的提示给第三方[8,11,20,21]。

本文的其余部分组织如下。在第2节中，我们介绍了背景以及与我们设计相关的方面的现有研究。第3节给出了基于ROP的水印的思想和实现。第4节对所提出的解决方案进行了评估，并与以前的水印方法进行了比较。我们在第5节讨论了在水印中应用ROP的适用性和兼容性问题。第六部分对全文进行总结。

## 2.相关工作

### 2.1软件水印

软件水印的目标是在软件中嵌入一个识别信息，该信息可以被提取出来以识别被水印软件的所有权或某些真实信息。

有些方案通过重新定位寄存器或修改程序的抽象语义等方式将水印静态地嵌入到程序文本中[12,18]。另一些则关注动态方法，其中水印嵌入到程序的运行时行为中[8,11,19{21,23,25,31]。

以往的动态水印研究分为两类。基于图的水印首先由Collberg等人[10]提出，是目前最为人熟知的软件水印方法之一[11,23,31,34]。这些方案将水印信息编码成堆分配的图结构。水印提取是通过使用外部水印提取例程检查程序构建的图形结构并识别代表水印信息的图形来完成的。另一类动态水印试图在程序控制流的特殊状态下对水印进行编码，并通过分析程序的特定执行轨迹(如多线程行为[21]、条件分支[8,20]或不透明谓词的值[19])来提取水印。

上述方法的一个共同特点是，它们需要在程序中添加专门用于水印的特殊组件(例如，表示图节点的数据结构[11,34]，特殊线程组件[21])。由于水印提取依赖于对程序的外部观察/检查，因此许多水印在正常运行时留下了可区分的特征。例如，基于线程行为或动态执行路径的水印方案需要在外部定位和监控特殊的线程组件或某些分支指令[9]。

### 2.2面向返回的编程

最初由Shacham[27]提出，面向返回的编程已经成为恶意代码前进的重要一步。虽然像W⊕X和DEP这样的保护机制被越来越多的操作系统用来对抗代码注入攻击，但ROP提供了一种利用任意计算的新方法，并绕过了上述保护，因为它不注入任何新代码。

ROP开始于x86架构[5,26]，后来扩展到许多其他平台，例如SPARC [4]， ARM[16]等。ROP攻击现在不仅是完全自动化的，而且可以在目标程序执行期间发起[15,29]。此外，在不允许代码注入的iOS应用中，ROP也被证明是有用的[32]。

### 2.3采用ROP的程序隐写

虽然作为一种攻击技术被介绍，但最近关于ROP是否可以以良性方式使用的争论引起了研究人员的注意。特别是，RopSteg[17]被提出用于代码保护，它试图通过执行位于其他地方的“意外匹配”来隐藏程序的选定代码部分。在隐藏某个软件的某些代码块的意义上，RopSteg和我们基于rop的软件水印具有相似的目的。然而，RopSteg的设计假定篡改程序代码不是攻击者的最佳利益，这在软件水印中肯定不是真的，因为删除程序的特定部分(用于水印)正是攻击的目的。当直接用于软件水印时，RopSteg有以下缺点。

首先，RopSteg用ROP生成器和ROP board替换了受保护的代码部分，以便从非预期匹配中跳转和返回。在水印方面，这意味着RopSteg仍然引入了只在水印提取中执行的特殊模式的新代码。这可以使嵌入的水印更容易被定位。

其次，RopSteg不能承受扭曲性攻击，因为应用于RopSteg程序的任何简单程序转换都很可能破坏隐藏指令的意外匹配。这使得它成为一个脆弱的水印嵌入解决方案。

## 3.基于ROP的动态软件水印

### 3.1威胁模型和假设

动态水印设计由水印嵌入器和水印识别协议组成。水印嵌入器记为E(·,·,·)，以主体程序P、水印对象w和输入设置δ∈∆(又称“秘密输入”)为输入，输出带水印的程序P‘=(P,w,δ)。目标是在语义层面使p’(δ) = P(δ) + Ω，其中Ω是w的可执行形式，同时保留其他输入的语义，即P‘(i) = P(i) 任意i≠δ。水印识别协议R(·)从P’提取w当它以秘密输入运行时，即w=R(P‘(δ))。

一般情况下，对手可能会对P’发起以下攻击:

* 加性攻击，将P‘变成P’‘，以插入伪水印υ，因此对于一个指定的对手σ属于∆<sup>1</sup>，R(P''(σ))=υ.

* 减法/扭曲攻击，将P'变成P''，所以让真实水印w被移除或损坏，即R(P''(σ))≠w。

假定对手完全控制p’。他可以使用任何保留语义的转换来修改它，并静态和动态地观察和分析它的行为。然而，对手也不是全能的。在实践中，它被认为对一些关键信息是盲目的[10]，即:

1. p‘是否被加了水印
2. 原始的程序P
3. 秘密输入δ

我们的基于ROP的水印继承了上述假设，并考虑了相同的通用攻击模型。此外，我们扩展了识别协议R的概念，使其不仅仅是一个算法或软件分析工具包，而且还包括要执行程序的整个系统环境设置。这种定义的原因将在第5节中解释。

### 3.2概述

ROP在恶意使用中如此流行的原因是，它以一种不直接运行的形式格式化其“代码”，而是帮助使用自己的指令在程序中创建意外的执行。由于这种组织可执行文件的特殊方式，ROP也使得分析人员很难检测或理解它创建的新“代码”流。换句话说，ROP引入的执行路径在功能上是“不可见的”。这可能是构建动态软件水印的一个很好的解决方案，与现有的软件水印不同，它在保持强大弹性的同时实现最小的可见性。

首先理解ROP“代码”由两部分组成是很重要的:

1. 被称为“小工具”的小段指令，以返回或间接调用/跳转结束，它们位于现有可执行文件中的某个地方;
2. 一个精心制作的字符串，称为“payload”，由这些小组件的地址以及它们在执行中需要的其他变量组成

ROP通过执行带有有效负载字符串的小工具来工作，这意味着对于它创建的新执行路径，只需要构建一些额外的数据。因此，基于ROP的水印思想是使用ROP小组件构建实际的水印代码，同时引入额外的代码来构建有效负载来控制小部件。如图1所示，以这种方式修改的程序将在给定秘密输入(它接管并表示隐藏的水印)时将控制转移到所选的小工具，然后返回到程序的正常例程。由于构建ROP有效负载不会改变原始程序的工作方式，因此通过此方法添加的额外代码总是可以在程序的常规使用期间执行，而不是被闲置并引起怀疑。

举个例子，假设我们要将水印“007”嵌入到目标程序中，方法是将它放入一个4字节的字符串S中(见图2)。在这个例子中，有效载荷构造包括准备一个序列，控制堆上的以下小组件和变量(图2中的阴影区域):

* 初始化存根，用于存储当前堆栈指针和要返回的地址，并修改堆栈指针以指向水印代码;
* 由三个小组件组成的完成一个内存写的水印代码<pop eax; ret>，<pop ebx; ret>和<mov [ebx]，[eax]；ret>
* 一个常数3616816(对应字符串"\007"的ASCII码)和字符串S的地址，将被内存写组件使用。
* 一种终止存根，它恢复原来的堆栈布局并返回到正常的程序执行。

当触发水印提取程序时，嵌入的ROP首先将3616816和S的地址分别加载到寄存器eax和ebx中，然后将S更新为水印消息”\007”。

通常，执行设计良好的ROP依赖于在转向小组件之前向堆栈注入有效负载，以确保小组件不仅获得所需的所有操作数，而且确保间接控制指令正确地找到它们的后继指令，以便小组件按照计划的精确顺序执行。因此，有效载荷的构建和配置是ROP的关键环节。

在恶意利用中，这通常是通过一些易受攻击的例程向程序输入外部数据来完成的，注入的payload破坏了原始堆栈环境，而不考虑潜在的后果(例如，ROP执行后的段错误)。但是，如果使用软件水印，则必须考虑以下问题:

1. 由于嵌入的ROP是用于呈现水印的，因此有效载荷必须全部由程序本身构建;
2. 与原始程序相比，用于构造有效负载的代码不应该显得可疑;
3. 在获取水印后，ROP应在不破坏程序正常执行的情况下将控制恢复到正常执行状态。

除此之外，我们还需要绕过保护机制，例如地址空间布局随机化(ASLR)。显然，在基于ROP的水印中，传统的针对恶意攻击发起ROP的方法是不合适的。相反，我们需要为我们的目的提出一种定制的技术。在下面的小节中，我们将更详细地介绍方案的每个步骤。

### 3.3定位水印小工具

如3.2节所述，ROP的执行是基于来自现有代码区域的称为gadget的指令块构建的，因此我们的第一步是找到在水印生成中有用的gadget。然而，在程序本身内部使用指令容易受到简单的程序转换攻击(如第2.3节所述)。

为了抵抗转换攻击，我们使用了共享库(例如UNIX的libc.so和Windows的kernel32.dll)。这样的库几乎可以链接到任何程序，而且不能轻易修改。因此，我们选择从这些系统库中搜索水印小工具，因为对水印程序的语义保留转换不能阻止它正确地定位这些遗留代码中的小工具。

因为我们只使用ROP来隐藏水印行为，所以要执行的小工具只需要具有以下功能:

* **寄存器加载**。将水印信息和目标内存地址加载到寄存器中。请注意，这可能不像<pop; ret>序列。算术/逻辑/移位操作也包括在内。
* **内存写入。**将源寄存器的值写入目标寄存器的地址所指向的内存区域，如<mov [eax], ecx; ret>。
* **栈移位控制栈指针**。允许水印ROP链接，而无需使用额外的代码重定向。这些基本上是特殊的寄存器加载小组件，因为它们的唯一目标是堆栈指针寄存器。
* **传递**。在程序被定向到ROP时记录指令指针的当前位置，在执行水印代码后恢复。除了上述小组件的特定组合外，我们还专门利用了寄存器交换小工具，如<xchg eax, esp; ret >在这里，因为它们可以存储当前堆栈指针以供以后使用。

自引入ROP以来，许多人提出自动搜索有用的指令序列[15,26,29]。我们利用这些现有的技术从系统库中定位我们需要的小工具。为**了与支持ASLR的系统兼容，我们在库中记录了gadget与某些函数的条目之间的偏移量，以便在运行时可以借助函数指针轻松计算出它们的绝对地址。**

我们在SPECint-2006基准测试项目集合以及两个系统库libc.so.6和kernel32.dll中搜索这四种类型的小工具。只有完成一个功能链的小组件才被记录为可用。表1所示的结果证实，这两个系统库都为水印提供了功能齐全的小工具集，而在小程序模块上进行相同的搜索可能会失败。**此外，我们还发现，具有相同功能的gadget通常可以在多个位置找到，这可以在格式化有效负载方面提供灵活性。**

### 3.4水印有效载荷的分布式动态构造

**在ROP中构造一个合理的水印通常需要执行数十个小工具，因此用于将小工具连接起来的有效负载将非常长。用于构建这种有效载荷的代码将会更长，从而为攻击者留下潜在的目标。**然而，正如在第1节中简要提到的，我们基于ROP的水印技术的一个重要优势是能够在整个执行路径中分散水印组件，以最大限度地减少程序分析的怀疑。我们的设计将水印有效载荷分成小段，在程序的不同功能中构建，我们称之为“carriers”。对于许多carriers，我们设法在每个carriers中嵌入一小段代码，只控制几个小工具，这在很大程度上减少了人们的怀疑，因为插入的代码与原始carriers的大小相比几乎可以忽略不计。请参考第4节对其进行安全评估

我们使用BitBlaze二进制分析平台的动态分析组件TEMU[30]来跟踪具有秘密输入的程序的执行情况，记录路径上执行的所有函数及其大小、调用频率，并绘制调用图显示它们之间的控制流程。此执行路径上的每个函数都是水印有效负载的候选载体。我们根据载体的大小对其进行排序，并将较长的有效载荷段嵌入较大的载体中，因为它们为额外的代码提供了更好的覆盖

我们不是将水印payload存储在静态数据区域内，而是“动态地”构造payload段。也就是说，只有当载体被执行时，它所携带的payload才会在程序的堆区域中创建(我们选择不在载体的栈帧中这样做，以尽量减少水印对程序正常执行的影响)。我们将构建payload段的形式多样化，以使识别表示水印的模式变得更加困难。Payload段可以安排为：

* 整数数组
* 字符串
* 新创建的复合数据结构(如C结构和c++类)实例的选定变量。

图3显示了如何使用不同类型的程序对象构建存储在线性内存空间中的水印payload的示例。正如我们所看到的，相同片段的gadget 可以以不同的方式表示:具有两个元素的整数数组，在结构/类的实例中相邻的两个变量。我们基于主体程序中已经存在的数据结构构建payload，而不是创建仅用于水印的新类型结构，这可能成为攻击者的目标。

此外，由于payload段被格式化为堆分配的数据块，因此很容易在计算程序拥有的其他变量时使用它们。这样做在水印组件和目标程序之间建立了主动连接，使它们更难以被禁用，即使它们以某种方式被对手发现

### 3.5通过栈指针操作的payload链接

尽管将水印有效载荷分割成短段并分布在多个载体中提高了安全性，但我们仍然需要一种方法来确保在水印提取过程中离散分布的payload片段能够被链接成一个连续的流，以便在它们的控制下正确执行ROP。

如图4所示，当水印payload被分割成段时，我们在它们的末端附加栈指针移动小组件。通过这种方式，每个段都负责将栈帧正确地重新定位到下一个栈帧的确切内存地址，这样水印payload就像连续块一样工作。

如前一小节所讨论的，水印payload的片段是动态构造的。在运行期间，当其中一个被构造时，带水印的程序检查它的前一段和/或后一段是否已经被构造。如果它们中的任何一个存在，程序通过更新它们的栈移动小组件将这些段链接在一起。因为段是一个接一个生成的(尽管它们的顺序可能不像使用时那样严格)，它们中的每一个都将自己链接到它的邻居，或者被邻居链接。

### 3.6通过函数指针覆盖触发ROP

现在，水印payload被链接起来执行。在基于ROP的水印中缺少的最后一个部分是实例化隐藏的水印路径的执行。这涉及到从程序的正常执行到预先选择的小工具的ROP执行的转换，我们不希望执行这种转换的指令看起来可疑。

我们使用一个函数指针来触发ROP执行。这种设计选择的原因是，函数指针不仅允许通过简单地重写其值将控制转移到ROP小工具，而且还提供了一种自然的方式，将水印payload的初始存根(在第3.2节的示例中给出)直接作为函数参数加载到栈中。

通常，这个水印触发器指向我们添加到程序中的虚拟函数，以便在正常执行中，触发器调用虚拟函数并执行不影响程序其余部分的计算。在输入秘密输入时，trigger的值将被覆盖，指向初始stub的第一个gadget(而该存根的其他部分稍后将由trigger推送到栈上)。随后，当触发器被调用时，执行初始化stub的gadget，它保存当前环境并将控制转移到水印有效负载的第一段。

**下一个问题是如何对触发条件进行编码(测试秘密输入)。一个简单的解决方案是使用一个条件块(例如，if语句)来比较当前程序输入和常量秘密输入。但是，这种条件块在控制流图中引入了分支，容易引起程序分析的注意。**在这里，我们提出一个隐藏此类分支的新想法，参见图5。我们利用右移操作，这样只有当Input等于Key时，变量x才会被设置为0。因此，程序能够有条件地确定函数指针的值，而无需显式地引入控制流转移指令。

```assembly
void RopTrigger_A (int Input, int Key)
{
    int a = Input-Key;
	int b = Key-Input;
	a>>31;
	b>>31:
	/* if Input==Key, then x=0, otherwise x
		=-1 */
	int x=a^b;
	/* overwriting */
	&funcPt=addressA*(0-x)+addressB*(1+x);
	funcPt(Initial_Gadgets);
}
```

注意，上面的例子只是水印触发器的原始实现。在实践中，有许多方法可以以更复杂的形式构建相同的函数，从而使嵌入式触发器难以定位或分析。例如，我们可以使用Key的哈希值来计算a和b，方法与[28]类似。简单的右移可以用等价的算术组合代替。指针混叠也可以应用于函数指针覆盖。最后，可以将触发器的代码块拆分并与其他功能模块合并，以降低其可见性。

### 3.7实现

我们基于ROP的水印工具包是在一组python脚本中实现的，这些脚本由一个小工具扫描器、一个跟踪处理器和一个代码重写器组成，如图6所示。

Gadget scanner分析系统库，从3.3节中给出的四种类型中选择可用的Gadget，并创建一个Gadget数据库。它还生成ROP有效负载，将候选小部件链接到水印代码中。

同时，跟踪处理器分析目标程序在秘密输入下的执行轨迹，寻找水印payload的可用载体。它不仅找到载体的入口点，而且还记录它们的哪些部分在给定的跟踪中被执行。

**在这些准备之后，代码重写者修改程序的源代码以嵌入水印。首先，它将小工具扫描器提供的payload划分为多个片段，并生成用于构建和链接它们的代码。然后，将这些代码分配到载体中，并植入虚拟函数和ROP触发器。最后，对修改后的源代码进行重新编译，得到带水印的程序。**

秘密跟踪分析是水印的一个棘手的部分，因为分析器只记录二进制级别的执行，而水印嵌入到源代码中。为了填补这个空白，我们的跟踪处理器由一个代码标记和一个跟踪分析器组成。

首先，代码标记通过用无效的内联汇编序列(我们称之为标签)标记函数的入口点和结束点以及其中的条件代码块，从而对程序源代码进行特殊的复制。我们对这些标记进行了格式化，使它们不仅易于识别，而且还能告诉它们在相应的源文件中的确切位置。特别是，我们让每个标记以指令开始和结束，这在常规二进制文件中永远不会出现。此外，**程序中还添加了一个全局垃圾变量**，每个标签都带有将标记位置的文件ID和行号按顺序写入该垃圾变量的指令。因此，从标记的源代码生成的可执行文件将在记录秘密跟踪的情况下运行，跟踪分析器可以简单地搜索插入的标记，以准确地找出源代码的哪一部分被执行。

跟踪处理器被实现为总共207行脚本，其中代码标记使用135行，跟踪分析器使用72行。代码重写脚本包含191行，因为除了扫描和重写源文件外，还需要为有效负载准备生成代码。Gadget scanner是由现有的Gadget搜索算法GALILEO[27]扩展而来的。

## 4.评价

在本节中，我们对基于ROP的水印进行了许多安全性分析，并给出了结果。**我们还测量静态和动态开销**。

**软件水印的安全性通常从隐蔽性、可信度和弹性三个方面来评价。隐形通常是指水印与周围的代码或数据融合的程度;可信度描述的是水印被提取的精确程度;而弹性衡量的是对发现或移除的坚决尝试的抵抗力。**基于ROP的水印作为执行嵌入的ROP小组件的直接结果提取水印;因此，其可信性是不言而喻的。因此，在本节中，我们主要侧重于分析我们的方法的隐身性和弹性。**同时，应用基于ROP的水印所带来的开销也从三个方面进行了评估:生成水印所需的时间、代码大小的增量和所需的额外堆空间。**

我们将我们的方案应用于SPECint-2006测试集中的许多主体程序，这些主体程序是以前的研究选择使用的[23]。**实验水印被设计成简单地在屏幕上输出水印信息**。所有测试都在一台配备2.66GHz英特尔酷睿2四核CPU、4GB内存和Windows 7操作系统的个人电脑上进行。

### 4.1静态隐形性

静态隐身的软件水印测量如何很好地融入适合周围的程序。如第3节所述，基于ROP的水印需要在程序中插入少量代码以构建其payload。因此，静态隐身在评估我们的设计中起着重要的作用。好消息是，我们基于ROP的水印引入的代码仅用于创建和更新看起来像是程序数据的payload段。它被分解到指令级，并分布在程序中的许多载体上(参见第3.4节)。考虑到这类代码的多样性，如第3.4节所讨论的，我们期望基于ROP的水印在该测量中表现出良好的静态隐身性。

我们采用Collberg等[11]引入的静态隐身测量方法，简要描述如下:

* 首先，给定一段生成x位水印的水印代码，创建一个字典作为指令级配置文件。这是通过在水印代码的指令流上扫描一个窥视孔(按照Collberg等人的建议，窥视孔的大小被设置为一到三条指令)来完成的，而在扫描中观察到的不同指令组合则作为新单词添加到字典中。
* 其次，为了测量水印代码在程序中是否具有隐蔽性，然后在原始和加了水印的程序中搜索字典中的所有单词。其中出现的单词越多，水印代码就越适合程序。

我们将基于ROP的水印应用于bzip2、hmmer、lbm、mcf、seng和soplex六个基准程序中，以嵌入192位水印。通过分析插入到六个水印程序中的水印代码，我们在字典中共识别出171个单词。图7显示了字典中在原始程序和带水印程序中找到的单词数量。

从这些结果中可以得出两个重要结论。首先，我们观察到水印代码字典中70%到85%的单词已经存在于原始程序中。这表明，我们基于ROP的水印引入的大部分代码都可以在普通程序中看到，这使得攻击者很难寻找可以作为检测签名的特殊指令序列。其次，我们发现即使在加了水印的程序中，也只有72%到88%的单词在字典中被观察到。同时，原始程序和加了水印的程序的结果差异很小，使得原始程序和加了水印的程序在本分析中相对难以区分。

我们进一步扩展了这个实验，通过在程序的指令流上运行一个相当大的滑动窗口(在我们的实验中有200条指令，因为水印代码本身总共只有271条指令)来执行局域性评估。同样，我们在运行滑动窗口时从字典中查找单词，当找到的单词数量低于阈值时向右移动一步，否则向右移动200步，以避免重复计算。发现的单词数量超过阈值的位置被认为是“hotspots”，与水印代码相比具有相似的配置文件，并将被标记为可疑。图8显示了结果，其中横轴显示不同的阈值设置，纵轴显示找到的“hotspots”数量。

结果与之前的实验结果一致，在之前的实验中，很少有窗口的水印字典覆盖率超过50%。当比较原始程序和水印程序的结果时，“hotspots”数量没有显着增加。

### 4.2水印组件的相关性分析

在对水印技术隐蔽性的第二个分析中，我们假设了一个更现实的场景，攻击者设法找到水印中使用的一个可区分的组件，并试图通过依赖分析来跟踪它的其他部分。现有的水印方案在这方面是脆弱的，因为它们的外部提取器用来识别水印的某些特征也可能被攻击者利用，而它们的代码和数据之间的联系直接暴露在分析中。

作为一个例子，我们在文献中提出的一种代表性的水印技术CT水印技术[10]上模拟了这种依赖分析。在仿真中，我们将堆分配水印图的根节点设置为静态，就好像它已经被识别了一样。然后使用IDA pro 6.4从给定的根节点开始启动依赖项分析，以便查找任何在语义上是相连的内容。图9显示了分析结果，**我们发现，基于暴露的根节点，IDA pro能够检测到连接所有参与水印生成的函数的依赖关系图，使得攻击者在搜索水印代码时相对容易缩小到特定的函数。**

相比之下，我们基于ROP的水印payload停留在程序的数据区域，因此从正常的角度来看，它与相应的小部件没有显式的连接，使得水印语义对代码分析(包括依赖性分析)“不可见”，即当嵌入的ROP未被触发时，负责将水印消息写入程序内存然后打印出来的码流实际上不存在。为了验证，我们对我们的设计进行了类似的模拟，其中我们有意让水印代码将隐藏的消息写入静态字符串中，静态字符串可以很容易地被静态分析器获取，并再次从程序中查找语义连接的部分。然而，IDA pro在访问任何依赖于暴露字符串的内容时遇到了失败，也就是说，它认为在带水印的程序中在语义上根本没有试图读取或修改字符串的指令。

为了确认这一结果，我们动态地执行加了水印的程序并监视目标字符串以找出对其进行操作的指令。图10显示了这个动态分析的屏幕截图(覆盖暴露的字符串之前和之后)。我们可以看到，在目标字符串上操作的指令实际上是来自共享库的意外指令，超出了分析器的范围。这证实了在水印程序中发现的零依赖关系。

请注意，上面的模拟只是为了演示我们的设计和以前的工作在语义可见性方面的差异。在我们基于ROP的水印中，我们实际上并没有使用这样一个静态字符串来存储水印消息，因此依赖性分析甚至可能没有开始的基础。

### 4.3弹性

在本小节中，**我们讨论了我们设计的抗失真攻击的强度，在这种攻击中，攻击者试图通过扭曲水印程序的二进制来破坏水印。常见的二进制混淆(包括函数和基本块重新排序，函数内联和外联，数据重构等)是扭曲攻击的主要方法，而程序打包（加壳）和优化也包括在对手的武器库中。**

直观地说，保持语义的转换不会影响我们的设计，因为它们不会改变gadget的构造方式。但是，一种可能性是将函数指针的参数作为触发ROP执行的目标。然而，触发器函数指针通过间接调用工作，其目标很难在二进制级别确定。从理论上讲，对触发器的完全扭曲需要定位所有间接调用并修改所有潜在目标，包括那些导入程序的目标(这些目标非常容易出错)。这使得对手的任务变得不切实际。

我们测试了我们所有的水印程序对一系列知名工具的转换的弹性:

* Xenocode执行二进制级混淆，包括加密静态字符串，随机插入冗余无效指令，混淆程序控制流[3];

* UPX，为软件提供高质量的打包和压缩[2];和
* LLVM优化器，支持各种独立于源和目标的二进制优化，其中一些对目标代码执行反编译/重新编译[1]。

结果表明，经过变换后的水印程序仍然可以正确地生成和链接水印载荷，并且仍然可以正确地提取隐藏的水印。这不仅表明我们的设计具有良好的弹性，而且表明如果我们想将基于ROP的水印与其他保护机制结合起来，我们的基于ROP的水印具有潜在的高兼容性。

### 4.4成本开销

在本小节中，我们将与基于图的水印进行比较，评估我们设计的性能开销。直观地说，基于ROP的水印在执行时间和堆空间上的开销都要小得多，因为它不需要将水印编码成复杂的数据结构(例如，图)。

在我们的实验中，我们使用CT水印技术将水印编码为基数图，因为它被广泛认为是基于图的水印中最有效的解决方案[11]。**测试中涉及的所有程序都是在同一设置下编译的**，使用两种方法进行水印的程序没有集成任何额外的保护机制。表2显示了运行时开销的结果，而图11显示了静态程序大小增量的结果。

我们发现，基于ROP的水印程序的运行时开销明显小于基于图形的程序的运行时开销(在某些情况下要小两个数量级以上)。我们的方法在程序大小上也经历了较小的增长。

我们还评估了为水印构造的堆分配数据结构的大小。这六个程序的结果非常相同，其中CT水印使用1,536字节的堆空间来编码192位水印在奇数图中，而我们基于ROP的水印在小工具以整数数组或结构/类格式化时分别使用156或188字节。同样，我们基于ROP的水印具有明显的优势。

### 4.5我们的方法与RopSteg

在本节中，我们给出了我们的方法和RopSteg在隐藏软件水印时的比较。正如第2节所讨论的，RopSteg是一个通用的工具，用于隐藏带有ROP的程序的代码部分。与软件水印相比，它具有不同的威胁模型，容易受到简单的程序转换攻击。在本小节中，我们转而关注两个评价。首先，在程序的正常运行(不生成水印)和水印生成中动态参与的插入的额外指令的数量。这是软件水印的一个重要的安全性评估，因为专门用于生成水印的指令(那些根本不参与程序正常运行的指令)是可疑的，并吸引程序分析。其次，我们还评估了项目规模增量。表3显示了我们测试的六个基准程序的平均结果，因为它们之间的结果是非常恒定的(在我们的方法的前一小节中显示，在RopSteg的[17]中讨论)。

我们的基于ROP的水印是基于这样一种思想设计的，即由水印引入的指令应该是具有双重性的，它们应该在程序的常规运行中执行(没有水印生成)。我们的评估(表3的第二列)确认我们的设计符合这个标准，因为100%的新添加的指令参与程序的正常运行。同时，只有61%的RopSteg插入的指令参与了程序的正常执行。此外，RopSteg导致的总尺寸增量比我们的方法要大。

## 5.讨论

### 5.1ROP的防御

已经提出了许多ROP防御措施来检测和阻止ROP执行[6,7,13,22,24,33]。可以想象，如果在部署了ROP防御的系统上触发，那么使用基于ROP的水印转换的程序中的嵌入式ROP执行将触发警报，并且水印提取发生的特定执行可能会被终止。

**然而，水印提取是一种特殊的场景，只有当某些相关方试图证明软件的所有权或识别授权用户时才会发生。这就是为什么使用一个特殊的输入来触发水印执行。在我们基于ROP的水印中，水印程序的正常执行将完全没有ROP执行的特征，因此不会与ROP防御相冲突。虽然提取隐藏在我们设计中的水印确实存在ROP行为，但我们认为，鉴于水印提取是一个特殊的事件，我们可以在专门的环境中简单地运行带水印的程序或暂时关闭ROP防御。**

### 5.2兼容性

我们的设计是在x86指令架构下实现和评估的。其他架构(如SPARC或ARM)上的有效性和效率可能与我们当前的结果有所不同。也就是说，有报道称ROP在各种平台上都取得了成功[4,14,16]，这表明我们的建议也可以在这些平台上发挥作用。

**然而，我们的设计使用了共享库中的小组件，这表明水印提取依赖于执行环境，例如库版本，以正确地重建ROP执行路径。一种可能的解决方案是获取多组水印payload字符串，每个字符串对应于所选库的不同版本，这样水印程序就可以检测其运行的环境，并将水印触发器指向相应的水印有效载荷。**我们把这个作为未来的工作。

### 5.3库替换攻击

目前，基于rop的水印的一个潜在弱点是所谓的库替换攻击，即攻击者用可能捆绑在软件包中的自定义库L‘替换了将链接到带水印程序的原始动态库，例如L。只要有小组件位于L中，这种替换就会在ROP过程中产生错误，从而影响水印恢复过程。在极端情况下，攻击者可能会替换所有的动态库，以防它不知道这些小组件驻留在哪里。我们计划在不久的将来改进我们在这方面的方法。

## 6.总结

我们提出了一种新的动态软件水印设计方案，该方案通过一种名为面向返回编程的内存错误利用技术嵌入和显示水印。我们的基于ROP的水印能够将重要的水印代码转换成ROP小组件，并在数据区域中构建它们。水印可以通过激活沿着这些小组件构造的ROP执行来提取。

评估表明，与以前的工作相比，我们的设计由于其细粒度的代码分布而实现了更好的隐身性。分析和实验还表明，我们的设计不仅可以很好地抵御代码混淆和重新打包的攻击，而且还可以显著降低开销。