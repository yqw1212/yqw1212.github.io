---
layout: post
title:  汇编语言学习(二)
date:   2020-07-30 00:00:01 +0300
image:  2020-07-30-deer.jpg
tags:   [asm]
---

### 一个源程序从写出到执行的过程

* 编写

* 编译、连接

  使用汇编语言编译程序（MASM.exe）对源程序文件中的源程序进行编译，产生目标文件

  再用链接程序（link.exe）对目标文件进行链接，生成可在操作系统中的直接运行的可执行文件。

  可执行文件包含两部分内容

  * 程序（从原程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
  * 相关的描述信息（比如：程序有多大、要占多少内存空间等）

* 执行

  操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS：IP指向第一条要执行的指令），然后由CPU执行程序。

### 源程序

#### 汇编指令

有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。

#### 伪指令

没有对应的机器码的指令，最终不能被CPU所执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。

segment和ends的功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。

一个段必须有一个名称来标识，使用格式为：

```assembly
段名 segment
段名 ends
```

一个汇编程序是由多个段组成的这些段被用来存放代码、数据或当作栈空间来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

End是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。

### 寄存器与段的关联假设

assume：含义为“假设”

它假设某一段寄存器和程序中的某一个用segment……ends定义的段相关联。

通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

### 源程序中的“程序”

我们可以将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行处理的指令或数据称为程序。程序最先以汇编指令的形式存在源程序中，经编译、链接后转变为机器码，存储在可执行文件中。

### 标号

一个标号指代了一个地址。

codesg放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。

### DOS中的程序运行

一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，将P2从可执行文件中加载入内存后，将CPU的控制权交给P2，P2才能得以运行。P2开始运行后，P1暂停运行。而当P2运行完毕后，应该将CPU的控制权交还给使得它得以运行的程序P1，此后，P1继续运行。

一个程序结束后，将CPU的控制权交还给使得它得以运行的程序，我们称这个过程为：程序返回。

### 程序返回

应该在程序的末尾添加返回的程序段

```assembly
mov ax,4c00H
int 21H
```

### 编译和连接

连接的作用有以下几个

* 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件。

* 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件。

* 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。

  所有在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。

### 可执行文件中的程序装入内存并运行的原理

command设置CPU的CS：IP指向程序的第一条命令（即程序的入口），从而使程序得以运行。

CX中存放的是程序的长度。

程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds：0

这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。

从256字节处向后的空间存放的是程序。

debug时使用P命令执行int 21.

Q命令退出Debug

### 操作系统的外壳

操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为shell的程序，用户（操作人员）使用这个程序来操作计算机系统工作。

DOS中有一个程序command.com，这个程序在DOS中称为命令解释器，也就是DOS系统的shell。

### [bx]和内存单元的描述

[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令

```assembly
mov ax,[bx]
```

bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA：EA处的数据送入ax中。

```assembly
mov [bx],ax
```

bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入SA：EA处。

### loop指令

指令的格式是

```assembly
loop 标号
```

CPU执行loop指令的时候，要进行两部操作

* (cx)=(cx)-1
* 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。

通常我们用loop指令来实现循环功能

```assembly
	mov cx 11
s:  add ax,ax
	loop s
```

* cx中存放循环次数
* loop指令中的标号所标识地址要在前面
* 要循环执行的程序段，要写在标号和loop指令的中间

```assembly
mov ax,0ffffh
mov ds,ax
```

在汇编源程序中，数据不能以字母开头，所以要在前面加0。

### 描述性符号()

为了描述上的简洁，我们可以使用一个描述性的符号"()"来表示一个寄存器或一个内存单元中的内容。

### 约定符号idata表示常量

我们在Debug中写过类似的指令：

```assembly
mov ax,[0]
```

表示将ds：0处的数据送入ax中。指令中，在"[...]"里用一个常量0表示内存单元的偏移地址。以后，我们用idata表示常量。

### 一段安全的空间

在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:200h~0:2FFh的256个字节的空间。所以我们使用这段空间是安全的。

