---
layout: post
title:  逆向实战之病毒分析
date:   2020-08-10 00:01:01 +0300
image:  2020-08-10-compass.jpg
tags:   [ctf,reverse]
---

# 壳与脱壳

壳，专门负责对程序体积进行压缩，或者保护一个程序不被非法修改、反编译、逆向分析的一类软件。

#### 壳的分类

* 侧重于缩小程序体积，则被称为压缩壳，经典的压缩壳软件有UPX、ASPack
* 侧重于程序代码与数据加密，则被称为加密壳

#### PE文件格式

Portable Executable，可移植的执行体，它是目前Windows平台上的主流可执行文件格式。最官方的参考资料微软官方SDK中的WINNT.H头文件。

Stud_PE

辅助学习PE文件格式，很方便的解析相关字段内容，并提供十六进制界面供对照。

CFF_Explorer

优秀的PE修改工具

010Editor

提供了PE文件的解析模板

查壳工具

* PEiD
* Exeinfo PE

### 壳的加载过程

* 入口现场保存

* 获取壳自身解密程序所需API的地址

* 解密原程序的各个区块（Section）的数据

* 初始化IAT，导入原程序所需系统API地址

  程序对于动态链接库中的函数的调用一般需要依赖一张导入地址表（Import Address Table，即IAT）程序被PE加载器加载后，PE加载器需要负责填充IAT。

  如果程序加壳了，壳将会自己模仿Windows PE加载器的工作来填充IAT中的相关数据，否则加壳程序不能正常运行。

* 调整重定位项

* Hook API，实现一些保护功能

* 恢复入口现场，跳转至OEP（Original Entry Point，原入口点）控制权转交

### 如何寻找OEP

* 根据跨段指令寻找OEP

* 根据堆栈平衡原理找OEP

* 用内存断点找OEP

  假设加壳程序的壳代码在解密程序时，首先解密（解压）code段，然后是data段，最后是rsrc段，那么我们可以通过在data段解密完成后对code段下内存访问断点，此时运行程序，程序段下的原因就只能是因为code段内存被执行而中断，并且会断在code段执行的第一条指令，一般来说也就是OEP。

### Dump内存

利用API Module32Next来获取进程的基本模块信息

### IAT修复

Dump出来的程序一般是无法直接运行的，因为缺少了必要的信息，PE加载器不能正确地填充IAT。

# 反调试技术

反调试技术多种多样，有的是基于进程在调试、未被调试这两种状态下的微小差异而实现的，例如：Window操作系统下，正在调试的进程的Process Environment Block（PEB）中的BeingDebugged字段将会被设置为True。

### 调用Windows API进行反调试

Windows操作系统提供了大量可供检测进程状态的API，通过调用这些API

* isDebuggedPresent

* CheckRemoteDebuggerPresent

* NTQueryInformationProcess

绕过方法——Hook相应API

ScyllaHide

### 使用断点检测进行反调试

* 软件断点
* 硬件断点

软件断点往往通过修改内存而实现（注意有别于内存断点），对内存是否被修改进行检测，便可以探测该类断点的存在。

对于x86架构，硬件断点是通过设置调试寄存器（Debug Registers，包括DR0……DR7）来实现的。当我们需要使用硬件断点时，需要将断点的地址设置到DR0……DR3中（因此最多仅支持4个硬件断点），并将一些控制属性设置到DR7中，基于这个原理可以编写检测硬件断点的代码。

### 时间间隔检测

在单步跟踪一段指令时，指令运行所耗费的时间于其未被跟踪的相差巨大。基于这个原理我们能非常轻易地编写出反调试代码，但这种反调试方式过于明显，且一般作用不大，易绕过。

### 基于异常的反调试

在Windows系统中，若某进程正在被另一进程调试，则其运行过程中产生的异常将首先由其调试器进行处理，否侧，将会直接由进程中注册的SEH（Structured Exception Hardling）处理函数进行处理。所谓SEH，简单来说，是一种能在一个进程出现错误的时候令操作系统调用用户自定义的回调函数的机制。

基于这个原理，我们可以编写代码，主动抛出一个异常（例如执行一条非法指令，或者访问一段非法内存等），随后在我们注册的SEH处理函数中对该异常进行接管，接着我们可以处理该异常，也可以针对性地进行一些反调试的的操作。

绕过方法

对于利用异常极值编写的反调试手段，我们一般需要对所使用的调试器进行配置，使之忽略程序产生的一些特定异常，这样，该异常就会依然由程序本身进行处理。对于x64dbg而言，可以通过“顶部菜单→选项→异常→添加上次”来忽略上一个产生的异常

### 其他常见反调试

* SetInformationThread API

* TLS callback function

* 特定调试器检测

# SMC动态加解密技术

SMC即Self-Modifying Code，会修改自身的代码，根据出现的时机可以分为两种

* 仅初始化时修改（例如各种压缩壳）
* 贯穿控制流的修改（各种动态解密代码、shellcode等）

作用

* 灵活，代码可以动态生成，各种代码动态机制都离不开SMC
* 隐蔽，运行时修改代码，能有效增加静态逆向工程难度

# 花指令的识别与去除&基本静态混淆手段

干扰反汇编器，程序中完全冗余，不影响程序功能，但却会对逆向工程产生干扰的指令。

* 加入无用且能干扰线性扫描反汇编器的指令序列

* 乱序

* 变形

* 控制流平坦化

* 虚拟机保护

  虚拟机保护的大范围使用最早便是出现在加密壳软件中，是一些加密壳的最强保护手段，其中最具有代表性的是VMProtect。

  VMProtect除了提供常规的数据加密、代码加密以及其他反调试等功能之外，还能在汇编指令层面对程序逻辑进行虚拟化，将开发者指定的代码段中所有的汇编指令转变为自行编写的一套指令集中的指令，并在实际执行时由自行编写的虚拟机执行器进行模拟执行。

反汇编方法

* 线性扫描反汇编
* 递归下降反汇编

