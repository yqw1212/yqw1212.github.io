---
layout: post
title:  Registered Report：DATALFLOW Towards a Data-Flow-Guided Fuzzer(NDSS 2022)
date:   2023-09-17 00:08:01 +0300
image:  2023-09-17-city.jpg
tags:   [note,paper,NDSS]
---

# Registered Report：DATALFLOW Towards a Data-Flow-Guided Fuzzer(NDSS 2022)

Adrian Herrera、Mathias Payer、Antony L. Hosking

​		数据流直观地更准确地描述了程序的行为。尽管这样有优势，但是由数据流覆盖驱动的模糊测试器受到的关注相对较少，主要出现在使用重量级程序分析（例如：污点分析、符号执行）时。不幸的是，这些更精确的分析带来了很高的运行时损失，阻碍了模糊测试器的吞吐量。

​        控制流边表示程序中操作的顺序，而数据流边捕获产生数据值的操作和使用它们的操作之间的依赖关系：实际上，这些操作之间可能没有控制流依赖关系。因此，数据流覆盖不活了不像控制流那样可见的行为，并直观地发现了更多或不同的错误。

## 介绍

​		代码覆盖率是程序行为的近似值，扩展代码覆盖率意味着探索程序行为。

​		控制流关注的是程序中的操作顺序(即分支和循环结构)，而数据流关注的是如何定义和使用变量(即数据)[14]:实际上，变量定义和使用地点之间可能没有控制依赖关系

​		不幸的是，精确的DTA很难实现，而且计算成本很高(例如，先前的工作发现DTA是昂贵的[18,19]，其精度在不同的实现中变化很大[18,20])。此外，一些真实的程序无法在DTA下编译，增加了可部署性问题。因此，大多数广泛部署的灰盒模糊器(例如，AFL [3]， libFuzzer[21]和honggfuzz[22])都避开了DTA，以支持更高的模糊吞吐量。

​		值得注意的是，我们的工作在执行过程中执行数据流分析，直接指导fuzzer。这与之前的工作(例如，GREYONE)形成对比，后者执行事后跟踪分析，试图推断或近似数据流。

## 背景和相关工作

### Fuzzing		

模糊器将输入放入队列中，然后

* 从队列中选择一个种子
* 改变种子(通过比特翻转、值替换等)
* 用突变种子执行目标，在覆盖图中存储覆盖(或其近似值)
* 检测崩溃和目标中新发现的覆盖率(将前者保存为脱机分析，将后者保存回队列中)。这个过程不断重复，直到遗漏bug的“剩余风险”降到合适的阈值以下[25]。

### 相关工作		

​		最流行的fuzzers是那些由代码覆盖年龄引导的[29]。通常，这种代码覆盖率是按基本块或边缘粒度测量的。

​		为了提高变异精度，一些模糊器使用动态污染分析(DTA)来跟踪输入字节。此信息用于推断要改变哪些字节。不幸的是，DTA存在精度和性能问题[18,20,30]，限制了部署。

​		IJON[33]引入了一种注释机制，用于跟踪覆盖图中的关键状态变量(例如，游戏《超级马里奥兄弟》中马里奥的x和y坐标)。

​		尽管有大量的工作与模糊覆盖指标相关，但纯数据流覆盖仍然是一个未被充分开发的指标。

## 数据流覆盖的目标		

​		使用基本块覆盖的模糊测试器不能区分相同块的不同顺序。这可以通过使用边覆盖来改进，这允许模糊测试器区分循环的前边缘和后边缘。

​		不幸的是，边覆盖仍然丢失了关于程序行为的重要信息（例如，灰盒模糊测试器依赖于覆盖信息来决定哪些输入突变导致新的程序行为）。

​		仅由代码覆盖率驱动的模糊测试器无法识别哪些变异的输入字节导致了新的程序行为。单个代码路径中数据访问和操作的差异讲丢失。

​		LLVM的DataFlowSanitizer（DFSan）不能跟踪未检测代码外部的污染（例如，通过外部库提供的函数，如malloc）。确保在代码中准确地跟踪需要大量的手工工作。

​		DTA也很昂贵。She等人发现，使用Triton DTA工具时，没有一个目标程序在24小时内完成。

​		考虑到DTA的缺点（准确性和成本），我们提出了一种替代方法：跟踪变量def定义端和use使用端之间的数据流。

## 设计和实现

需求：

* 构建基于数据流的覆盖度量的理论基础
* DATAFLOW如何整合这些观察结果
* DATAFLOW原型的实现，重点是发现内存安全漏洞。

### 覆盖敏感度		

​		数据流覆盖是对运行时执行的def/use链的跟踪

​		在模糊测试中，覆盖率度量的敏感性是它保留一系列突变测试用例的能力，直到它们触发一个bug。不同的敏感度使我们能够平衡效率和性能：更敏感的指标会导致更高的性能损失。

#### def端敏感度

​		完整的数据流覆盖要求识别和测量所有可变站点。

​		一种方法是按类型划分def站点，并将检测限制为给定类型（或类型集合）的def端。

​		按类型划分站点有几个优点。例如：检测数组变量使模糊器关注内存安全漏洞。同样，跟踪结构体的数据流可以发现类型混淆漏洞。基于类型的分类需要预先了解目标，以确保在运行时跟踪有意义的变量。

#### use端敏感度

​		在使用地点记录不同粒度的信息。当记录更精确的信息时，必须注意确保覆盖图不会饱和，阻塞模糊队列。

#### 组合敏感度

```assembly
 1 size_t max; // Set by the user
 2 unsigned int i = 0, j=0;
 3 char *prime = (char *)malloc(max);
 4 memset(prime, 1, sizeof(char) * max);
 5
 6 for(i=2; i<max; ++i){
 7     if(prime[i]){
 8         for(j=i; i*j<max; ++j){
 9             prime[i*j]=0;
10         }
11     }
12 }
```

![](https://raw.githubusercontent.com/yqw1212/yqw1212.github.io/master/img/2023-09-15-fuzz-use.jpg)

* Simple access：黄色区域。跟踪何时访问prime(第7行和第9行)。这样得到两个def-use链:第3行-第7行和第3行-第9行。这基本上相当于基本块覆盖：要达到第9行的访问，需要执行CFG中的所有基本块。与块覆盖一样，这提供了一个较差的程序行为的近似值（因为关于循环及其如何影响数据的信息丢失了）。

* Access with offset：红色区域。跟踪访问prime的时间以及访问prime的偏移量(索引i和j)。这提供了一个更完整的视图关于如何访问prime时产生了可忽略的开销（我们的实现比上述代码的简单数据流覆盖率增加了3%的开销）。在某些方面，这类似于MEMFUZZ的方法，它将内存访问合并到代码覆盖中[7]。这产生了2×(max-2)个def-use链：prime在每个索引被读出和写入的次数。

* Access with value：蓝色区域。跟踪何时访问prime以及访问期间的值(正在读/写)。这是最敏感的使用端覆盖指标，并且实现了传统数据流覆盖的目标：将值与变量关联，以及这些关联如何影响目标的执行[14]。这也类似于GREYONE的“污点推理”，它查看路径约束中使用的变量的值[19]。

  同样，这种级别的敏感性导致2×(max-2)个def-use链。在这里，prime可以取的值是完全确定的。然而，一般来说，这些值可能取决于用户的输入，因此会很快使模糊测试器的覆盖图饱和。

敏感度 lattice 组成必须平衡效率和性能：过于精确和模糊测试器的覆盖图将会造成饱和，降低吞吐量。

### 实现

描述DATAFLOW的高级架构，包括：

* 编译用于捕获所需灵敏度的def/use端的指令
* 实现运行时库用于跟踪def/use端的数据流，并将此信息提供给模糊测试引擎。

​		DATAFLOW的基于编译器的插桩是通过一组LLVM（v12）通道实现的。这些passes识别和指示def和use位置（在IR层面），因此这些位置之间的数据流，即def/use链可以在运行时被跟踪。

​		对指令的def位置的选择会影响覆盖的敏感性：更多的def位置导致更完整的数据流覆盖。

​        运行时库：将数据流的运行时跟踪简化为元数据的管理问题（def端标签时必须在use端被有效检索的元数据）。我们采用了一种低肥胖性的指针形式，将16位的def端的标签隐式地存储在指针本身。这种方法提供了许多优点——特别是相对于过度（中等）肥胖性的指针而言——包括与未检测/遗留代码的兼容性和廉价的元数据访问。

​        我们的低肥胖性指针系统的设计类似于Duck和Yap：我们实现了一个自定义的内存分配器fuzzalloc，它利用了x86_64体系结构提供的大量虚拟地址空间（我们假设它适用于具有足够指针位宽的体系结构）。fuzzalloc API由标记版本的malloc、calloc和realloc组成。这些被标记的函数(由编译器在defsites插入，提供了一种将堆分配的数据映射到def端标签的机制。

![](https://raw.githubusercontent.com/yqw1212/yqw1212.github.io/master/img/2023-09-15-fuzz-mapping.jpg)

​        将def端映射到内存空间，以便在use端进行有效检索。def端被映射到①和②两个独一无二的mspaces。use端通过右移操作检索指针的def端。use端被程序计数器（x86_64上是rip寄存器）识别，它被检索通过④处的`lea`指令。最后def和use端被通过hash绑定在一起成为一条def/use链在⑤处。根据敏感度的不同，指针被访问时的偏移量也可能包含在这个散列中。