---
layout: post
title:  Towards Measuring Supply Chain Attacks on Package Managers for Interpreted Languages(NDSS)
date:   2023-12-25 00:08:01 +0300
image:  2023-12-25-portrait.jpg
tags:   [note,paper]
---

# 针对解释语言的包管理器的供应链攻击度量

Ruian Duan, Omar Alrawi, Ranjita Pai Kasturi, Ryan Elder, Brendan Saltaformaggio, and Wenke Lee

## 摘要

包管理器已经成为现代软件开发过程的重要组成部分。它们允许开发人员重用第三方代码，共享他们自己的代码，最小化他们的代码库，并简化构建过程。然而，最近的报告显示，包管理器已经被攻击者滥用来分发恶意软件，给开发人员和最终用户带来了重大的安全风险。例如，eslint-scope，一个在Npm中每周有数百万次下载量的包，就被窃取了开发者的凭证。为了理解使最近的供应链攻击成为可能的安全漏洞和错误的信任，我们提出了一个比较框架来定性地评估解释语言的包管理器的功能和安全特性。在定性评估的基础上，我们应用元数据、静态和动态分析等知名的程序分析技术来研究登记的包的滥用。我们最初的努力发现了339个新的恶意软件包，我们报告给注册机构要求删除。包管理器维护者从339个报告的包中确认了278个(82%)，其中三个包的下载量超过10万次。对于这些软件包，我们已发放了官方CVE编号，以帮助从受感染的受害者中快速移除这些软件包。我们概述了将程序分析工具裁剪为解释性语言的挑战，并发布了我们的管道，作为社区构建的参考点，并帮助确保软件供应链的安全。

## 1.介绍

许多现代web应用程序依赖于解释性编程语言，因为它们有丰富的库和包。像PyPI、Npm和RubyGems这样的注册库(也称为包管理器)提供了一个集中的存储库，开发人员可以在其中搜索和安装附加包来帮助开发。例如，构建web应用程序的开发人员可以依赖Django[1]、Web2py[2]和Flask[3]等Python web框架来提供快速开发的样板代码。中心化的包管理不仅使开发过程更加高效，而且还创建了一个协作和共享开源代码的大型社区。不幸的是，不法分子已经找到了渗透这些社区的方法，并用恶意代码感染良性流行软件包，窃取凭证[4]，安装后门[5]，甚至滥用计算资源进行加密货币挖掘[6]。

这个问题的影响不仅仅局限于一次性的小型web应用程序，大型网站、企业甚至政府组织都依赖于开源解释编程语言来实现不同的内部和外部应用程序。攻击者可以通过简单地破坏第三方库的软件供应链来渗透到防御良好的组织中。例如，eslint-scope[4]，一个在Npm中每周有数百万次下载量的包，就被窃取了开发者的凭证。同样，在RubyGems中拥有超过1亿次下载的rest-client[5]也被入侵，在web服务器上留下了远程代码执行(RCE)后门。这些攻击表明，不法分子可以通过实施软件供应链攻击来秘密地访问大范围的组织。

安全研究人员[7]意识到了这些攻击，并提出了几种解决方案来解决第三方包中恶意软件的崛起。Zimmermann等[8]系统地研究了609个已知的安全问题，揭示了Npm生态系统中巨大的攻击面。另一方面，BreakApp[9]隔离了不受信任的包，这解决了凭证盗窃并防止对敏感数据的访问，但不能阻止加密货币挖掘或后门。此外，许多解决方案[10]-[12]假定固有信任，并专注于查找包中的错误而不是恶意包。更糟糕的是，一些攻击非常险恶，并使用社会工程技术[13]，[14]来伪装自己，首先发布一个“有用”的包，然后等到目标使用它来更新它并包含恶意有效载荷。尽管许多安全研究人员正在积极调查对注册表的攻击并提出解决方案，但这些方法似乎是临时的和一次性的解决方案。更好的方法是了解软件供应链滥用的程度，以及不法分子是如何利用它们的。该方法必须建立在允许对不同第三方库生态系统进行客观比较的基础上。

为此，我们提出了一个框架，突出了关键功能、安全机制、利益相关者和补救技术，以比较分析不同的第三方包生态系统。我们使用我们的框架来查看第三方包管理中心提供了哪些特性，执行了哪些安全原则，如何在不同的各方之间委托信任，以及管理中心为攻击后提供了哪些补救和应急计划。我们利用我们的发现来提供实际的操作项，管理维护人员可以使用预先存在的工具和安全性原则来执行这些操作项，这些工具和安全性原则将提高整个包管理生态系统的安全性。使用众所周知的程序分析技术，我们构建了MALOSS，这是一个为解释语言量身定制的管道，我们使用它来经验地研究包管理器的安全性。我们将这个管道公开，以供社区使用，作为参考或起点，帮助分析和识别可疑的包。

我们使用MALOSS管道对来自PyPI、Npm和RubyGems的100多万个包进行了研究，发现PyPI中有7个恶意包，Npm中有41个恶意包，RubyGems中有291个恶意包。我们向管理维护者报告了这些包，并删除了其中的278个，超过82%。报告的恶意软件包中有三个安装量超过10万次，它们被分配了一个官方CVE编号。我们提供了一个深入的案例研究，以展示我们的框架的实用性，并展示了这些恶意软件包的复杂性，并展示了它们的感染载体、功能和持久性。此外，为了研究恶意软件包的影响，我们使用被动dns数据来估计这些恶意软件包的安装范围。最后，我们提出了可操作的步骤，以帮助提高包管理器的整体安全性并保护软件供应链，例如在客户端添加打字错误检测以最大限度地减少开发人员的意外错误。

## 2.背景

注册中心是代码共享的平台，在软件开发过程中扮演着重要的角色。我们首先介绍开发、管理和使用来自注册中心的包的四个主要涉众，即注册中心维护者(rm)、包维护者(pm)、开发人员(Devs)和最终用户(Users)。然后，我们概述了第三方包注册滥用，并表明现有的研究不能解决供应链攻击的上升趋势。我们进一步深入研究安全漏洞，并确定保护注册中心的挑战

### A.主要利益相关者

我们在图1中勾画了主要涉众的特征以及它们在包管理器生态系统中的简化关系。注意，涉众是角色，可以分配给单个人员。

注册中心维护人员。注册中心维护者管理注册中心维护框架，并负责运行注册中心，注册中心是存放由pm开发的包的集中存储库。注册表为开发人员提供搜索和安装功能，以帮助在中央存储库中组织包。注册表通常由两部分组成:一个管理和服务包的web应用程序(例如，pypi.org)和一个提供对包的简单访问的客户端应用程序(例如，pip)。注册中心维护者要求pm在被允许发布(例如，经过身份验证的编写)他们的包之前注册。另一方面，开发者可以从注册表查询和安装(读取)，无论是否注册。

包维护者。包维护者管理包维护框架，并负责开发、维护和管理包。包维护者通常使用像GitHub这样的代码托管平台来管理他们的开发，并与其他有贡献的开发人员协作。他们可能会收到对其项目感兴趣的贡献者的pull请求，从而允许社区支持增强和维护。他们可以使用持续集成和持续部署(CI/CD)管道来自动化发布过程(即，构建和部署)。

开发人员。开发人员管理应用程序开发框架，并且是发布包的消费者。他们有责任在他们的软件中找到正确的软件包，并向最终用户发布他们的产品。开发人员专注于在他们的软件中开发独特的功能，并重用来自注册表的包来实现通用功能。此外，开发人员需要解决重用包的问题，例如已知的漏洞和不兼容性。

终端用户。虽然不直接与注册中心交互，但最终用户仍然是生态系统中重要的利益相关者。用户处于下游，在浏览器、移动设备或物联网(IoT)设备上使用开发人员的服务或应用程序。用户最终是为整个生态系统付费和提供动力的客户，然而，除了反馈渠道之外，他们无法控制软件，并且可能受到上游安全问题的影响。

### B.注册滥用概述

我们在图2中给出了供应链攻击的选择列表，跨越了不同类型的注册中心(例如:解释语言、系统范围)。2016年，Tschacher[7]演示了针对包管理器的概念验证攻击。攻击使用了typosquatting，这是一种错误拼写流行软件包的名称并等待安装流行软件包的用户键入名称(因此是typosquatting)的技术，结果反而安装了恶意软件包。截至2019年8月，在不同的注册表(PyPI、Npm、RubyGems等)中报告和删除了300多个恶意包。在图3中，我们汇总了上传到注册表中的恶意软件包的数量以及按上传年份计算的相应下载计数。我们注意到这些计数是记录/检测到的攻击，这是所有攻击(已知和未知)的子集。图3显示，仅2018年一年就出现了100多个恶意软件包，累计下载量超过6亿次。

Typosquatting只是一种攻击，漏洞分析平台Snyk[15]最近的一份报告将攻击分为三种类型，即Typosquatting、账户劫持和社会工程。劫持是通过凭证盗窃来破坏帐户，而社会工程是欺骗包存储库所有者转移所有权的欺骗策略。该报告强调，误输入是最常见的攻击策略，因为大多数注册中心不执行任何安全策略，如Loden[16]所示。账户劫持之所以发生，是因为攻击者可以猜到薄弱的凭证，而社会工程攻击利用了开源项目的协作性质，这在许多攻击中都可以看到[13]，[14]，[17]。不幸的是，社区的重点一直放在通过Synode[10]、NodeCure[11]和ReDoS[12]等平台查找包代码中的bug上。BreakApp[9]最近的努力使用了不可信包的运行时隔离，但由于需要开发人员的努力而缺乏实用性，并且无法处理诸如加密劫持之类的攻击。注册表维护者意识到了这些问题，并主动实现了一些安全性增强，如包签名[18]和双因素身份验证(2FA)[19]。尽管有这些值得赞扬的努力。

### C.保护注册安全的挑战

为了打击针对包管理器的供应链攻击，需要对生态系统进行深入分析，以了解哪一部分被滥用，谁负责，如何最好地防止此类攻击，以及可以采取哪些补救措施。尽管针对每个威胁提出临时修复方案可能很简单，例如针对帐户泄露的2FA，但系统地了解薄弱环节并提出对策仍然具有挑战性。为了实现这一点，我们在§III-A中提出了一个比较框架来定性地分析PyPI、Npm和RubyGems注册表。我们为解释型语言选择了这些包管理器，因为它们在开发人员中很流行，并且看到了最多的供应链攻击。该框架通过系统地分析注册表的功能、安全性和修复特性，以及针对攻击向量和恶意行为的现有攻击，清除了迷雾。

从定性分析中得出的一个重要结论是，注册中心目前几乎没有发布包的审查过程。因此，我们的直觉是，更多未知的恶意软件应该仍然存在。为了验证这一点，我们应用了众所周知的程序分析技术，如元数据、静态和动态分析来研究注册表滥用。然而，**现成的工具存在准确性和缺乏领域知识的问题**。首先，由于这些包可能有大量的依赖关系，直接对它们应用现有的静态分析工具不仅会**导致大量的时间和空间开销**，而且还会在重复分析常用包时浪费计算资源。例如，eslint和electron都在Npm上重用了超过100个包，包括间接依赖。受StubDroid[20]的启发，我们实现了模块化的静态分析，将依赖关系总结为格式以供进一步重用。其次，这些包是用动态类型语言编写的，**在执行方面很灵活，导致静态分析不准确，动态分析中的运行时需求复杂**。在本研究中，我们采取了最努力的方法来分析包的行为，并利用我们对现有供应链攻击的见解来标记可疑的攻击。然后，我们迭代地检查结果，以识别和报告恶意软件包。需要注意的是，我们并不是试图在程序分析中推进最先进的技术，而是将现有的工具编译成社区可以构建的功能管道。令人惊讶的是，我们在§III-B的初步努力中发现了339个新的恶意软件包，其中三个下载量超过10万次。

## 3.方法

### A.质量分析

自2018年以来，我们一直在跟踪对注册机构的供应链攻击，重点关注PyPI、Npm和RubyGems，它们受到的攻击最多。通过镜像这三个注册机构，我们获得了312个已报告攻击的样本。为了分析这些攻击，我们提出了一个框架，可以对注册的包进行比较分析，以确定根本原因和安全漏洞。该框架的灵感来自于对包管理生态系统中的管理和开发过程进行建模。我们概述了当前影响生态系统的威胁，并展示了如何将其应用于我们的框架。

1)注册机构特征:注册表是包管理器生态系统的核心组件，提供包托管和帐户保护等功能。我们在表1中列出了PyPI、Npm和RubyGems的特性，分为三类，即功能、审查和修复。

**功能特性。**如图1所示，PMs(作为供应商)访问帐户并在注册平台上发布和管理他们的包，而开发人员(作为消费者)从注册平台中选择并安装包作为依赖项。每个注册项在开发人员的系统上都有不同的安装方式，以及PMs的代码交付能力。访问指的是注册中心如何对PMs进行身份验证以发布包。我们将研究与帐户安全相关的特性，如公钥身份验证和多因素身份验证(MFA)。发布（Publish）指的是如何将包打包并发布到注册中心。我们看看发布方法，比如由PMs上传和通过包开发存储库引用。我们还将研究打包功能，如签名和命名规则，如错别字保护。Manage指的是如何管理包，以及包上允许有哪些控制。控件可以包括按版本删除包、弃用包或添加授权的协作者。选择（Select）指的是评级或声誉评分，它可以帮助开发者选择信任哪些软件包并将其添加为依赖项。我们查看与存储库和作者的评级和声誉相关的标准。安装（Install）指的是开发人员如何安装软件包。我们考察了一些特性，比如可以运行额外代码的安装钩子，可以指定安全依赖的依赖锁定，以及包是否可以包含专有代码。

**检查特性。**我们定义了注册中心可以实现的审查功能，以主动保护用户访问并检测易受攻击和恶意的包。不幸的是，它们目前都不受支持。元数据（Metadata）指的是对给定包的元数据分析，其中包括依赖性分析、作者信息、更新历史记录和附加的打包组件。静态（Static）指的是执行lint来进行风格和逻辑代码分析。这包括查找易受攻击的或恶意的代码。此外，它还包括扫描具有反病毒(AV)解决方案的二进制组件。动态（Dynamic）是指通过动态执行包来分析包的行为，并监控可疑行为，如网络连接、可疑文件访问等。

**修复功能。**一旦RMs确定了需要进一步调查的异常信号，安全团队就会调查事件案例，并执行删除和通知。Remove指的是RMs在基于报表删除包时的主动性。基本操作包括删除受影响的包和禁用发布者的帐户，而主动操作包括从已安装的包中删除。Notify是指RMs将违规包通知给公众的机制。这包括它们如何通知。例如，RMs可以在git repo上创建一个问题来通知PMs，或者通过电子邮件联系PMs。这也包括他们通知谁。例如，RMs可以将违规包及其依赖项通知pm等公共受害者。更主动的通知将寻求通知开发者和发布建议，告知其他依赖者并建议修复。

我们手动评估表1中功能部分下的每个特性。对于审查和修复特性，我们直接联系注册中心维护者，报告我们通过管道识别的恶意包。根据我们的信息交换，我们注意到他们的响应，例如他们在适当的位置检测或标记可疑包，并在表1的审查和补救部分记录它们。此外，我们从展示和博客中收集信息，这些信息披露了注册中心的安全实践

2)威胁模型:如图1所示，我们认为供应链攻击的目标是利用包管理器生态系统中的上游涉众(即PM和RM)，以扩大其对下游涉众(即开发人员和用户)的影响。我们调查了现有的供应链攻击报告，并详细说明了它们的攻击媒介和恶意行为。

**攻击向量。**有几个威胁颠覆了包管理供应链生态系统。我们将它们定义如下，并在图1中标注攻击号。注册利用是指利用托管所有包的注册表服务中的漏洞，修改或插入恶意代码[21]，[22]。Typosquatting指的是包的名字拼写错误，与流行的包相似，希望开发人员错误地指定他们的包，而不是预期的包[7]，[16]，[23]。这还包括跨注册Publish 3指的是直接发布包而不期望出现错别字。这可以用于机器人跟踪或恶意软件托管[27]。Account **Compromise**③是指对注册门户上的PMs账户进行入侵，使攻击者能够将包替换为恶意包或发布恶意版本[4]，[5]，[28]-[30]。和平台抢注流行名称(也称为包屏蔽[24])，希望开发人员错误地认为它们存在于特定的注册表中[25]，[26]。**Infrastructure Compromise**②是指PM的开发、集成和部署基础设施遭到破坏，攻击者可以将恶意代码注入包中[31]。心怀不满的内部人员①指的是插入恶意代码或试图破坏包开发的授权PM[32]。**恶意贡献者① (Malicious Contributor ①)**是指收到bug修复或改进的良性软件包，其中包含额外的易受攻击或恶意代码[14]。**所有权转移（Ownership Transfer）①③**是指包被废弃、回收或原业主将责任转移给新业主进行未来开发[13]，[17]。这种转移既可以发生在代码托管站点，也可以发生在注册中心。

**恶意行为。**在供应链攻击中，我们将受害者视为下游利益相关者，如图1中的开发人员和用户。开发者可以直接被利用来窃取他们的凭证或破坏他们的基础设施，也可以通过他们的应用程序或服务间接地成为接触用户的渠道。用户可能被利用来窃取他们的凭证或损坏他们的设备。我们参考了advisory[33]和blog[15]中对现有恶意软件的描述，将其恶意行为总结如下。**窃取**指的是收集敏感信息并将其发送给攻击者。可以收集或窃取各种类型的信息，从可用于跟踪敏感信息的不太敏感的机器标识符[34]，包括秘密令牌[4]，加密货币[14]，密码甚至信用卡，这可能导致进一步的危害或经济损失。**后门**是指在受害机器上留下代码执行后门。后门可以通过多种方式实现。它可以是特定属性(例如cookie)[29]的代码生成(例如eval)，特定负载[5]，或者允许任何命令的反向shell[35]。**破坏**是指对系统或资源的破坏。由于隔离，这在浏览器中不那么严重，但在开发人员基础设施和最终用户设备上至关重要。这可以是为了利润和乐趣。常见的事情是通过删除或加密文件系统来破坏系统，并要求金钱(勒索软件)[27]。加密劫持是指利用受害机器的计算能力进行加密挖矿。**加密劫持行为[**6]是一个新兴的恶意软件家族，它也出现在浏览器[36]和其他平台[35]，[37]中。**病毒**是指利用一个人可以同时是开发人员和PM的事实来感染他维护的包来传播恶意软件[38]。**恶意广告**是指利用访问受感染网站或使用受感染应用的最终用户点击与攻击者发布者账户相关的广告，从而为攻击者带来收入[39]。**概念验证(Proof-of-concept)**指的是没有实际危害的软件包，而是旨在证明恶意行为可以实现的概念验证[38]。

3)安全漏洞和信任缺失:我们在图1的供应链模型下进一步分析了前面列举的威胁。注册利用是由RMs的实现错误引起的，但它很难启动并且很少看到。Typosquatting和publish是由于RMs对PMs的隐性信任导致的。账户泄露是由于PMs粗心大意，不支持MFA和RMs检测异常账户造成的。基础设施妥协、内部不满和恶意贡献者是由于PMs的安全机制不足和RMs对PMs的隐性信任来保护他们的代码和基础设施。所有权转移是由于PMs和RMs对新所有者的隐性信任导致的。

安全漏洞需要对生态系统进行增强，并且很容易修复。例如，如表1所示，RMs可以支持或执行诸如用于帐户保护的2FA访问、用于代码托管服务和注册中心之间一致性的引用(基于webhook的)发布以及用于意图验证的客户端错字检测等功能。另外，PMs和RMs可以限制能够管理包发布的所有者，特别是对于流行的包，以最小化生态系统的风险。

为了更好地理解信任的破坏，我们在表2中列出了涉众的信任模型变化。RM是生态系统中的中心权威，所以PM和Devs必须信任RMs友善而负责地行事。但相反，尽管RM仍然可以信任社区中的大多数PM和Devs，但由于潜在的攻击者，RMs不应该信任所有的PMs和Devs。由于潜在的恶意贡献者和不满的内部人员，项目经理与贡献者和其他项目经理进行交互，也应该削弱他们对多数人的信任或基于声誉的信任。作为生态系统中的下游用户，开发者和用户必须相信上游利益相关者的善意，尽管他们可能会增加一些安全机制来保护。另一方面，开发者与来自互联网的用户互动，但是不信任他们。

### B.经验测量

我们的定性分析表明，这三个注册中心目前几乎没有发布包的审查过程，现有的供应链攻击主要是由社区报告的，没有自动化。直觉上，我们预计更多未知的攻击仍然存在于野外。因此，我们应用众所周知的程序分析技术，如元数据、静态和动态分析来发现注册中心的新恶意软件。值得注意的是，我们并不是在发明新的程序分析技术，而是利用现有攻击的洞察力来编译一个功能审查管道，用于分析包和发现潜在的攻击。

我们在图4中展示了审查管道MALOSS的工作流程和内部组件，它由四个组件组成:元数据分析、静态分析、动态分析和真实验证。来自注册中心的包由三个分析组件处理，以生成显示可疑活动的中间报告。我们从报告的攻击中整理启发式规则列表，用于包过滤和标记，当遇到误报时迭代改进。

(1)元数据分析：**元数据分析侧重于收集包的辅助信息(如包名、作者、发布、下载、依赖)，并根据不同的标准进行汇总。所有信息都直接从注册中心API中检索。**元数据分析可以标记可疑软件包，也可以识别与已知恶意软件相似的软件包。例如，包名称的编辑距离可以帮助根据包的名称对包进行分组，从而可以精确定位热门包的候选类型。作者信息可以帮助根据作者对包进行分组，从而可以识别来自已知恶意作者的包。元数据分析还包括检查包中附带的文件类型，以确定是否存在嵌入式二进制文件或本机扩展。

(2)静态分析:静态分析侧重于分析每个包管理器对应的解释语言的源文件，跳过嵌入式二进制文件和本机扩展。该分析由三个部分组成:手动API标记、API使用分析和数据流分析。为了允许在给定大量依赖项的情况下进行有效的处理，我们使用包摘要执行模块化分析。

**手动API标签**。如图5所示，**我们在静态分析中重点关注四种类型的运行时API，即网络、文件系统、进程和代码生成。网络API允许通过各种协议进行通信，如套接字、HTTP、FTP等。它们被用来泄露敏感信息[40]，获取恶意负载[5]等。文件系统API允许文件操作，如读、写、chmod等。它们被用来泄露ssh私钥[40]，感染其他包[32]等。流程API允许进程操作，如进程创建、终止和权限更改。它们被用来产生单独的恶意进程[6]。代码生成API (CodeGen)允许运行时代码生成和加载。这包括臭名昭著的eval和Node.js中的vm.runInContext等，它们被用来加载恶意负载[5]，[30]。**

对于每个注册的包的运行时，我们手动遍历它们的框架API，并检查它们是否属于上述任何类别。为了允许数据流分析，如果它们可以返回敏感或可疑数据，我们进一步将它们标记为数据sources，如果它们可以对输入执行可疑操作，我们将它们标记为数据sinks。请注意，API可以是source也可以sink，例如Node.js中的https.post既可以检索可疑数据，也可以发送敏感信息。此外，一些接收器api不必与源一起使用以执行恶意行为。

例如，Node.js中的fs.rmdir是一个接收器，如果它的参数来自用户输入，则会引发警告。但即使没有来源，fs.Rmdir可以通过将输入路径硬编码到根文件夹来破坏用户计算机。因此，我们需要识别可疑的API及其流。表5(见附录)给出了更详细的人工标注结果。

**API使用分析。**我们使用最先进的库[42]-[45]将包的源文件解析为抽象语法树(AST)，并在AST中搜索手动标记的API的使用情况。对于全局命名空间中的API(例如Python的eval)，我们使用它们的名称将它们与函数调用进行匹配。对于类的静态方法或模块的导出函数的API(例如Node.js的vm.runInContext)，我们通过跟踪类或模块的别名并匹配它们的全名来识别它们的使用情况。对于作为类的实例方法的API，由于在动态类型语言中识别它们是一个开放的问题，因此我们做出了权衡，并以两种方式识别它们的使用:仅使用方法名和使用默认实例名的方法名。尽管前者可能会高估，后者可能会有假阳性和假阴性，但我们认为它们在估计API使用情况时仍然有用。例如，通过处理清单1中eslint-scope的恶意代码片段，我们可以识别静态方法https.get下载恶意负载和执行它的全局函数eval。

此外，包可以有依赖项，并通过依赖项导出的函数间接调用可疑的api。例如，清单2中所示的discord.js-user通过依赖项请求窃取discord令牌。处理间接API使用的一种直观的解决方案是分析每个包及其依赖项，但这可能会导致重复分析公共包，并且由于依赖项太多，可能会耗尽资源。因此，为了提高效率和减少故障，我们执行模块化的API使用分析，每个包只分析一次。我们首先构建所有包的依赖树，并分析没有依赖的包的API使用情况。然后我们沿着依赖树往上走，把包的api和它们的依赖组合起来。设P<sub>k</sub>表示包k的api, i表示k所依赖的包，我们计算k的组合的API为∪<sub>i</sub>P<sub>i</sub>∪P<sub>k</sub>。

**数据流分析**。为了进行数据流分析，我们调查和测试了每种解释语言的开源工具，并为Python选择了PyT[46]，为JavaScript选择JSprime[47]，为Ruby选择了Brakeman[48]。我们对这些工具进行调整，以使用自定义的源和接收器配置来分析包，并在任何source-sink对之间输出已识别的流。通过使用这些工具，管道继承了它们在准确性和可伸缩性方面的局限性，我们认为如果有更好的替代方案，这些局限性可以得到改进。通过数据流分析，管道可以支持更具表现力的启发式标记规则。

与API使用分析类似，数据流分析需要处理流出或流入依赖项的流。受StubDroid[20]的启发，他们提出总结Java包的依赖关系以加速后续的数据流分析，我们对包进行数据流分析，以检查其导出的函数是返回来自已知源的值的间接源，还是其参数传播到sink的间接sink，或者是返回来自参数的值的传播节点。当我们沿着所有包的依赖树向上走的时候，我们输出确定的流，以及间接source、间接sink和传播节点，它们被合并到定制的配置中，用于后续的分析。例如，我们可以首先总结请求，以发现其导出的函数请求调用网络接收器(如https.post)，然后分析清单2中的代码，以识别通过网络泄漏令牌的恶意流。

(3)动态分析:动态分析侧重于执行包和跟踪系统调用。与静态分析相比，动态分析考虑源文件，以及嵌入式二进制文件和本机扩展，但它对运行时环境不可见(例如，不能跟踪eval)。分析由两部分组成，在Docker[49]容器内执行包用于沙盒，使用Sysdig[50]进行动态跟踪以提高效率和可用性。

方案执行。包可以以各种方式使用，例如独立工具或库，在动态分析中应该考虑到这一点。因此，我们以四种方式执行包，即安装、嵌入的二进制文件、导入和功能。对于安装，我们运行安装命令(例如:NPM install)来安装包，这会触发定制的安装钩子(如果有的话)，并允许攻击者以用户的权限进行操作。对于包中嵌入的二进制文件，我们从包中运行可执行文件，因为攻击者可以包含预构建的二进制文件或混淆的代码来阻碍调查。对于导入，我们导入包作为库来触发初始化逻辑，攻击者可以利用这些逻辑。对于函数，我们模糊化导出的函数和库类，以揭示它们的行为。当前原型调用导出的函数，用空参数初始化类，并递归地调用模块和对象的可调用属性。在执行包时，我们使用Docker[49]容器作为沙箱来保护底层系统免受像清单3中destroyer-of-worlds这样滥用系统资源的恶意软件的攻击。

**动态跟踪。为了捕捉进程与底层系统的交互，在基于linux的系统中有三种流行的工具，即Strace[51]、Dtrace[52]和Sysdig[50]。经过交叉比较，我们选择Sysdig作为跟踪工具，因为它效率高，可用性好。**为了充分利用计算资源，我们并行分析多个包，每个包在一个单独的Docker容器中，其名称编码包的信息，如名称、版本等。Sysdig捕获系统调用跟踪，并将它们与用户空间信息(如容器名称)关联起来，从而允许我们区分来自不同容器和包的行为。在进行原型设计时，我们跟踪与ip、DNS查询、文件和进程相关的系统调用，并将它们转储到文件中，以便进行进一步处理。

(4)真实验证:验证步骤是半自动化的，包括一个基于启发式规则标记可疑包的自动化过程和一个检查恶意和更新规则的手动过程。更新后的规则用于迭代过滤和缩小可疑包的范围。通过从现有的供应链攻击和其他恶意软件研究中学习[53]，我们指定了一组初始的启发式规则。完整的规则列表如表三所示。

**元数据分析规则。**为了标记输入错误的候选包，我们使用编辑距离来识别与注册中心内或跨注册中心的流行包名称相似但作者不同的包。为了通过推断找到可疑的候选程序，如果它们依赖于已知的恶意软件或具有相似的作者和发布模式，我们会标记包。为了通过所包含的文件类型来识别可疑的候选文件，如果包附带预构建的二进制文件,如Windows的PE和Linux的ELF文件，我们将标记它们。

**静态分析规则。**首先，受恶意软件通常在安装过程中执行恶意代码的启发，我们用定制的安装逻辑标记包。其次，受基于帐户的恶意软件通常保留现有的良性版本并发布新的恶意版本的启发，如果最近发布的版本使用以前未见过的网络，进程或代码生成api，我们会标记软件包。第三，受到恶意软件展示的窃取和后门行为通常涉及网络活动的启发，我们用某些类型的流标记包，例如从文件系统源到网络接收器的流，以及从网络源到代码生成接收器的流。

**动态分析规则。**首先，受到窃取和后门需要网络通信等行为的启发，我们标记了连接意外ip或域的包，其中预期的IP或域来自官方注册表(例如pypi.org)和代码托管服务(例如github.com)。其次，恶意行为通常涉及访问敏感文件，如果他们写入或读取这些文件(例如/etc/sudoers，/etc/shadow)，我们会标记包。第三，受加密劫持通常会产生一个加密挖掘进程的启发，我们用意想不到的进程标记包，其中预期的进程被初始化为注册客户端(例如pip)。

然而，为了为RMs或PMs提供采取行动的证据，我们必须手动调查可疑的包，以确认它们的恶意或将它们标记为假阳性，以帮助更新启发式规则。为了避免在更新规则时重新计算，缓存了分析的中间结果。我们迭代地执行基于规则的过滤过程和手动标记过程，以报告恶意软件。

## 4.发现

从§III-B4中的初始启发式规则集开始，我们迭代地标记可疑包，更新规则，最终发现339个新的恶意软件，其中PyPI中的7个恶意软件，Npm中的41个恶意软件和RubyGems中的291个恶意软件。我们分别向RMs报告了这339个新恶意软件，278个(82%)已被确认并删除，其中PyPI的7个被删除，Npm的41个被删除19个，RubyGems的291个被删除252个。在被删除的软件包中，有三个(即:paranoid2、simple_captcha2和datagrid)的下载量超过了10万次，这表明受害者数量很大。因此，我们为他们申请了CVEs (CVE2019-13589, CVE-2019-14282, CVE-2019-14281)，希望潜在的受害者能够及时得到通知进行补救。此外，我们在表六(附录)中列出了61个已报告但尚未删除的软件包。

在本节中，我们将表4中339个新报告的恶意软件与312个社区报告的恶意软件结合起来，并使用§III-A中提出的框架和术语分析这些供应链攻击，以了解其攻击向量和影响等各个方面。此外，我们列举了反分析技术和良性软件包中看似恶意的行为，以提高研究界的认识并帮助避免陷阱。具体来说，我们的结果包括:

* 注册中心中的包通过一些直接依赖关系紧密地连接到许多间接依赖关系，这意味着PM需要确保直接重用的包的质量，并且RM需要信任来检查间接使用的包是否存在恶意。

* 输入密码和账户泄露是最容易被利用的媒介，这表明攻击者倾向于使用低成本的方法，并且缺乏RMs的支持和PMs的意识来保护账户。

* 窃取和后门是最常见的恶意行为，表明所有下游利益相关者都是攻击目标，包括最终用户、开发人员甚至企业。

* 20%的恶意软件在包管理器中存在超过400天，下载量超过1K，这意味着缺乏对策和潜在的高影响，而它们的反向依赖关系进一步放大了这一点。

* 被动dns数据显示了供应链攻击的有效性，并验证了我们的直觉，即庞大的用户群可以帮助及时修复安全风险。

* 攻击者正在进化并使用代码混淆、多级有效载荷和逻辑炸弹等技术来逃避检测。

* 注册生态系统缺乏法规和明确的政策，导致信息窃取与用户跟踪之间的混淆等问题。

### A.实验设置

**环境。**我们使用20个本地工作站运行Ubuntu 16.04, 64GB内存和8 x 3.60GHz Intel Xeon cpu，从PyPI, Npm和RubyGems下载并分析所有软件包及其版本。我们使用带有60TB磁盘空间的网络附加存储(NAS)服务器为所有工作站提供共享存储。我们使用NAS服务器来镜像注册中心的包及其元数据，并存储分析结果。注册表镜像允许我们获得恶意软件的副本，即使它们被删除。

**工具和数据集。**对于元数据分析，我们从官方注册表API收集包及其版本的辅助信息。对于静态分析，我们依赖于开源项目进行AST解析[42]-[45]和数据流分析[46]-[48]，[54]。为了执行模块化分析，我们使用Airflow[55]为每个注册表构建依赖树并调度依赖树中的包的分析，该树能够调度任务的有向无环图(dag)。对于动态分析，我们依赖Docker[49]进行沙盒，依赖Sysdig[50]进行深度系统级跟踪。我们使用Celery[56]来安排包的分析。为了了解供应链攻击受害者的数量，我们与一家主要的互联网服务提供商(ISP)合作，根据他们的被动DNS数据检查相关的DNS查询。

### B.包统计

如表4所示，我们使用审查管道处理超过100万个包，分别从PyPI统计到186K，从Npm统计到997K，从RubyGems统计到151K。我们描述来自分析的见解。

元数据分析。对于注册中心中的所有包，我们在图6a中给出了每个包的版本数和下载量的分布。版本数量的分布表明，80%的包的版本少于7到9个，不同的注册中心有相似的分布，这意味着跨注册中心有相似的发布模式。相比之下，下载次数的分布在不同的注册库中有所不同，20%的RubyGems和PyPI包的下载次数分别超过了13835次和678次，这表明在RubyGems上发布的包被下载和重用的频率更高。

我们还在图6b中展示了前10K下载包的依赖项计数分布，包括直接和间接依赖项。80%的包有2个或更少的直接依赖关系，这就增加到20个或更少的间接依赖关系，这意味着PMs需要确保复用OSS的质量，并且RMs需要信任来检查包是否有恶意。图6b中间接依赖项的最大数量超过1K，这意味着当频繁重用的包受到损害时，间接依赖项的数量会显著增加。这表明PyPI和RubyGems面临着与之前研究[8]所强调的Npm相似的风险，例如单点故障和未维护包的威胁。

**静态分析。我们在图7a中展示了使用可疑api的前10K下载包的百分比。与eval这样的代码生成API是危险的并且很少使用的直觉相反，图7a显示了7%的PyPI包和10%的RubyGems包使用代码生成API。这样的代码生成APi不仅经常用于供应链攻击，而且如果它们的输入没有得到适当的处理，还可能导致代码注入漏洞。**

**动态分析。**我们动态分析了注册表中的所有包，方法是在Docker容器中对它们进行沙盒[49]，并使用Sysdig[50]跟踪它们的行为。图7b显示了根据§III-B4中的初始启发式，在每个注册表中显示意外动态行为的包的数量。图中显示，Npm和PyPI比RubyGems有更多带有意外网络活动(即IP和DNS查询)的包。需要注意的是，安装阶段的意外行为会被依赖包放大，从而导致图7b中出现大量标记包。这种冗余随后通过检查依赖树来删除。

### C.供应链攻击细节

我们根据§III-A中提出的框架和术语系统地总结了651恶意软件。在展示时，我们使用Overall来指代报告的恶意软件，Community用于指代社区报告的恶意软件，Authors用于指代作者报告的恶意软件。

**攻击向量。**我们在图8a中根据攻击向量对恶意软件进行了分类，其中typposquatting是最常被利用的攻击向量，其次是帐户泄露和发布。由于攻击者倾向于使用低成本的方法，因此可以直观地看出，typposquatting和发布将占主导地位。然而，帐户泄露的流行意味着缺乏RMs的支持和PMs保护帐户的意识。虽然不是很重要，但其他攻击向量，如恶意贡献者和所有权转移，都被攻击者利用，这表明包管理器生态系统中的每个利益相关者都应该提高意识，并参与打击供应链攻击。

**恶意行为。**我们根据恶意行为对恶意软件进行分类，如图8b所示，**窃取是最常见的行为，其次是后门、概念验证和加密劫持。我们进一步调查了占主导地位的类别，即窃取，并发现大约四分之三的人收集不太敏感的信息，如用户名，IP等，对开发者和最终用户造成的伤害较小。其余的窃取包收集各种敏感信息，如密码、私钥、信用卡等。至于后门和加密劫持，它们的流行表明攻击者不仅针对最终用户，还针对开发人员和企业的基础设施，这意味着开发人员和企业迫切需要采取行动。**

**持久性。**我们在图9中展示了每个恶意软件的持续天数和下载量的分布，其中20%的恶意软件在包管理器中持续超过400天，下载量超过1K。截至2019年8月，这三个注册中心都没有声称部署分析管道或人工审查流程，而是依靠社区来发现和报告恶意软件，从而导致恶意软件长期存在。为了更好地理解恶意软件在持久性和流行度方面的分布，我们在图10中展示了持久性天数与下载量之间的相关性。散点图显示，受欢迎的软件包可能会持续更短的时间，这可能是由于它们的用户基础更大。如图10所示，有18个恶意软件包被识别出来，下载量超过100K。我们(即作者)报告了这18个包中的4个。我们报告的三个恶意软件包，即paranoid2、simple_captcha2和datagrid，已被注册表维护人员确认并删除，并分别被分配为CVE-2019-13589、CVE-2019-14282和CVE-201914281。不幸的是，第四个已识别的恶意软件包rsa-compat仍然在线。它收集有关包、Node.js运行时和操作系统的信息，由于缺乏定义用户跟踪与窃取的策略，Npm维护者正在对其进行调查。

**影响。**除了恶意软件的特征外，我们还通过检查下载数量来衡量其潜在影响，特别是受影响的开发者和最终用户的规模。从图9b中，我们选择下载量超过1000万的恶意软件。最流行的恶意软件包(event-stream, 1.9亿次，eslint-scope, 4.42亿次，bootstrap-sass, 3000万次，rest-client, 1.14亿次)的总下载量(包括良性和恶意版本)达到7.76亿次。除了直接下载带来的威胁外，我们还强调，与面向用户的移动应用商店不同，注册表中的包面向开发人员，因此它们的依赖关系放大了它们的影响。此外，通过沿着图6b中的依赖树往上走来计算反向依赖，我们发现事件流有3,905个依赖，eslint-scope有15,356个依赖，bootstrap-sass有546个依赖，rest-client有4,722个依赖。通过测量它们的依赖下载，每个包的下载都被大大放大了——即event-stream - 5.39亿次，eslint-scope - 25.9亿次，bootstrap-sass - 4600万次，rest-client - 2.89亿次下载，总计34.64亿次恶意包下载，从而将影响放大了4.5倍。

需要注意的是，下载可能会因CI/CD管道而膨胀，并且可能无法反映受影响的开发人员和最终用户的确切数量。但是，由于注册表不提供此类信息，或者甚至可能没有此类信息，因此我们依赖下载次数来估计影响。

**感染。**尽管下载和反向依赖可以间接衡量恶意软件的流行程度，但目前尚不清楚恶意软件是否会进入开发者和用户的手中。观察到许多恶意软件在其恶意逻辑中涉及网络活动，受到启发，我们与一家主要的ISP合作，检查与恶意软件相关的DNS查询。我们首先手动检查恶意载荷并提取联系域。其次是排除常用的域名为良性目的，如pastebin.com和googleanalytics.com。我们根据ISP共享的被动DNS数据查询其余域，并在图11中显示按月汇总的域数量。数据包含2017年1月至2019年9月的查询，但由于数据丢失，2017年6月至2017年12月的查询除外。如图11所示，rest-client[5]中使用的域名mironanoru.zzz.com.ua在2019年8月有10次点击，但在2019年9月几乎为零。这与rest-client在2019年8月上传和删除的事实相匹配，这表明供应链攻击的有效性，并验证了我们的直觉，即庞大的用户群可以帮助及时修复安全风险。AndroidAudioRecorder使用的域名n.cdn-radar.com[26]直到2019年9月才被点击，即使在2018年12月被删除后也显示出感染。进一步的调查发现，没有针对这一事件建立公共咨询，受害者可能不知道这个问题，这意味着需要通知渠道。此外，ptpb.pw，一个在acroread中使用的域名[17]，由于加密矿工的服务滥用，于2019年3月永久关闭[57]，这意味着使用DNS查询关联恶意软件活动的可能性以及在线服务抗滥用的必要性。

值得注意的是，感染测量是经验性的，并假设与恶意软件相关的低容量DNS查询可能源于感染。然而，没有直接接触终端宿主，我们无法最终证明它们的感染。此外，DNS查询的数量可能在被动DNS数据中存在偏差，而作者无法控制或查看这些数据。

### D.反分析技术

在手动检查恶意载荷时，我们注意到恶意软件一直在发展，并利用各种反分析技术来挫败检测。受先前关于规避恶意软件[58]-[62]的作品的启发，我们列举并分类了这些供应链攻击中使用的技术，以提高社区的关注并帮助未来的分析。

**良性服务滥用。**攻击者可以滥用良性服务来隐藏自己并绕过保护机制。例如，清单4显示rest-client[5]滥用pastebin.com服务来托管它们的第二阶段有效负载，使得基于DNS查询的防御技术无效。同样，AndroidAudioRecorder[26]利用DNS隧道泄露敏感信息，滥用入侵检测系统(IDS)通常允许的DNS服务。从图11的DNS查询角度来看，pyconau-funtimes[64]成功地将攻击者隐藏在了0.tcp.ngrok的正常用户中。用于建立安全隧道的服务。

**多级负载。**由于反病毒工具大多基于签名，恶意软件倾向于通过将恶意逻辑分割成多个阶段并包含最小的代码片段来隐藏其逻辑和指纹足迹。例如，清单4只包含有效负载获取、代码生成和错误处理，并隐藏了其恶意逻辑，例如窃取环境变量和从pastebin.com的第二阶段有效负载中后门受感染的主机。

**代码混淆。现有研究[65]、[66]将恶意软件的混淆技术分为随机化混淆、编码混淆、逻辑结构混淆等，并指出恶意软件可以通过混淆代码来隐藏恶意逻辑，使其不被人工检测和自动检测。**我们发现供应链攻击也不例外。例如，getcookies[30]和purescript[32]都使用编码混淆。类似地，清单5中的快速请求[63]使用随机混淆和编码混淆来挫败分析。

**逻辑炸弹。TriggerScope[67]将逻辑炸弹定义为仅在某些(通常是狭窄的)情况下执行或触发的恶意应用程序逻辑。逻辑炸弹可以用来击败静态和动态分析方法。**例如，如果没有在生产环境中执行恶意负载(清单4中的第8行)，那么对rest-client[5]的动态分析将永远不会执行恶意负载。

**旧版本。几个恶意软件[5]，[29]通过帐户泄露发布利用独特的技术来击败分析。攻击者不是将恶意负载发布到最新版本的软件包中(即最大化受害者数量，从而增加被捕获的可能性)，而是将这些有效负载发布到旧版本的软件包中，以瞄准较少数量的受害者。我们可以想象，攻击者的直觉是，使用旧版本的开发人员对安全性不那么谨慎，从而最大化了攻击持久性，最小化了检测概率。**

### E.安全分析障碍

在真正验证过程中，我们遇到了一些看似恶意的行为，结果却是良性的。我们列举它们是为了提高研究界的意识，并帮助避免陷阱，同时希望RMs能够指定政策来定义和规范这些行为。

**安装钩子。**在安装过程中，一些软件包从在线服务获取数据，并在本地评估或将其写入敏感位置。例如，stannp使用c.docverter.com将其README转换为RST格式，而meshblu-mailgun试图通过在cdn.octoblu.com上检查预构建二进制文件的可用性来跳过构建过程。这种行为类似于恶意活动，会混淆自动分析。

**动态代码加载。**在运行时加载代码被手机商店认为是可疑的，因为它可能被滥用来将未知代码注入应用程序。然而，一些良性软件包在本地评估来自网络的有效负载。例如，清单6中的net_http_detector计算来自github.com的有效负载。

**用户跟踪。**pm可能希望跟踪用户以改善用户体验或增加业务，但是如果没有定义良好的策略，信息窃取和用户跟踪之间的界限是不明确的。例如，rsa-compat是由于缺乏用户跟踪策略而受到调查的包之一(图10)，它收集Node.js运行时和操作系统指标，并将它们发送回https://therootcompany.com。

## 5.缓解

### A.缓解策略

我们研究的目的不仅是引起人们对这个被忽视的问题的关注，而且还为包管理器生态系统中的利益相关者提供指导，以检测和减轻供应链攻击。我们在§III-A3中强调了RMs的直接增强和功能。然而，从长远来看，随着攻击者的发展，每个利益相关者都需要提高意识并帮助改善安全状况。

**注册中心维护人员。**RMs是生态系统中的中心权威。我们根据表一所示的三种类型的特征，即功能、审查和补救，详细阐述了它们的缓解策略

(1)功能特点:RMs可以通过提供MFA和代码签名，阻止弱密码或泄露密码，检测异常登录，显著提高账户保护。它们还可以通过在注册表客户端检测typosquatting和防止发布流行软件包的typosquatting来对抗typosquatting。此外，RMs可以发布策略来保护所有权转移，规范包行为，如在rsa-compat中跟踪用户而不通知，并排除不需要的包，如restclient，它声称是一个排版保护宝石，而没有证明自己的清白

(2)审查功能:RMs可以扩展审查管道，以识别具有(i)与现有流行包相似的名称或使用元数据分析与现有攻击相关的包，(ii)使用静态分析的可疑API使用和数据流，(iii)使用动态分析的意外运行时行为。真正的正面验证过程可以通过众包人工审查来扩展。由于包管理器生态系统是一个拥有项目经理和开发人员等利益相关者的开源社区，因此他们可以参与确保生态系统的安全。特别是，当RMs检测到可疑的包版本时，他们可以将此信息广播给相应的开发人员或发布分析结果以进行“社会投票”。

(3)修复功能:由于RMs拥有中央权限，他们不仅可以从服务器上删除恶意软件包和发布者，还可以通过与黑名单的比较，从客户端删除已安装的软件包。此外，RMs还可以使用各种通知渠道，如电子邮件、安全咨询和客户端检查，以通知涉众有关安全事件的信息。通知目标包括受影响包及其依赖的开发人员和项目经理。例如，如图11所示，移除AndroidAudioRecorder后的感染突出了基于通知的修复的重要性。

**包维护者。**针对PMs的攻击媒介包括帐户泄露、基础设施泄露、心怀不满的内部人员、恶意贡献者和所有权转移。PMs可以通过采用MFA、代码签名和强密码等技术来保护他们的帐户。PMs可以通过防火墙、及时的补丁和IDS来保护他们的基础设施。PMs需要对新的贡献者和不满的内部人员都保持谨慎，并且手动检查小的包或者为大的包使用代码审查系统。除了增强之外，项目经理还可以通过向顾问报告安全问题、更新依赖关系以避免已知问题、加入“社会投票”以及避免安全分析障碍来帮助改进生态系统。

**开发人员。**尽管开发人员无法控制上游包，但他们可以遵循最佳实践来修复安全问题。开发人员可以使用已知的安全包版本托管私有注册表，以避免来自上游利益相关者的供应链攻击。开发人员可以定期检查安全建议并及时更新，以避免已知漏洞。对于不受信任的包，开发人员可以手动检查，部署审查管道来检查代码，并在运行时隔离它们[9]，[10]，以避免潜在的危险。此外，开发者可以加入“社会投票”来改进安全性分析。

**终端用户。**尽管用户无法控制任何提供的服务和软件，但用户可以利用防病毒工具来保护他们的设备和保护自己。此外，用户可以提高他们的安全意识，只访问官方和信誉良好的网站。

### B.测量的局限性

我们的实证测量旨在利用现有供应链攻击的洞察力来识别野外的新攻击。我们的目标是揭示问题的严重性和普遍性，而不是在程序分析中实现高覆盖率和健壮性。目前形式的审查管道存在静态分析不准确和动态分析覆盖率低的问题，并且很容易被规避。我们邀请社区发展最先进的程序分析技术，以帮助保护包管理器生态系统。

**分析范围。**在对管道进行原型设计时，我们只考虑在静态分析中为每个注册使用相应语言编写的文件，不包括本机扩展、嵌入式二进制文件和用其他语言编写的文件。**我们在动态分析中只考虑Linux平台，特别是Ubuntu 16.04，不包括其他Linux发行版，Windows和MacOS环境。我们只考虑运行时依赖，从而忽略了开发依赖。**

**不准确的静态分析。**管道依赖于静态分析中现有的AST解析和数据流分析工具，由于动态类型的原因，这些工具可能不准确。此外，诸如反射和运行时代码生成之类的编程实践会加剧问题，并导致不准确的结果。然而，我们认为可以开发更准确的工具和算法，并在可用时将其集成到管道中。

**动态代码覆盖率。**该管道目前在Ubuntu 16.04上执行四种类型的动态分析，但可能代码覆盖率有限。可能的改进包括环境多样化(例如Windows、浏览器)、强制执行[68]、符号执行[69]等。

**反分析技术。**正如§IV-D所讨论的，攻击者已经进化并采用了反分析技术。我们预计未来会出现更复杂的技术，如故意易受攻击的代码和严重的混淆。我们恳请未来的研究人员与不断进化的攻击者作战。

**有效性的威胁。**实证测量包括两个手动步骤。首先，§III-B2中的手动API标签检查语言细节和运行时API。不正确的标签可能导致可疑包裹中的假阳性和假阴性。假阳性被真阳性验证进一步排除，而假阴性被我们的研究遗漏，在注册中仍然是恶意的。其次，§III-B4中的初始启发式规则和真正验证是基于已知的攻击和作者的领域知识。这一步可能会引入假阴性和错过恶意软件。

## 6.相关工作

**软件供应链攻击。**最早的软件供应链攻击是1983年的汤普森黑客攻击，他在编译器中留下了一个后门，即使程序的源代码是良性的，也可能危及程序。随后，类似的攻击[70]-[74]被发起，目标是各种供应链组件，如基础设施、操作系统、更新通道、编译器和加密算法。**近年来，针对包管理器的供应链攻击呈增加趋势[4]、[5]、[7]、[13]、[17]、[29]、[31]、[35]、[37]**，这些包管理器托管预构建包，以实现代码共享等好处。最近，Zimmermann等人[8]提出了一项关于Npm生态系统的研究，揭示了社区面临的高风险，如单点故障和未维护包的威胁。相比之下，我们的工作主要是针对三种流行的包管理器研究供应链攻击，以确定根本原因，扫描新的威胁并提出改进建议。作为副产品，我们对§IV-B中的三个包管理器进行了依赖性分析，发现它们遭受了类似的风险(即单点故障和未维护包的威胁)，正如Npm研究中强调的那样。由于我们的工作集中在描述供应链攻击上，我们没有进一步深入到风险量化和不同注册中心之间的比较。

**包管理安全。先前的工作研究了包管理器的设计和实现，并提出了攻击[75]，[76]和防御[77]-[79]。这些工作的重点是设计一个更安全的包管理器**，具有诸如折衷弹性和供应链完整性等属性。此外，由于Npm生态系统中的漏洞和恶意软件数量不断增加，人们提出了各种工作[8]-[12]、[80]、[81]来发现新的漏洞、隔离不受信任的包、评估风险和修复问题。我们的工作与以前的工作不同，我们研究了针对包管理器的真实供应链攻击的语料库，并提出了可操作的改进和建议。

**安全工具。**我们以一种可扩展的方式对审查管道进行原型化，这样就可以向管道中添加更多的工具来产生更好的结果。例如，针对各种语言[20]、[82]-[88]和二进制文件[89]、[90]的静态分析工具可能会生成更准确、更全面的结果。动态分析工具[51]，[52]，[68]，[91]-[95]可以增加动态代码覆盖率，并为各种平台和环境提供支持。此外，现有的威胁情报服务，如VirusTotal[96]和安全博客[97]，可以为分析工具识别的指标(如文件哈希值、URL、IP)提供信息，从而自动化对已知攻击的真正积极验证过程。

## 7.结论

为了系统地研究包管理器生态系统中最近的供应链攻击，我们提出了一个比较框架，揭示了利益相关者之间的关系。我们查明其根本原因，并总结其攻击媒介和恶意行为。基于我们的见解，我们将元数据、静态和动态分析等众所周知的程序分析技术汇编成一个大规模的分析管道，以揭示包的各个方面并帮助检测恶意包。通过反复验证，我们在PyPI中发现并报告了7个恶意软件，在Npm中发现了41个恶意软件，在RubyGems中发现了291个恶意软件，其中278个(82%)被删除，3个被分配了CVE。

我们将开放分析管道的源代码，并根据要求提供收集到的恶意软件样本用于研究目的，以帮助未来研究提高包管理器的安全性和防御供应链攻击。我们还邀请社区改进它，并邀请RMs投资部署它们，以设置最低安全门槛。