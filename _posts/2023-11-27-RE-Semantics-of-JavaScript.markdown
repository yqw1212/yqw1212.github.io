---
layout: post
title:  Sound Regular Expression Semantics for Dynamic Symbolic Execution of JavaScript(PLDI2019)
date:   2023-11-27 00:08:01 +0300
image:  2023-11-27-woman.jpg
tags:   [note,paper]
---

# JavaScript动态符号执行的正则表达式语义的正确性

这篇文章的标题是《JavaScript动态符号执行的正则表达式语义的正确性》（Sound Regular Expression Semantics for Dynamic Symbolic Execution of JavaScript）。该论文的作者是Blake Loring、Duncan Mitchell和Johannes Kinder。文章介绍了一种针对正则表达式的动态符号执行的模型，旨在提高测试生成和错误检测工具对正则表达式的支持。目前主流的正则表达式引擎在处理一些常见功能（如反向引用和贪婪匹配）时存在问题，导致测试覆盖率不足或错误被忽略。为解决这一问题，作者提出了一种基于字符串约束和经典正则表达式的模型，并使用细化方案来处理匹配优先级和贪婪性的问题。

文章中介绍了他们在JavaScript的动态符号执行引擎ExpoSE中实现了该模型，并对包含正则表达式的1000多个Node.js软件包进行了评估。实验结果表明，他们的方法在提高正则表达式查询成功率和覆盖率方面是有效的。

该论文还提供了ECMAScript 2015（ES6）正则表达式语言的完整模型，并介绍了一种基于反例引导抽象细化（CEGAR）方案，用于处理贪婪性对捕获组的影响。此外，论文还对JavaScript正则表达式的使用进行了系统研究，并发现非正则特性被广泛使用。

总之，该论文的主要贡献是提出了一种支持JavaScript正则表达式的动态符号执行模型，并通过实验证明了其在实践中的有效性。这对于提高测试生成和错误检测工具对正则表达式的支持具有重要意义。

## 摘要

在基于符号执行的工具中，用于测试生成和bug查找的正则表达式支持是不够的。主流正则表达式引擎的常见方面，如向后引用或贪婪匹配，被忽略或不精确地近似，导致测试覆盖率低或遗漏bug。在本文中，我们为ECMAScript 2015 (ES6)的完整正则表达式语言提出了一个模型，该模型适用于测试和执行函数的动态符号执行。我们使用字符串约束和经典正则表达式对正则表达式操作进行建模，并使用改进方案来解决匹配优先级和贪心问题。我们在JavaScript的动态符号执行引擎ExpoSE中实现了我们的模型，并在超过1000个包含正则表达式的Node.js包上对其进行了评估，证明了该策略是有效的，可以显著增加成功的正则表达式查询的数量，从而提高覆盖率.

## 1.介绍

正则表达式在开发人员中很流行，用于匹配和替换字符串，许多编程语言都支持正则表达式。例如，在JavaScript中，可以编写/goo+d/.test(s)来测试s的字符串值是否包含“go”，后面跟着一个或多个“o”和最后一个“d”。类似地，s.replace(/goo+d/，"better")计算为一个新字符串，其中s中第一个这样的出现被字符串"better"取代。

一些测试和验证工具包括对正则表达式的一定程度的支持，因为它们非常常见[24,27,29,34,37]。特别是，SMT(可满足模理论)解算器现在通常支持字符串和经典正则表达式的理论[1,2,6,15,25,26,34,38 - 40]，它允许表达约束，如上面测试示例中的s∈L(goo+d)。尽管任何关于字符串的一般理论都是不确定的，但现代SMT求解器可以有效地求解许多字符串约束。

SMT解算器在语言理论意义上支持正则表达式，但是像Perl或javascript这样的编程语言中的“正则表达式”——通常称为regex，我们在本文的其余部分也采用这个术语——并不局限于表示正则语言b[3]。例如，表达式/<(\w+)>.*?<\/\1>/解析任何匹配的XML标记对，这是一种上下文敏感的语言(因为标记是必须出现两次的任意字符串)。

阻止正则表达式转换为常规语言中的单词问题的有问题的特性包括捕获组(上面示例中\w+周围的括号)、反向引用(\1引用捕获组)和子表达式的贪婪/非贪婪匹配优先级(.*?是贪婪的,)。此外，任何这样的表达式也可以包含在forward(?=)中，它可以有效地编码上下文敏感语言的交集。在关于字符串操作程序的工具推理中，这些特征通常被忽略或不精确地近似。这是一个问题，因为它们被广泛使用，正如我们在§7.1中所演示的那样。

在用于测试生成的动态符号执行(DSE)的上下文中，这种支持的缺乏可能导致覆盖范围的损失或错过错误，因为约束必须包含非规则语言中的成员。困难来自于路径条件中典型的混合约束—简单地为一个独立的正则表达式生成一个匹配的单词是很容易的(不需要查找)。迄今为止，在这个问题上只取得了有限的进展，主要是解决了使用近似解决方案实现的直接需求，例如捕获组[29]和反向引用[27,30]。然而，匹配优先级和查找头在以前都没有解决过。

本文提出了一种在动态符号执行中支持ECMAScript正则表达式的新方案，并在实践中证明了该方案的有效性。我们依赖于ECMAScript 2015 (ES6)中正则表达式及其相关方法的规范。然而，我们的方法和发现应该可以很容易地转移到大多数其他现有的实现中。特别是，我们做出了以下贡献:

* 我们根据经典正则语言和字符串约束(§4)对ES6正则表达式进行了完整的建模，并涵盖了以前工作中缺失的几个方面[27,29,30]。我们引入捕获语言的概念，使匹配和捕获组分配问题自包含。

* 我们引入了一个反例引导的抽象细化(CEGAR)方案来解决贪婪对捕获组的影响(§5)，这使我们能够在DSE中部署我们的模型，而不会牺牲近似不足的可靠性。
* 我们首次对JavaScript正则表达式进行了系统研究，检查了NPM软件库中415,487个包的功能使用情况。我们表明非规则特征被广泛使用(§7.1)。

在本文的其余部分，我们将回顾ES6正则表达式(第2节)，并通过示例(第3节)概述我们的方法。然后，我们使用新的公式(§4)详细介绍了我们的正则表达式模型，并提出了一个CEGAR方案来解决匹配优先级(§5)。我们将讨论该模型的实现，作为JavaScript的ExpoSE符号执行引擎的一部分(§6)，并评估其对DSE的实际影响(§7)。最后，我们回顾相关工作(§8)并总结(§9)。

## 2.ECMAScript正则表达式

我们将回顾ES6正则表达式规范，重点关注它与经典正则表达式的区别。我们从regex API及其匹配行为(第2.1节)开始，然后解释捕获组(第2.2节)、反向引用(第2.3节)和操作符优先级(第2.4节)。ES6正则表达式与其他语言的正则表达式相当，但缺乏Perl的递归和回溯，并且不需要类似posix的最长匹配。

### 2.1Methods, Anchors, Flags

ES6正则表达式是RegExp对象，由字面量或RegExp构造函数创建。RegExp对象有两个方法，test和exec，它们需要一个字符串参数;字符串对象提供了匹配、分割、搜索和替换方法，这些方法需要一个RegExp参数。

如果字符串的任何部分与表达式匹配，则regex接受字符串，即，它被通配符隐式地包围。可以用锚控制字符串中的相对位置，^和$分别匹配开始和结束。

正则表达式中的标志可以修改匹配操作的行为。忽略大小写标志i在匹配时忽略字符大小写。多行标志m重新定义锚字符以匹配输入的开始和结束或换行字符。unicode标志u改变了在表达式中转义unicode字面值的方式。粘性标志y强制匹配从RegExp开始。lastIndex，它使用前一个匹配的索引进行更新。因此，RegExp对象变得有状态，如下例所示:

r = /goo+d/y;

r.test(“gooood”);/ /正确; r.lastIndex = 6

r.test("good ");/ /错误; r.lastIndex = 0

全局标志g的含义不同。它扩展了match和replace的效果，以包括字符串上的所有匹配，它相当于RegExp的test和exec方法的sticky标志。

### 2.2捕获组

正则表达式中的括号不仅改变运算符优先级(例如，(ab)\*匹配字符串“ab”的任意重复次数，而ab\*匹配字符“a”后面跟着字符“b”的任意重复次数)，而且还创建捕获组。捕获组按照左括号的顺序从左到右隐式编号。例如,/a|((b) \*c) \*d/编号为/a|(1(2b)\*c)\*d/。

在只需要括号的情况下，可以使用语法(?:…)．

对于正则表达式，捕获组很重要，因为正则表达式引擎将记录与每个捕获组匹配的最新子字符串。捕获组可以使用反向引用从表达式内部引用(参见§2.3)。

某些API方法还返回每个捕获组的最后匹配的子字符串。在JavaScript中，match和exec的返回值是数组，整个匹配在索引0处(隐式捕获组0)，最后匹配的第i个捕获组实例在索引i处。在上面的示例中，"bbbbcbcd".match(/a b|((b)\*c)*d/)将计算为数组["bbbbcbcd"，"bc"，"b"]。

### 2.3反向引用

regex中的反向引用指向一个编号的捕获组，并将匹配引擎最后匹配捕获组的对象。一般来说，向正则表达式添加后向引用会使可接受的语言变得非正则[3]。

在量词(Kleene star、Kleene plus和其他重复操作符)内部，由反向引用匹配的字符串可以在多个匹配中更改。例如，正则表达式/((a|b)\2)+/可以匹配字符串"aabb"，反向引用\2被匹配两次:第一次，捕获组包含"a"，第二次包含"b"。

### 2.4操作评价

我们在表1中解释了本文感兴趣的算子;§6中描述的实现支持完整的ES6语法[14]。一些操作符可以重写为语义上等价的表达式，以减少需要处理的情况的数量(如重写专栏所示)。

正则表达式区分贪婪求值和惰性求值。贪婪操作符消耗尽可能多的字符，使整个正则表达式仍然匹配;惰性操作符消耗尽可能少的字符。这种区别——称为匹配优先级——对于经典正则语言来说是不必要的，但确实会影响捕获组的分配，从而影响反向引用。

零长度断言或遍历不使用任何字符，但仍然限制接受的单词，从而强制实现语言交叉。正向或反向查找头可以包含任何正则表达式，包括捕获组和反向引用。在ES6中，lookbehind只能通过\b(词边界)和\B(非词边界)使用，它们通常只用于(或从不)匹配字符串中的整个单词。

## 3概述

在我们方法的概述中，我们现在定义regex(§3.1)的词问题以及它如何在DSE(§3.2)中出现。我们通过示例(第3.3节)介绍我们的regex模型，并解释如何通过细化(第3.4节)消除虚假的解决方案。

### 3.1单词问题和捕获语言

对于任何给定的经典正则表达式r，只要w是由r生成的(正则)语言中的单词，我们就写w∈L(r)。对于正则表达式r，我们还需要记录正则表达式r中捕获组的值。

### 3.2动态符号执行中的正则表达式

```assembly
let timeout = '500';
for (let i = 0; i < args.length; i++) {
let arg = args[i];
let parts = /<(\w+)>([0-9]*)<\/\1>/.exec(arg);
    if (parts) {
        if (parts[1] === "timeout") {
            timeout = parts[2];
        }
    ...
    }
}
assert(/^[0-9]+$/.test(timeout) == true);
```

清单1中的代码从它的输入变量args(一个字符串数组)解析XML标记之间的数字参数。

第4行中的正则表达式将每个参数分成两个捕获组:标记和数值(部分[0]是整个匹配)。当标记为“timeout”时，它会相应地设置超时值(第6-7行)。在第12行，运行时断言在处理完参数后检查超时值是否真的是数值。断言可能会失败，因为程序包含一个错误:第4行中的regex使用Kleene星号，因此也允许将空字符串作为要设置的数字，JavaScript的动态类型系统将允许为空字符串设置超时。

DSE通过系统地枚举路径(包括断言[17]的故障分支)来查找此类错误。从带有输入的具体运行开始，例如，args[0] =“foo”，DSE引擎将尝试构建一个路径条件，该条件根据输入值对分支决策进行编码。它尝试系统地翻转路径条件中的子句，并查询SMT求解器以获得覆盖不同路径的输入分配。这个过程会一直重复，直到所有的路径都被覆盖为止(这个程序在循环输入字符串的时候有无限多的路径)。

如果不支持正则表达式，DSE引擎将在调用exec时具体化参数，并将具体结果分配给各个部分。随着所有后续决策的具体化，路径条件变为pc = true，引擎将无法覆盖更多路径并找到漏洞。

### 3.3建模捕获语言隶属度

在路径条件中捕获语言成员约束不能直接用SMT表示。我们根据经典规则语言的隶属关系和字符串约束对它们进行建模。对于给定的ES6正则表达式R，我们首先只用原子术语重写R(参见表1)，即|、*、捕获组、向后引用、查找和锚。为了与JavaScript API保持一致，我们还引入了外部捕获组C0。考虑正则表达式R = (?:a|(b))\1。预处理后，捕获语言的隶属度问题就变成了

一种通用重写，允许字符在没有锚的情况下在匹配之前和之后出现的字符。

我们递归地将捕获的语言隶属度降低为常规隶属度。首先，我们平移纯规则的Kleene*和外部捕获组，得到

其中++是字符串连接。我们继续分解正则表达式，直到只剩下纯正则项或标准字符串约束。接下来，我们翻译嵌套捕获语言约束

在处理交替时，要么满足左侧，捕获组变为未定义(我们将其表示为Ø)，要么满足右侧，捕获锁定到匹配，我们将其建模为

最后，我们对反向引用进行建模，这取决于它所引用的捕获组是否已定义:

综上所述，我们得到R的模型:

### 3.4改进

由于匹配优先级(贪婪)，这些模型允许分配捕捉在实际执行中不可能实现的组。例如，我们对/^a*(a)?$/建模为：

这允许C1是a或空字符串ε，即元组(“aa”，“aa”，“a”)将是我们模型下捕获语言的虚假成员。因为a*是贪婪的，它总是消耗字符串"aa"中的两个字符;因此,(a)?只能匹配ε。这个由贪婪和懒惰算子语义引起的问题在以前的工作中仍然没有得到解决[27,29,30,34]。为了解决这个问题，我们使用了一个反例引导的抽象优化方案，该方案使用一个符合ES6的匹配器来验证候选赋值。继续这个例子，候选元素(“aa”，“aa”，“a”)通过在字符串“aa”上运行一个具体的匹配器来验证，这与C0 =“aa”和C1 = ε的候选捕获相矛盾。通过反例对模型进行了细化:

然后，我们生成并验证一个新的候选对象(w, C0, C1)，并重复细化，直到一个令人满意的赋值通过具体的匹配器。

## 4.对ES6正则表达式建模

我们现在详细描述了建模捕获语言的过程。

在将给定的ES6正则表达式R预处理到R '(§4.1)之后，我们对约束(w, C0，…)进行建模。， Cn)∈Lc (R ')，通过递归地将R '的抽象语法树(AST)中的术语转换为经典的正则语言隶属关系和字符串约束(§4.2-4.3)。最后，我们展示了如何对否定约束(w, C0，…，Cn) 不属于 Lc (R')(§4.4)建模。

### 4.1预处理

为了便于说明，我们将项R1, R2的串联R1R2显式地表示为二进制运算符R1·R2。然后，任何正则表达式都可以拆分为原子元素、捕获组和反向引用(根据ES6规范[14]，统称为术语)的组合，并通过显式操作符连接。使用表1中的规则，我们将任何R重写为等效的正则表达式R '，其中只包含交替、连接、Kleene*、捕获组、非捕获括号、遍历和反向引用。我们将所有剩余的惰性量词重写为它们的贪婪等价物，因为模型与匹配优先级无关(这是在细化中处理的)。

注意，Kleene+和repeat的规则重复捕获组，例如，将/(a){1,2}/重写为/(a)(a)|(a)/添加两个捕获组。因此，我们显式地将原始表达式和重写表达式之间的捕获组关联起来。重写包含K个捕获组的Kleene+表达式S+时，S*S有2K个捕获组。对于形式为(C1，…， CK)∈Lc (S+)的约束，重写为

由于S\*S包含S的两个副本，Ci,j对应于S*S中S的第j个副本中的第i个捕获。我们将捕获之间的直接对应表示为

### 4.2 操作和捕获组

设t是在R'的AST中处理的下一项。如果它是无捕获的并且是纯规则的，那么在这一步中不需要做任何事情。如果t是非正则的，则它包含k +1个编号为i到i + k的捕获组(k≥- 1)。在每个递归步骤中，我们表示捕获语言(w, Ci，…， Ci+k)∈Lc (t)，通过一个由字符串和规则语言隶属约束以及t子项的一组剩余捕获语言隶属约束组成的模型。注意，我们在预处理步骤中记录了regex中捕获组的位置。当将t分解为子项t1和t2时，对于某些j，捕获组Ci，…， Ci+j包含在t1中，Ci+j+1，…，Ci+k包含在t2中。各个操作的模型如表2所示;我们将在下面讨论规则的细节。

当匹配一个交替变量|时，非匹配侧的捕获组将是未定义的，用Ø表示，这与空字符串ε不同。

当建模量化t = t1\*时，我们假设t1不包含反向引用(我们在§4.3中解决这种情况)。在这个例子中，我们通过表达式t1\*t1|ε来建模t，其中t1是对应于t1的正则表达式，除了每一组捕获括号被重写为一组非捕获括号。这样，t1是正则的(假设它是无反向引用的)。然而，t1\*t1|ε在语义上并不等同于t:如果可能，必须满足捕获组，因此t1\*不能消耗表达式的所有匹配。我们对这一约束进行编码，暗示当t1|ε与空字符串匹配时，t1*也必须匹配。

向前看将单词限制为断言表达式和t2语言的成员。单词边界\b实际上是对单词和非单词字符的单字符查找。因为边界可以以两种方式出现，所以模型对w1的结束和w2的开始分别为单词和非单词，或非单词和单词字符使用析取。非词边界\B定义为\b的复制。

对于捕获组，将下一个捕获变量Ci绑定到t1匹配的字符串。第1个捕获组必须是外部捕获，因此其余捕获Ci+1，…，Ci+k必须包含在t1内。对于非捕获组不需要执行任何操作，并且在所包含的子表达式上继续递归。

锚断言输入的开始(^)和结束($);我们分别通过元字符<和>来表示单词的开始和结束。在大多数情况下，当处理这些操作时，t1将为ε；这是因为很少在标记输入开始的操作符之前(或分别在标记输入结束的操作符之后)使用regex操作符。在这两种情况下，我们都断言语言定义了输入的开始或结束，因此，t1的语言必须是一个空单词，尽管可以定义捕获组(例如通过包含嵌套捕获的断言的t1)。我们给出了用于将正则表达式与多行标志集匹配的单独规则，这些规则修改了锚的行为，以接受元字符或换行符。

### 4.3反向引用

表3列出了正则表达式AST中不同情况下的反向引用模型;\k是对R的第k个捕获组的反向引用。直观地说，每个反向引用的实例都是一个指向捕获组的变量，其类型取决于R的结构。

如果后向引用在匹配时只能求出单个值，则称其为不可变的;如果它可以接受多个值，则它是可变的，这是一种罕见但特别棘手的情况。例如，考虑/((a|b)\2)+\1\2/。在这里，反向引用\1和\2的第二个实例是不可变的。然而，\2的第一个实例是可变的:在Kleene+下外部捕获组的每次重复都可以改变第二个(内部)捕获组的值，从而改变此量化中的反向引用的值。例如，字串“aabbbbb”满足这个正则表达式，但“aababaa”不满足。为了充分描述这些区别，我们引入以下定义:

定义2(反向引用类型)。设t是正则表达式r的第k个捕获组：

1. 如果k大于R中的捕获组数量，或者在R的AST的后序遍历中在t之前遇到\k，则\k为空;

2. 如果\k不为空，那么\k是可变的，并且t和\k都是R中某个量化项Q的子项;
3. 否则，\k是不可变的。

当反向引用为空时，它被定义为ε，因为它指向的捕获组要么是一个超项，例如/(a\1)*/，要么出现在项的后面，例如/\1(a)/。

不可变后向引用有两种情况。在第一种情况下，反向引用没有被量化。在我们的模型中对于R, Ck已经用等式约束建模了，所以我们可以将反向引用绑定到它。在第二种情况下，反向参考发生在量化中;在这里，匹配的单词是被引用的捕获组的相同副本的有限连接。这两个模型还包含了捕获组为Ø这样的极端情况。由于交替或空的Kleene*。根据ES6标准，在这种情况下，反向引用的计算结果为ε。

不幸的是，从该模型生成的约束很难求解，对于当前的SMT求解器来说也不可行，因为它们需要“猜测”匹配字符串变量的分区，将其划分为单独的和变化的组件。为了解决这样的查询，我们引入了一个替代前面规则的方法，将量化的后向引用视为不可变的。得到的模型如表3的最后一行所示。例如,回到/((a|b)\2)+\1\\2/,我们可以接受(“aaaaaaaaa”、“aaaaaaaaa”,“aaaa”,“a”),而不是(“aabbaabbb”、“aabbaabbb”,“aabb”,“b”)。我们将在§5.4中讨论健全性含义。量化的背景引用很少(见§7.1)，因此在实践中效果有限。

### 4.4建模非成员变量

目前所描述的模型过于接近捕获语言的隶属关系。我们为∀C0，…， Cn: (w, C0，…， Cn) 不属于 Lc (R)定义一个类似的模型。直观地，非隶属度模型断言，对于所有捕获组分配，存在某些分割词，使得其中一个单独的约束被违反。大多数模型都被简单地否定了。在连接和量化中，只否定了语言和空性约束，所以模型采用以下形式：

回到§3.3的例子，∀C0,C1:(w,C0,C1)不属于Lc((?:a|(b))\1)的否定模型变成：

## 6.实现

我们现在描述我们的方法在DSE引擎ExpoSE1[27]中的实现。我们解释了如何通过捕获语言成员(第6.1节)对regex API进行建模，并简要概述了ExpoSE(第6.2节)。

### 6.1建模正则表达式API

ES6标准指定了几个计算正则表达式的方法。我们按照它为RegExp .exec(s)指定的伪代码来实现匹配，并根据在algorithm 2中捕获语言成员关系来捕获组分配。值得注意的是，我们的算法实现了对ES6指定的所有标志和操作符的支持。

RegExp.test(s)与表达式RegExp.exec(s) !== undefined完全等价。以同样的方式，可以为为ES6定义的其他正则表达式函数构建模型。我们的实现包括剩余功能的部分模型，这些模型允许在实践中有效地生成测试，但在语义上不完整。

算法2首先从粘接或全局标志的前一个匹配的末尾开始处理标志，并且它重写正则表达式以接受忽略大小写标志的字符的小写和大写变体。

我们在输入中引入<和>元字符，它们在匹配过程中充当字符串开始和结束的标记。接下来，如果设置了sticky或全局标志，我们将在lastIndex处对输入进行切片，以便新的匹配从前一个匹配的末尾开始。由于引入了元字符，如果lastIndex大于零，则需要偏移1。然后重写regex源，以允许字符先于匹配并成功匹配。注意，我们使用(?:.|\n)\*?而不是.\*?因为通配符。使用ECMAScript正则表达式中除换行符外的所有字符。为了避免将这些字符添加到最终匹配中，我们将原始regex源放在捕获组中。这就形成了C0，它被定义为整个匹配字符串[14]。预处理完成后，我们测试每个捕获组的输入字符串和新字符串是否在表达式的捕获语言内。如果是，则创建一个results对象，该对象返回正确映射的捕获组、输入字符串以及删除元字符后字符串中匹配的开始。否则lastIndex被重置并返回undefined。

### 6.2ExpoSE

ExpoSE是一个DSE引擎，它使用jalang2[19]框架来检测一段JavaScript软件，以便创建程序跟踪。当程序终止时，ExpoSE调用SMT求解器Z3[13]，从跟踪中识别所有可行的备用测试用例。然后将这些新的测试用例排队，并以分代搜索[18]的方式选择执行下一个测试用例。ExpoSE框架允许并行执行单个测试用例，在每个测试用例结束时聚合覆盖率和可选路径信息。这种并行化是通过将每个测试用例作为分配给专用单核的唯一进程来执行的;因此，分析是高度可伸缩的。

我们的测试用例选择策略类似于Bucur等人提出的CUPA策略。我们使用程序分叉点对未开发的代码进行优先级排序:每个表达式都有一个唯一的标识符，计划的测试用例根据创建时执行的表达式进行分类。我们通过从分析期间访问最少的桶中随机选择一个测试用例来选择下一个测试用例;这将优先考虑由不太常见的表达式触发的测试用例。

## 7.评价

我们现在根据经验回答以下研究问题:

(RQ1)非经典正则表达式是JavaScript中的一个重要问题吗?

(RQ2) ES6正则表达式的准确建模是否使基于dse的测试生成更有效?

(RQ3)模型和细化策略的性能是否支持实际分析?

我们通过调查正则表达式在野外的使用来回答第一个问题(§7.1)。我们通过将我们的方法与现有的在一组广泛使用的库(第7.2节)上的ExpoSE[27]中支持正则表达式的部分实现进行比较来解决RQ2。然后我们在超过1000个JavaScript包(§7.3)上衡量我们方法的每个方面的贡献。我们通过分析每个查询的求解器和细化统计来回答RQ3(§7.4)。

### 7.1调查正则表达式的使用情况

我们专注于为Node.js编写的代码，Node.js是一种流行的独立JavaScript框架。Node.js用于服务器和桌面应用程序，包括流行的工具Slack和Skype。我们分析了来自NPM仓库的415,487个包，NPM仓库是开源Node.js代码的主要软件仓库。将近35%的NPM包包含一个正则表达式，20%包含一个捕获组，4%包含一个反向引用。

我们开发了一个轻量级的静态分析，它可以解析包中的所有源文件，并识别正则表达式和函数调用。我们不检测new RegExp(…)形式的表达式，因为它们通常需要更昂贵的静态分析。因此，我们的数字提供了正则表达式使用的下限。

我们发现regex在JavaScript中的使用非常广泛，在总共415,487个扫描包中，有145,100个包至少包含一个regex。表4列出了量化中包含正则表达式、捕获组、反向引用和反向引用的NPM包的数量。注意，大量的包使用捕获组和反向引用，这证实了支持它们的重要性。

表5报告了收集到的所有9M正则表达式的统计信息，给出了每个特性包含它的表达式的比例。NPM包中的许多正则表达式并不是唯一的;这似乎是由于重复包含相同的文字(而不是引入常数)，使用在线解决方案解决常见的问题，以及依赖项的包含(在适当的依赖项管理之前)。为了调整这一点，我们提供了遇到的所有表达式和唯一表达式的数据。在这两种情况下，都有大量的捕获组、反向引用和其他非经典特性。由于量化后向引用的发生率很低，我们不区分可变和不可变后向引用。

结论本研究结果证实了正则表达式的广泛应用，并且通常包含复杂的特征。特别重要的是对捕获组的忠实处理，它们出现在被检查的包中的20.45%。另一方面，由于量化的反向引用只占正则表达式的0.01%，在§4.3中引入的优化很少会在DSE期间导致额外的欠近似。

### 7.2超越技术水平的改进

我们将我们的方法与最初的ExpoSE[27]进行比较，据我们所知，后者是JavaScript中唯一可用的、功能性的支持正则表达式的实现。

我们评估了两个版本的ExpoSE在一组库上实现的语句覆盖率，选择它们是因为它们的受欢迎程度(每周下载量高达2000万)和regex的使用。这包括三个库minimist、semver和validator，第一版的ExpoSE在[27]上对它们进行了评估。为了公平地比较原始的ExpoSE和我们的扩展，我们对两者都使用了原始的自动化库工具。因此，我们没有利用测试生成的其他改进，例如我们在工作过程中添加的符号数组支持。我们使用内存为256GB的32核机器，在两个版本上每一个小时重新执行每个包6次，然后取结果的平均值。我们将细化方案限制为20次迭代，我们在初步测试中确定为有效的(见§7.4)。

结果。表6包含了我们的比较结果。为了提供程序大小的指示，我们使用在运行时加载的代码行数(JavaScript加载依赖项的动态方法使得很难静态地确定有意义的LOC计数)。

结果表明，使用我们的模型和细化策略扩展的ExpoSE可以将我们广泛使用的库样本的覆盖率提高十倍以上。在moment、query-string和yn的情况下，原始ExpoSE中缺乏ES6支持，因此无法进行有意义的分析，导致覆盖率为0%。以semver为例，如果在一小时后停止，我们会看到覆盖率下降。这是由于正则表达式的建模增加了求解时间(参见§7.4)。当以两个小时的超时时间执行两个版本的ExpoSE时，覆盖率不足就会消失。

我们发现我们对ExpoSE的修改使得在使用regex的广泛使用的库中生成测试更有效。这表明本文提出的解决正则表达式查询的新方法对DSE中的实际问题具有重大影响。我们还看到其他对ExpoSE的改进，比如对ES6的支持，也影响了覆盖范围。因此，我们继续对模型的各个方面进行评估。

### 7.3贡献点

现在，我们深入研究regex支持中的各个改进是如何促进覆盖率的增加的。

方法。从我们调查§7.1的正则表达式包中，我们开发了一个包含1131个NPM库的测试套件，ExpoSE能够为其自动生成有意义的测试工具。在选择的每个库中，ExpoSE至少对符号字符串执行一个正则表达式操作，这确保库包含一些与本文范围相关的行为。以这种方式构建的测试套件包含许多库，这些库是工业中广泛使用的包的依赖项，包括Express和Lodash.2。

自动测试生成通常需要定制的测试工具或参数化单元测试集[33]，以在没有简单命令行接口的代码中实现高覆盖率，包括库。通过执行所有导出的带符号参数的方法，为支持的类型string、boolean、number、null和undefined, ExpoSE的工具可以完全自动地探索库。返回的对象或函数随后也以同样的方式进行探索。

我们执行每个包一小时，这通常允许达到一个(潜在的初始)覆盖平台，在这个平台上，额外的测试用例不会进一步增加覆盖。我们将正则表达式支持分解为四个级别，并度量每个级别对行覆盖率和测试执行率的贡献和成本(表7)。作为基线，我们首先具体地执行所有正则表达式方法，具体化参数和结果。在第二个配置中，我们添加了ES6正则表达式及其方法的模型，包括对单词边界和查找的支持，但删除了捕获组并具体化了对它们的任何访问，包括反向引用。第三，我们还完全支持捕获组和反向引用。最后，我们还添加了改进方案来解决过逼近问题。

结果。表7显示，对于每个支持级别，覆盖率提高的目标包的数量和百分比;覆盖度相对增加的几何平均值;和平均测试执行率。最后一行显示了与基线相比启用完全支持的效果。注意，改进的包的数量少于上面的行之和，因为包的覆盖率可以通过多个特性得到改进。

在这种规模的数据集中，包括许多只使用少量正则表达式的库，平均覆盖率增长预计很小。尽管如此，我们看到专门的支持提高了至少象征性地执行一个regex函数的一半以上的包的覆盖率。正如预期的那样，最大的改进来自于支持正则表达式的基本符号执行，即使没有捕获组或考虑匹配优先级。然而，当添加捕获组时，我们看到了进一步的改进，这表明它们确实影响了程序语义。细化影响较少的包，尽管它在需要的地方显著地促进了覆盖。这是因为幸运的解算者可能会在第一次尝试时生成正确的输入，即使是在模糊的设置中。

对于数据集中的一些库，该方法非常有效。例如，在清单解析器n4mf-parser中，完全支持比具体的提高了29%的覆盖率;在格式转换库sbxml2json中，减少14%;在浏览器检测库mario中，下降了16%。在这些方案中，细化方案都有助于提高覆盖率。一般来说，增幅最大的是包含基于正则表达式的解析器的包。

每个额外的特性都会导致平均测试执行速度的小幅下降。尽管一小部分(约1%)的查询可能需要超过300秒的时间来解决，但并发测试执行可以防止DSE在单个查询上停滞不前。

结论。对ES6正则表达式的全面支持在实践中提高了JavaScript DSE的性能，但代价是执行时间增加了16% (RQ2)。在固定的时间窗口内以较低的执行率增加覆盖率，这表明完整的正则表达式支持提高了单个测试用例的质量。

### 7.4对真实案例查询的有效性

我们现在研究模型的性能和改进方案来回答RQ3。最后，我们还讨论了细化限制及其对分析的影响。

方法。我们收集了NPM实验期间的查询数据(§7.3)，以提供SMT查询成功率和执行时间的详细信息，以及改进方案的使用情况。

结果。我们发现，在测试的1131个包中，有753个(66%)执行了至少一个包含捕获组或反向引用的查询。在这些包中，653个(58%)包含至少一个需要细化的SMT求解器查询，134个(12%)包含一个达到细化限制的查询。

总的来说，我们的实验执行了58,390,184个SMT查询来生成测试用例。正如预期的那样，大多数不涉及正则表达式，但它们构成了重要的一部分:4,489,581(7.6%)查询建模了正则表达式，645,295(1.1%)建模了捕获组或反向引用，74,076(0.1%)需要使用细化方案，2,079(0.003%)达到了细化限制。精化方案非常有效:至少有一个精化的查询中只有2.8%达到了精化极限(在建模捕获组的所有查询中，只有0.003%达到了精化极限)。在经过改进的SMT查询中，产生一个有效的、令人满意的赋值所需的平均改进次数是2.9;大多数查询只需要一次细化。

表8详细说明了每个包和每个查询处理SMT问题所花费的时间。我们提供了问题的四个关键方面的数据:我们报告了每个包和每个查询在约束求解器上花费的时间，以及策略中特别具有挑战性的部分在约束求解器上花费的时间。我们发现，细化的使用使平均每个查询的求解时间增加了四倍;然而，这主要是由达到细化限制的SMT查询主导的，平均运行时间要长10倍。在一些包的求解器中花费的最小时间很低，这可以归因于在执行早期遇到正则表达式的包，但是测试工具或函数模型(与正则表达式无关)的限制阻止了进一步的探索。

总结。我们发现改进方案是非常有效的，因为它能够解决97.2%遇到的包含正则表达式的约束问题。这也是必要的，因为10%的包含捕获组的查询导致了一个虚假的令人满意的赋值，需要进行细化。

通常，只需要少量的改进就可以产生一个正确的、令人满意的分配。因此，即使细化限制为5或更少也是可行的，并且可以在对覆盖率影响较小的情况下提高性能。

### 7.5对有效性的威胁

现在我们来看看影响结果有效性的潜在问题，特别是可靠性、包选择和可伸缩性。

稳健性。除了模型的稳健性(参见§5.4)，还必须考虑实现的稳健性。在缺乏ES6正则表达式的机械化规范的情况下，我们的代码无法被证明是正确的，因此我们使用了一个广泛的测试套件来进行验证。然而，假设具体匹配器是符合规范的，如果算法1终止，即使§4的实现包含错误，也会返回约束公式的符合规范的模型。在最坏的情况下，算法不会终止，导致超时和失去覆盖。因此，bug只会降低报告的覆盖率改进。

在§7.3中，我们选择了在我们的调查(§7.1)中确定的软件包，其中我们的通用软件包在DSE的一小时内遇到正则表达式。这使我们能够将评估重点放在regex支持上，而不是评估工具的质量(并且必须处理包中不可访问的代码)。使用这个工具可能会将包的选择限制在更简单、不具代表性的库中。然而，我们发现简单的api并不意味着简单的代码:最终的数据集包含几个复杂的包，例如语言解析器，并且遇到的正则表达式类型与调查结果一致。对于简单的代码，我们发现ExpoSE通常可以达到100%的覆盖率;这样做的失败要么是由于代码的复杂性，要么是缺乏对与正则表达式和api无关的语言特性的支持，这些特性需要额外的建模(例如，文件系统)。

一般来说，可伸缩性是DSE面临的一个挑战，而不是我们的正则表达式模型所特有的。根据经验，单个测试(插装、执行和约束生成)的执行时间与程序大小呈线性增长，求解器查询的平均大小也是如此。查询长度对求解时间的影响各不相同，但我们的regex模型似乎并没有加剧查询长度的影响。原则上，我们的模型兼容组合方法[4,16]和状态合并方法[5,21]，这有助于DSE扩展到大型程序。

然而，我们方法的可扩展性足以满足Node.js的需求:JavaScript的LOC计数比c++等更小，而且NPM上的代码非常模块化。例如，在最依赖的前25个NPM库中，最大的是30kloc(但不包含正则表达式)。为我们的评估选择了几个包，比如babel-eslint，它们的KLOC在20-30之间，并且使用通用的工具进行了有意义的探索。

## 8.相关工作

在之前的工作中，我们介绍了ExpoSE，并根据经典正则语言的隶属关系和字符串约束[27]引入了对JavaScript正则表达式编码的部分支持。这个问题最初的解决方案缺乏对几个有问题的特性的支持，比如查找头、词边界和锚。匹配优先级是一个开放的问题，我们现在已经通过我们的改进方案解决了这个问题。

理论上，正则表达式引擎可以通过解释器[9]以符号方式执行。虽然这消除了建模的需要，但在实践中，由于路径爆炸，整个解释器和正则表达式引擎的符号执行很快变得不可行。

还有其他几种JavaScript的符号执行方法;大多数包括对经典正则表达式的有限支持。Li等人[24]提出了一种针对正则表达式程序的自动化测试生成方案，该方案为遇到的每个正则表达式在线生成匹配函数，加剧了路径爆炸。Saxena等人提出了第一种通过字符串约束对捕获组进行编码的方案。Sen等人[31]介绍了Jalangi，一个基于程序仪表和concolic值的工具。Li和Ghosh b[23]和Li等人[22]描述了一个用于JavaScript和浏览器DOM的自定义浏览器和符号执行引擎，以及一个支持大多数JavaScript字符串操作的字符串约束求解器PASS。尽管所有这些方法都具有对ECMAScript regex的一些支持(例如对捕获组的有限支持)，但它们忽略匹配优先级，并且不支持向后引用或查找。

thom等人提出了一种启发式方法来解决涉及不受支持的字符串操作的约束。我们选择对求解器不支持的操作进行建模，并采用CEGAR方案来确保正确性。Abdulla等人提出使用一种改进方案来解决复杂的约束问题，包括支持与上下文无关的语言。带后向引用的正则表达式语言不是上下文无关的[10]，因此，它们的模式不足以编码所有正则表达式;然而，他们的方法可以作为比经典正则表达式更丰富的基础理论。Scott等人[30]建议可以通过连接约束来消除反向引用，但是他们没有提出这样做的方法。

来自字符串求解社区的进一步创新，例如涉及复杂函数的字符串约束的可判定性[12,20]或支持递归字符串操作[35,36]可能会在将来提高我们的方法的性能。我们将我们的技术整合到DSE引擎的级别，而不是约束求解器，这使得我们的工具可以利用字符串求解技术的进步;同时，我们可以利用本机正则表达式匹配器，避免将正则表达式特定于实现语言的细节集成到求解器中。

之前对4000个Python应用程序的正则表达式使用情况的调查[11]也为正则表达式建模提供了强有力的动机。我们的调查将这项工作扩展到JavaScript，样本量要大得多

## 9总结

本文提出了ES6中完整正则表达式语言的一个模型，该模型适用于test和exec函数的动态符号执行。我们根据字符串约束和经典正则语言的隶属关系对正则表达式的隶属关系约束进行建模。我们引入了一种新的CEGAR方案来解决匹配优先级的挑战，这在目前的相关工作中很大程度上被忽视了。

据我们所知，我们的解决方案是ES6的第一个全面解决方案。我们证明了正则表达式——特别是它们的非规则特性——在JavaScript中被广泛使用，并且现有的基于DSE的分析因此会因具体化而遭受覆盖损失。在对超过1000个Node.js程序的大规模评估中，我们的新解决方案优于现有的部分方法，并证明了我们的模型在改进字符串操作JavaScript程序分析方面的可行性。