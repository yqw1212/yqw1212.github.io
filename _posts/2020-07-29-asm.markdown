---
layout: post
title:  汇编语言学习(一)
date:   2020-07-29 00:00:01 +0300
image:  2020-07-29-flowering.jpg
tags:   [asm]
---

# 引言

汇编语言是直接在硬件上工作的编程语言，首先要了解硬件系统的结构，才能有效地应用汇编语言对其编程。

## 机器语言

机器语言是机器指令的集合

## 汇编语言的产生

汇编语言的主体是汇编指令

汇编指令和机器指令的差别在于指令的表示方法上

寄存器：CPU中可以存储数据的器件，一个CPU中有多个寄存器

## 汇编语言的组成

汇编语言由以下3类组成

* 汇编指令(机器码的助记符)

* 伪指令(由编译器执行)

* 其他符号(由编译器识别)

汇编语言的核心是汇编指令，它决定了汇编语言的特性。

## 存储器

CPU是计算机的核心部件，他控制整个计算机的运作并进行运算，要想让一个CPU工作就必须向它提供指令和数据。

指令和数据在存储器中存放，也就是平时所说的内存。

## 存储单元

存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号

## CPU对存储器的读写

CPU要想进行数据的读写，必须和外部器件(芯片)进行三类信息的交互

* 存储单元的地址
* 器件的选择，读写或命令
* 读或写的数据

在计算机中有专门连接CPU和其他芯片的导线，通常称为总线。

物理上：婴儿跟导线的集合

逻辑上划分：

* 地址总线
* 数据总线
* 控制总线

## 地址总线

CPU通过地址总线来指定存储单元。

地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。

## 数据总线

CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。

数据总线的宽度决定了CPU和外界的数据传送速度。

## 控制总线

CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。

有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。

所以控制总线的宽度决定了CPU对外部期间的控制能力。

## 内存地址空间

对CPU来说，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。

## 接口卡

CPU对外部设备不能直接控制，如显示器、音箱等。直接控制这些设备进行工作的是插在拓展插槽上的接口卡。

## 各类存储器芯片

从读写属性上看分为两类

* 随机存储器(RAM)
* 只读存储器(ROM)

从功能和连接上分类：

* 随机存储器(RAM)
* 装有BIOS的ROM
* 接口卡上的RAM

装有BIOS的ROM

BIOS：Basic Input/Output System，基本输入输出系统。

BIOS是由主板和各类接口卡(如：显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。

# 寄存器(CPU工作原理)

### CPU概述

一个典型的CPU由运算器、控制器和寄存器等器件组成，这些器件靠内部总线相连。

8086CPU有14个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。

### 通用寄存器

8086CPU所有的寄存器都是16位的，可以存放两个字节。

8086上一代CPU中的寄存器都是8位的

AX、BX、CX、DX通常用来存放一般性数据被称为通用寄存器。

为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。

* AX可以分为AH和AL

* BX可以分为BH和BL

* CX可以分为CH和CL

* DX可以分为DH和DL

### 字在寄存器中的存储

一个字可以存在一个16位寄存器中。

由于一个内存单元可以存放8位数据，CPU中的寄存器又可以存放n个8位数据。也就是说，计算机中的数据大多是由1~N个位数据构成的。

用十六进制来表示数据可以直观的看出这个数据是由哪些8位数据构成的，每两位对应一个八进制。

### 物理地址

CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。我们将这个唯一的地址成为物理地址。

### 16位结构的CPU

16位结构表述了一个CPU具有以下几个方面特征

* 运算器一次最多可以处理16位的数据
* 寄存器的最大宽度为16位
* 寄存器和运算器之间的通路是16位

### 8086CPU给出物理地址的方法

8086有20位地址总线，可传送20位地址，寻址能力为1M。

8086内部为16位结构，他只能传送16位的地址，表现出的寻址能力却只有64K。

8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。

* CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址
* 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
* 地址加法器将两个16地址合成一个20位的地址

$$
物理地址=段地址×16+偏移地址
$$

### 段

段的划分来自于CPU，由于8086CPU用“（段地址×16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。

* 一个段的起始地址一定是16的倍数
* 偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K。

偏移地址16位，变化范围为0~FFFFH，仅用偏移地址来寻址最多可寻64K个内存单元。

### 段寄存器

段寄存器就是提供段地址的。

8086CPU有4个段寄存器

* CS（code）
* DS（data）
* SS（stack）
* ES（extra）

当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。

### CS和IP

CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。

* CS为代码段寄存器
* IP为指令指针寄存器

工作过程

* 从CS：IP指向内存单元读取指令，读取的指令进入指令缓冲器
* IP=IP+所读取指令的长度，从而指向下一条指令
* 执行指令，转到步骤一，重复这个过程

在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H。

即在8086PC刚启动时，CPU从内存FFFF0H单元中读取指令执行。

FFFF0H单元中的指令是8086PC机开机后执行的第一条命令

### 修改CS、IP的指令

mov指令可以改变8086CPU大部分寄存器的值，被称为传送命令。

mov指令不能用于设置CS、IP的值。

8086CPU为CS、IP提供了另外的指令来改变他们的值：转移指令
$$
jmp\quad 段地址：偏移地址
$$
功能：用指令中给出的段地址修改CS，偏移地址修改IP

仅修改IP的内容
$$
jmp\quad ax
$$
功能：用寄存器中的值修改IP

### 代码段

对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。

可以将长度为N（N≤64KB）的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。

将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。

CPU只认被CS：IP指向的内存单元中的内容为指令。

所以要将CS：IP指向所定义的代码段中的第一条指令的首地址。

## Debug

win10默认已经移除了这个插件，我们需要手动安装。

准备工具

* DOSBox
* debug.exe

DOSBox可以在官方网站下载：*https://www.dosbox.com/*

可以直接在浏览器搜索debug.exe下载

在DOSBox的安装目录下，找到DOSBox 0.74 Options.bat，双击进入配置，拉到最下面，加入如下语句（MOUNT是挂载，C是参数，D:\Debug是debug.exe存放的文件夹路径）：

```java
MOUNT C D:\Debug//这里为debug.exe存放的文件夹路径
C:
debug
```

启动DOSBox.exe，在光标处输入dds：0，结果如下所示即安装配置成功：

![]({{site.baseurl}}/img/2020-07-29-debug.jpg)

* R命令查看、改变CPU寄存器的内容
* D命令查看内存中的内容
* E命令改写内存中的内容
* U命令将内存中的机器指令翻译成汇编指令
* T命令执行一条机器指令
* A命令以汇编指令的格式在内存中写入一条机器指令

# 寄存器（内存访问）

### 内存中字的存储

任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元。

### DS和[address]

8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。

我们要读取10000H单元的内容可以用如下程序段进行

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```

mov指令可以将一个内存单元中的内容送入一个寄存器。

8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器。

### 字的传送

8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，也就是一次性传送一个字。

### mov、add、sub指令

已学mov指令的几种形式

* mov 寄存器,数据
* mov 寄存器,寄存器
* mov 寄存器,内存单元
* mov 内存单元,寄存器
* mov 段寄存器,寄存器
* mov 寄存器,段寄存器

add和sub

* add/sub 寄存器,数据
* add/sub 寄存器,寄存器
* add/sub 寄存器,内存单元
* add/sub 内存单元,寄存器

### 数据段

我们可以将一组长度为N（N≤64K）、地址连续、起始地址为16倍数的内存单元当作专门储存数据的内存空间，从而定义了一个数据段。

将一段内存当作数据段，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

## 栈

现今的CPU中都有栈的设计。

8086CPU提供相关的指令来以栈的方式访问内存空间。

这意味着我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用。

入栈出栈指令

* PUSH
* POP

push ax：将寄存器ax中的数据送入栈中

pop ax：从栈顶取出数据送入ax

8086CPU的入栈和出栈操作都是以**字**为单位进行的。

8086CPU中，有两个寄存器

* 段寄存器SS 存放栈顶的段地址
* 寄存器SP 存放栈顶的偏移地址

任意时刻，SS：SP指向栈顶元素。

任意时刻，SS：SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素。所以SS：SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字节单元的偏移地址+2。

### 栈顶超界的问题

当栈满的时候再使用push指令入栈，栈空的时候再使用pop指令出栈，都将发生栈顶超界的问题。

8086CPU不保证对栈的操作不会超界。这就是说8086CPU只知道栈顶在何处（由SS：SP指示），而不知道程序员安排的栈空间有多大。

我们在比编程的时候要自己操心栈顶超界的问题。

### push、pop指令

* push 寄存器：将一个寄存器中的数据入栈

  pop 寄存器：出栈，用一个寄存器接收出栈的数据

* push 段寄存器：将一个段寄存器中的数据入栈

  pop 段寄存器：出栈，用一个段寄存器接收出栈的数据

* push 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）

  pop 内存单元：出栈，用一个内存字单元接收出栈的数据

  ```assembly
  push [0]
  ```

出栈的顺序和入站的顺序相反。

push和pop指令同mov指令不同，CPU执行mov指令只要一步操作，就是传送，而执行push、pop指令却需要两步操作。

栈顶的变化范围最大为

* 0~FFFFH

### 栈段

我们可以将长度为N（N≤64K）的一组地址连续、起始地址为16倍数的内存单元当作栈来使用，从而定义了一个栈段。

栈最底部字单元的地址为1000：FFFE，所以栈空时，SP=0000H。

栈顶的变化范围是0~FFFFH，从栈空的时候的SP=0，一直压栈，直到栈满时SP=0；如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。所以一个栈段的容量最大为64KB。

