---
layout: post
title:  Revery: From Proof-of-Concept to Exploitable
date:   2024-01-15 00:08:01 +0300
image:  2024-01-15-alphabet.jpg
tags:   [note,paper]
---

# 梦想:从概念验证到可以利用(向自动化漏洞利用生成迈进一步)

## 摘要

自动化生成漏洞利用是一个开放的挑战。现有的解决方案通常深入探索崩溃路径，即触发漏洞的概念验证(PoC)输入所采用的路径，并在路径上发现可利用状态时生成漏洞。

然而，可利用状态并不总是存在于崩溃路径中。

此外，现有的解决方案严重依赖于符号执行，在路径探索和漏洞生成方面缺乏可扩展性。此外，很少有解决方案可以利用基于堆的漏洞。

在本文中，我们提出了一种新的解决方案Revery，以在崩溃路径发散的路径中搜索可利用状态，并生成基于堆的控制流劫持漏洞。

它采用了三种新颖的技术:(1)利用布局-分配有向图来表征漏洞的内存布局及其贡献者指令;(2)一种面向布局的模糊解决方案，用于探索与崩溃路径具有相似内存布局的发散路径，以搜索更多的可利用状态并生成相应的发散输入;(3)将崩溃路径和发散路径拼接在一起的控制流拼接方案，合成既能触发漏洞又能触发可利用状态的EXP输入。

## 1.介绍

由于自动化漏洞发现解决方案(例如，模糊测试)的成功，在现实世界的应用程序中发现了越来越多的漏洞，以及概念验证(PoC)输入。例如，谷歌的OSS-Fuzz平台[31]采用了几个最先进的fuzzers来持续测试开源应用程序，并在5个月内发现了1000多个bug[4]。因此，越来越多的人力资源被用于评估漏洞，例如，确定根本原因并修复它们。因此，它要求解决方案自动评估脆弱性的严重性和优先级。

漏洞评估，特别是可利用性评估，对防御者和攻击者都很重要。攻击者可以隔离可利用的漏洞和编写漏洞来发起攻击。另一方面，防御者可以优先修复可利用的漏洞，并相应地分配资源。此外，防御者可以从漏洞中学习生成IDS(入侵检测系统)签名，以阻止未来的攻击。

评估漏洞的一种直接方法是分析崩溃点的程序状态，即导致程序崩溃或安全违规的指令，这些指令可能被杀毒程序(例如AddressSanitizer[32])捕获。例如，微软的可利用工具[3]检查崩溃点基本块中的所有指令，并搜索已知的可利用模式，例如，带有受污染目标的控制传输指令。**HCSIFTER[19]采取了额外的步骤来恢复被堆溢出损坏的数据，使程序能够在崩溃点之后执行更多的代码，从而提供更可靠的评估。然而，这些解决方案依赖于启发式来确定漏洞的可利用性，因此有时是不准确的。此外，他们不能提供利用输入来证明可利用性。**

**评估漏洞可利用性的最终方法是生成一个可用的漏洞，无论是由人还是由机器，例如，如Cyber Grand Challenge (CGC[16])所示。**Sean Heelan在他的论文中提出了一个原型[20]，使用动态分析和符号执行来生成经典缓冲区溢出漏洞的攻击。AEG[10]和Mayhem[15]提供端到端系统来发现漏洞，并在可能的情况下自动生成漏洞利用，分别针对源代码和二进制代码。**Q[29]和CRAX[22]可以为给定PoC输入的二进制文件生成漏洞利用**。

这些自动利用生成(AEG)解决方案共享类似的工作流程。**一般来说，他们会先利用动态分析方法对崩溃路径中的漏洞进行详细分析，然后在崩溃路径中搜索可利用状态，然后利用符号执行分别收集路径可达性约束、漏洞触发约束和漏洞构造约束，最后利用SMT(可满足模理论)求解器求解这些约束并生成漏洞输入**。然而，这些解决方案只能解决一小部分问题。例如，**在CGC中开发的机器只能解决Final Event中82个挑战项目中的26个**。

有几个挑战需要解决

挑战1:漏洞利用的衍生性问题。如[17,39]所述，**一旦内存损坏漏洞被触发，受害程序的状态机就会变成一个怪异的(状态)机。利用实际上是一个编程的过程，奇怪的机器执行意想不到的行为**。为了利用它，设置这个奇怪机器的初始状态是非常重要的。

然而，**PoC输入(例如，由fuzzers提供)可能会损坏一些数据并导致奇怪的机器进入不可利用的初始状态。例如，由于一些完整性检查，程序可能在崩溃点后不久退出。**因此，AEG解决方案不仅要在PoC输入所采取的崩溃路径中寻找可利用状态，还要在可选的发散路径中寻找可利用状态。这就是所谓的漏洞利用衍生性，是漏洞利用[39]的核心挑战之一。很少有AEG解决方案关注这一问题。

挑战2:符号执行瓶颈。**现有的解决方案严重依赖于符号执行来探索程序路径(例如，用于漏洞发现)，或者执行推理(例如，用于测试用例和漏洞生成)**。AEG[10]和Mayhem[15]利用符号执行来探索从漏洞点可到达的路径，并搜索可利用状态，能够缓解上述利用衍生性问题。然而，符号执行存在可伸缩性问题，并且在漏洞生成方面表现不佳。**首先，它在探索路径时面临路径爆炸问题，即使只分析一条路径也会消耗过多的资源。二是在将某些值具体化后，对某些可利用状态视而不见。例如，它必须具体化内存分配的符号参数和路径中内存访问操作的符号索引，以便对内存状态进行建模并能够探索后续子路径。但是具体化的值可能导致不可利用的内存状态。**

挑战3:利用基于堆的漏洞。很少有现有的解决方案能够对基于堆的漏洞产生利用。首先，堆管理函数太复杂，程序分析技术无法分析。例如，glibc库中的单个文件malloc有5000多行代码。其次，堆管理函数已经部署了几个完整性检查，可以在某些检查点检测堆损坏。

我们的解决方案。**在本文中，我们专注于基于堆的漏洞的可利用性评估，给定PoC输入。我们提出了一个框架Revery，能够在崩溃路径和发散路径中搜索可利用状态，并在可能的情况下生成工作于控制流劫持的漏洞。**

首先，对漏洞进行动态分析。与现有的AEG解决方案类似，Revery还在崩溃路径中收集一些运行时信息，**包括变量的污染属性**。此外，它还检查损坏的内存对象(表示为异常对象)，以及可用于定位异常对象的对象。此外，它从路径中检索布局-分配指令，这些指令创建这些对象并在它们之间建立点到关系。基于这些指令和对象，Revery创建了一个布局-分配有向图来描述漏洞的内存状态和贡献者。

然后，它搜索可选的发散路径来寻找可利用的状态。**Revery利用一种新颖的面向布局的模糊解决方案，而不是符号执行来探索发散路径**。类似于定向模糊[12]，Revery也驱动一个模糊器探索接近特定目标的路径，即崩溃路径。

然而，Revery并不旨在匹配精确的崩溃路径或在模糊测试期间触发漏洞。相反，它忽略了崩溃路径中的大多数指令，但旨在攻击前面提到的布局-分配指令，这可能会产生与漏洞类似的内存布局。因此，**模糊器可以探索许多不同的路径，并且有更好的机会找到可利用的状态，同时停留在易受攻击的内存状态。**

最后，Revery尝试合成新的EXP输入，以触发发散路径中的可利用状态和崩溃路径中的漏洞。它采用了一种新颖的控制流拼接方法，将发散路径和crash路径拼接在一起，然后利用轻量级的符号执行来生成EXP输入。

在某些情况下，Revery能够直接生成有效的漏洞。但由于存在复杂的防御机制，或者对动态的要求，这并不能保证开发过程中的决策，或其他超出本文范围的挑战。值得注意的是，即使在Revery无法生成有效漏洞的情况下，Revery也可以向专家提供EXP输入并帮助他们编写漏洞。

结果。我们基于二进制分析引擎angr[34]构建了Revery的原型，并在19个CTF (Capture the Flag)程序上对其进行了评估。它证明了Revery在触发可利用状态方面是有效的，并且可以为其中很大一部分生成有效的利用。更具体地说，**Revery可以为19个程序中的9个(47%)生成漏洞，而现有的开源AEG解决方案无法解决其中任何一个**。此外，它可能会触发另外5个(26%)的可利用状态。

总而言之，我们做出了以下贡献:

* 我们提出了一个自动化的解决方案，可以将PoC输入转换为EXP输入，这可能会触发漏洞并进入可利用状态。在某些情况下，它也可能直接产生有效的漏洞利用。
* 我们提出了一个布局-分配有向图数据结构，以表征漏洞的内存布局及其贡献者指令，从而实现许多与漏洞相关的分析。
* 我们提出了一种新的面向布局的模糊解决方案，在不需要符号执行的情况下，在发散路径中搜索可利用状态。
* 我们提出了一种新颖的控制流拼接解决方案，将崩溃路径和发散路径拼接在一起，并通过轻量级的符号执行合成EXP输入。
* 我们已经实现了一个Revery的原型，并证明了它在CTF项目中的有效性。

## 2.目的举例

在本节中，我们将说明自动化漏洞生成解决方案所面临的漏洞派生性问题，并通过图1中演示的运行示例展示我们的解决方案Revery的概述

### 2.1漏洞

如图1所示，在第10行有一个堆溢出漏洞。两个对象obj1和obj2具有相同的大小，而且很可能在堆中彼此相邻分配。如果满足第9行中的漏洞条件vul，则冗长的输入可能导致缓冲区obj1->data溢出。因此，该缓冲区后面的对象(例如obj2)将被损坏。

因此，第12行和第14行的语句将分别读取和写入损坏的内存地址。如果损坏的指针obj2->ptr指向无效(例如，不存在)的内存，这两条语句将导致崩溃。如果它指向有效内存，那么第12行的语句将正常执行(但会导致错误的返回值)，而第14行的语句将进一步破坏目标内存并导致任意地址写入(AAW)。

从利用的角度来看，第12行语句是不可利用的，除非返回值res影响调用函数中的控制流。但是第14行的语句触发了一个可利用状态。它导致AAW原语能够覆盖任意目标，包括在第15行调用的全局函数指针处理程序，因此可能导致第15行控制流劫持。

### 2.2利用的可行性

正如[39]中所讨论的，利用可衍生性是利用的核心挑战之一。更具体地说，给定漏洞的PoC输入，程序可能会变成一台奇怪的机器，但具有不可利用的初始状态。为了成功利用漏洞，我们必须在可选的发散路径中寻找可利用状态，并将怪异机器引导到可利用状态。

如运行中的示例所示，假设PoC输入证明在第10行存在漏洞(例如，由fuzzers提供)，它可以将字段obj2->status覆盖为非零，并将obj2->ptr覆盖为无效的内存地址，从而导致第12行崩溃。所以这个PoC会导致奇怪的机器进入一个不可利用的初始状态。成功的利用必须触发漏洞(在第10行)并进入可利用状态(例如，在第14行)。

为了简单起见，我们引入了几个术语:

* 崩溃路径:PoC输入所采用的路径，例如，示例中的路径9->10->11->12。

* 崩溃点:程序崩溃或安全违规被杀毒程序捕获的指令，例如第12行。

* 漏洞点:漏洞(即安全违规)发生的指令，例如示例中的第10行。崩溃路径可能有多个安全违规。第一个违规点记为漏洞点。

* 可利用点:可能导致成功利用的指令，例如示例中的第14行。可利用点导致可利用状态，在这种状态下，奇怪的机器可以正常工作。在实践中，任意地址读/写/执行指令(AAR/AAW/AAX)是典型的可利用点。

* 发散路径:可以找到可利用状态的路径，例如本例中的9->11->13->14。

* 劫持点:控制流可以被劫持的指令，例如示例中的第15行。它们是特殊的可利用点。在运行的示例中，它是一个二级可利用点，由第14行中的第一个可利用点引起。

* 利用路径:被成功利用的路径，例如:9->10->11->13->14->15。

* **拼接点:在发散路径和崩溃路径上的特殊指令，可以将它们拼接在一起生成开发路径，例如示例中的第11行和第13行。实际上，两个拼接点之间可能有许多子路径需要探索。**

值得注意的是，运行示例中的崩溃点(第12行)可以到达劫持点(第15行)，但它是不可利用的。如上所述，这个劫持点是第二级可利用点，由第14行中的可利用点构成。如果没有第14行的帮助，就无法利用第15行。

因此，为了成功地进行漏洞利用，我们必须跳出原始PoC的框框，在发散的路径中寻找可开发的状态。这是我们解决方案的直觉，也是“梦想”这个名字的由来。据我们所知，现有的AEG解决方案很少关注这种利用衍生性问题。

### 2.3我们的解决方案:Revery

我们提出了一种新的解决方案Revery，以解决利用衍生性问题并评估基于堆的漏洞的可利用性。在上层，Revery对漏洞进行详细分析，利用漏洞信息引导模糊器而不是符号执行，探索发散路径并搜索可利用状态，然后通过拼接崩溃路径和发散路径合成利用路径，最后生成触发漏洞和可利用状态的输入。如图2所示，它有三个主要组件。

2.3.1漏洞分析。Revery首先详细分析了漏洞，类似于现有的AEG解决方案。它使用动态分析来使用提供的PoC输入测试目标应用程序。**更具体地说，它跟踪每个指针和内存对象的状态，并在崩溃路径上捕获安全违规。**因此，它可以识别漏洞点，例如图1中的第10行。

更重要的是，它可以识别被漏洞破坏的异常对象，例如示例中的obj2。**Revery还识别异常对象的索引对象，这些索引对象可用于定位异常对象，例如示例中的全局变量gvar**。此外，**它从执行跟踪中检索布局-分配指令，这些指令创建异常和索引对象，并设置它们的指向关系，例如示例中的第7行**。这些对象和贡献者指令用于构造布局-分配有向图。

2.3.2发散路径探索。**Revery算法在发散路径中寻找可利用状态，解决可利用衍生性问题。它没有使用符号执行，而是使用模糊测试。**首先，它采用了一种新颖的面向布局的模糊解决方案来探索发散路径。为了促进漏洞的生成，只有与PoC输入相似的内存布局的发散路径才会被探索。因此，它驱动模糊器探索接近崩溃路径的路径，以类似于定向模糊解决方案[12]的方式。但是它没有使用完整的崩溃路径，而是使用前面提到的布局-分配指令作为模糊器的指导。因此，模糊器可以产生发散输入，以行使发散路径(例如，图中的9->11->3 ->4)具有适当的存储器布局。

然后，Revery在发散路径中搜索可利用的状态。**几种启发式方法用于识别可利用状态。**例如，如果内存存储操作的目的地由损坏的对象控制，例如，第14行，它是一个可利用状态。

此外，Revery还在这些发散路径中寻找劫持点。**劫持点有时并不明显。所以Revery用一些启发法来推断劫持点。**例如，图中的第15行是二级劫持点，如果第14行覆盖全局函数指针，则可以启用二级劫持点。

2.3.3 PoC拼接。一旦发现发散路径中的可利用状态(以及发散输入)，Revery将尝试合成一个新的输入来触发漏洞和可利用状态。**一般来说，它首先在崩溃路径(如第11行)和发散路径(如第13行)中找到拼接点，并进行一些具体的数据流分析。**

然后，利用轻量级的符号执行来探索这两个缝合点之间的潜在子路径(例如，11->13)，并将崩溃路径与发散路径缝合以合成利用路径(例如，9->10->11->13->14->15)，并最终生成用于行使利用路径的输入。部署了几个优化以使符号执行变得轻量级。

因此，Revery可以生成能够触发漏洞和可利用状态的EXP输入。它可以帮助专家快速生成有效的漏洞。在某些情况下，Revery能够直接生成漏洞。例如，Revery可以生成一个利用输入来劫持控制流，方法是利用第14行中的可利用状态来覆盖全局函数指针处理程序。

假设。我们假设受害程序部署在常规的现代操作系统中，启用了默认防御(例如，DEP[9]或glibc中的完整性检查)。除了ASLR[26]是禁用的，因为它需要额外的信息披露漏洞或利用，这是Revery目前不支持的。

## 3.漏洞分析

要利用漏洞，必须定位漏洞点和该漏洞点上的程序状态。此外，为了解决漏洞的可衍生性问题，需要在漏洞状态周围寻找可利用状态。因此，**Revery通过漏洞识别来定位漏洞，通过布局分析来表征漏洞状态**

### 3.1漏洞识别

给定PoC输入，Revery首先需要识别其相应的漏洞点。已经提出了数十种检测内存错误的解决方案，例如AddressSanitizer[32]和Valgrind[7]。然而，**AddressSanitizer和Valgrind会稍微改变目标应用程序的内存布局，因此不适合漏洞生成。**

Revery使用一种不同的技术，称为内存标记(MT，也称为内存着色、内存污染、锁和钥匙)来定位漏洞。**最近的一个工作[33]在硬件中实现了内存标记。但是，它对内存指针中的标签进行编码，从而影响程序状态。此外，它只检测空间记忆违规，而不检测时间违规。**

**Revery使用影子内存来非侵入性地跟踪指针和堆对象的标记**。它还跟踪堆对象的状态，不仅可以检测空间漏洞(例如，堆溢出)，还可以检测时间漏洞(例如，use-after-free)。

**原则上，每个指针都应该访问一个具有有效状态的特定内存对象。如果在运行时使用它来访问不同标记或无效状态的对象，则会捕获安全违规。**图3显示了一个漏洞识别的示例。

3.1.1内存标签。每个堆对象和指针都附带一个内存标记，指示其沿袭。该标记将在创建对象时唯一地生成，并作为污点标签(污点分析)传播到对象的指针和其他相关指针。此外，每个堆对象都与一个状态相关联，即未初始化、繁忙或空闲，在其生命周期中代表三种状态，即已分配但未初始化、已初始化并正在使用或已释放。值得注意的是，释放的内存区域可以分配给新对象，其内存状态和标记也会相应改变。

在某些极端情况下，开发人员可以使用一个对象的指针，通过算术运算来获取另一个对象的指针。它会错误地将第一个对象的标记传播到第二个指针。幸运的是，这对于堆对象来说很少见，因为堆对象之间的偏移量不是固定的。唯一的例外是堆管理函数，它可以用这种方式检查相邻的对象，而不管这些对象具有什么语义。因此，Revery将禁用这些特殊功能的标记传播和验证。值得注意的是，此优化仅适用于跨对象指针派生。Revery正常支持对象内指针驱动。

3.1.2安全规则。对于每个堆内存访问指令(即加载和存储)，我们可以获得指针的标记tag_ptr和目标内存区域的标记tag_obj和状态status_obj。内存访问不能违反以下安全规则:

* **V1:访问目的对象:指令应该只访问目的对象，即tag_obj和tag_ptr必须匹配。**

* **V2:读取繁忙对象:加载指令不应该访问释放或未初始化的内存，即status_obj必须是繁忙的。**

* **V3:写存活对象:存储指令不应该访问被释放的内存，也就是说，status_obj必须是繁忙或未初始化的。**

**任何违反这些规则的行为都将导致漏洞。例如，缓冲区溢出内存访问将违反规则V1。未初始化的变量漏洞将违反规则V2。释放后使用(UAF)漏洞可能违反规则V1、V2或V3。如果被释放对象的内存没有被其他对象占用，那么对它的读访问将违反V2，对它的写访问将违反V3。如果被释放对象的内存被占用，那么它的标记就会改变，任何通过原始悬浮指针对它的访问都将违反规则V1。**

### 3.2布局分析

Revery进一步分析对象布局，以表征漏洞状态，并检索导致该状态的指令。

3.2.1漏洞相关对象布局。每个基于堆的漏洞(包括堆溢出和UAF)都与一个异常对象相关，异常对象的内容被漏洞破坏(或将被漏洞破坏)。对这些对象的进一步操作可能会导致这台奇怪的机器进入可利用状态。

假设漏洞点使用标记为tag_ptr的指针访问标记为tag_obj的目标对象。如果是写访问，那么标记为tag_obj的对象就是异常对象，它将被这种写访问破坏。如果它是读访问，并且此漏洞是UAF，则标记为tag_ptr的对象是异常对象，它将被占用相同内存的新对象分配破坏。Revery目前不支持其他类型的读访问冲突。

此外，Revery还跟踪所有可用于定位异常对象的索引对象。这些异常对象和索引对象通过点到关系连接。因此，Revery可以得到对象的有向图，表示为布局有向图。该布局图在一定程度上表征了漏洞状态。图4(b)显示了一个示例布局有向图。

3.2.2漏洞相关代码。如前所述，怪异的机器必须进入特定的初始状态，包括漏洞状态。因此，有必要准备一个与漏洞相似的对象布局，无论是发散路径还是利用路径。因此，有助于布局的指令是重要的。

我们可以看到，以下两种类型的操作可以分配对象布局:(1)创建新对象的内存分配，以及(2)使用指针将对象的字段分配给另一个对象的存储操作。因此，Revery可以检索所有这些对布局有向图中的对象进行操作的贡献者操作，并生成一个布局有向图。

更具体地说，这个有向图中的每个节点都是一个异常对象或索引对象，具有对象的创建者指令和内存标记的属性。有向图中的每条边表示两个对象之间的点对关系，具有指针赋值指令的属性。**给定一个目标异常对象，我们可以使用向后切片来构造这个有向图**。图4(c)显示了一个示例布局-分配有向图。这个有向图有一个更简单的形式，称为布局-分配切片，它是按执行顺序排列的贡献者指令序列

## 4.发散路径探索

为了解决漏洞利用衍生性问题，需要对发散路径进行探索，并在发散路径中搜索可利用状态。在本节中，我们将介绍Revery如何探索不同的路径。

### 4.1可选方案

现有的自动化漏洞生成方案，如AEG[10]和Mayhem[15]，严重依赖于符号执行来探索从漏洞点开始的崩溃路径或可达路径，以便沿着路径探索搜索可利用状态。然而，符号执行有几个严峻的挑战，不适合路径探索或可利用状态搜索。

首先，它在路径探索中是不可伸缩的。它遭受由程序中的分支和循环引起的路径爆炸问题。即使分析一条路径，也会耗费太多资源。此外，符号约束通常太复杂而无法解决。

第二，符号执行可能对某些可利用状态视而不见。它必须在探索过程中，通过增加具体值赋值的额外约束，将一些符号值具体化。不可能尝试所有候选的具体化值，从而错过某些值并导致对某些可利用状态的盲目。

例如，它将具体化路径中内存分配的符号参数，以便对内存状态进行建模并探索后续子路径。很可能只有少量的分配会导致可利用状态。因此，具体化的内存分配可能导致不可利用状态。

此外，它还将在内存访问操作中具体化符号索引，否则操作的结果是未知的。同样，它也可能导致不可利用的状态。

**另一种选择是结合模糊和符号执行来探索路径，例如，Driller[37]。然而，这种解决方案的符号执行组件仍然存在上述挑战。此外，模糊组件通常缺乏目标，因此不能有效地发现可利用状态。**

### 4.2面向布局的模糊测试

Revery只利用模糊测试来探索不同的路径并搜索可利用的状态。正如漏洞发现所示，在探索路径和程序状态方面，模糊测试比符号执行更有效。因此，模糊测试也可能有助于更快地找到发散路径和可利用状态。

Revery采用了一种由layout-contributor有向图引导的新颖的面向布局的模糊解决方案，以探索构建与漏洞相似的内存布局的不同路径。

4.2.1设计准备。Revery扩展了流行的覆盖制导模糊仪AFL来执行模糊测试。Revery没有仅仅依靠代码覆盖率来指导路径探索，而是使用layout-contributor有向图作为调整探索和突变方向的指导。

类似于定向模糊[12]， Revery驱动模糊器探索接近崩溃路径的路径。它只针对匹配布局-分配者片中的指令，而忽略崩溃路径中的其他指令。设计选择基于以下三种直觉。

为简单起见，我们引入几个术语。给定一个输入Ia，它可能会碰到几个布局-分配者指令(可能与引导片的顺序不同)。将这些指令的完整列表记为La，其包含目标引导片的最长公共子序列LCS记为Pa。

* 直觉1:以与引导切片相同的顺序命中所有布局-分配者指令的输入可以构建与漏洞相似的内存布局。

  Layout-contributor指令负责创建漏洞的异常对象及其索引对象，以及设置它们之间的指向关系。因此，命中完整布局-分配者切片的输入可能会构造类似的内存布局。

* 直觉2:命中引导切片较长的子序列的输入更有可能派生出命中完整切片的输入。

  换句话说，如果输入Ia的LCS Pa比Ib的LCS Pb长，则输入Ia优于Ib。如图5所示，假设目标片在路径a=>c=>e=>f中，那么执行路径a=>c=>d的输入比执行路径a=>b的输入更好。该输入的进一步突变可能会使输入更快地击中完整的引导切片。

* 直觉3:输入命中更少的布局贡献者指令更有可能为进一步的漏洞生成带来更少的麻烦。

  换句话说，对于Ia和Ib两个输入，如果它们的LCS Pa和Pb长度相同，但布局-分配指令列表La比Lb长，则输入Ib优于Ia。在这种情况下，输入Ia比Ib有更多重复或乱序的分配者指令，这可能导致冗余的对象创建或布局构建，使内存布局过于复杂而无法利用

4.2.2实现细节。Revery扩展了流行的fuzzer AFL[41]。如图6所示，AFL应用连续循环来探索路径。它(1)保持一个好的测试用例队列，即种子;(2)从队列中选择种子;然后(3)改变种子以获得一堆新的测试用例，然后(4)在QEMU中使用生成的测试用例运行目标二进制程序并跟踪覆盖率，然后(5)根据覆盖率信息识别种子。Revery对AFL进行了以下两个方面的修改：

* 跟踪切片命中计数。除了用于代码覆盖跟踪的现有位图之外，**Revery还在QEMU和fuzzer驱动程序之间**的共享内存中添加了一个额外的缓冲区HIT。HIT[0]用于跟踪切片命中的计数，HIT[i]用于跟踪引导切片中的第i条指令是否被命中。

  更具体地说，每次执行布局贡献者指令时，QEMU将增加片命中计数hit[0]。如果该指令是引导片中的第n条(n>=1)指令，则当且仅当HIT[n-1]已经设置时，QEMU才会设置HIT[n]。这样，模糊器驱动程序可以得到hit中的片命中数[0]，以及hit中引导片的LCS [1:N]。

* 调整模糊方向。Revery修改模糊器驱动程序以利用收集到的切片命中信息。基本上，它稍微改变了种子选择的算法。当从队列中取出一个种子进行突变时，它首先优先考虑LCS较长的种子，如直觉2中所述。然后，在LCS长度相同的种子中，它优先考虑切片命中次数较少的种子，如Intuition 3所示。最后，与AFL的默认策略相同，它优先考虑大小更小、执行时间更快的种子。

### 4.3发散输入过滤

使用面向布局的模糊测试，Revery可以找到能够触发与PoC输入相同的布局贡献者切片的发散输入。**然而，与layout-contributor有向图不同的是，在layout-contributor切片中缺少数据流约束。因此，发散的输入有时与从崩溃路径构建的目标布局-分配有向图不匹配。因此，Revery需要额外的步骤来隔离可能匹配目标布局-分配有向图的发散输入。**

一般来说，它首先将发散路径与崩溃路径对齐，然后定位负责创建异常对象的指令。然后，采用与崩溃路径相同的方法，通过反向切片，从发散路径中构造异常对象的新的布局贡献者有向图。最后，它通过比较每个节点的内存标记及其创建者指令在两个有向图中的地址，将这个新有向图与目标有向图进行匹配。图7显示了匹配如何工作的示例。

如果这两个有向图不匹配，那么这个发散的输入将被丢弃。否则，发散输入保持不变。因此，这两个有向图的节点(即堆对象)将相应地对齐，以及所有节点的内存标记。因此，我们可以在发散路径和崩溃路径之间推断每个对象的对应对象，从而对这两条路径进行进一步的公共分析。

### 4.4可利用状态搜索

即使分叉路径具有与漏洞相似的布局，也不是所有路径都是可利用的。Revery进一步删除了不具有可利用状态的发散路径。

4.4.1可利用状态。异常对象可能会影响其他对象，有时会直接或间接地用于某些敏感操作。由这些敏感操作产生的程序状态被表示为可利用状态。

在本文中，我们主要考虑两种类型的敏感(可利用)操作，即内存写入和间接调用。例如，如果内存写入的目标地址受到异常对象的影响，那么攻击者可能会控制写入的位置并导致AAW(任意地址写入)，即在实践中常用的可利用状态。如果攻击者能够影响间接调用的目标，包括虚函数调用和间接jmp指令等，那么他们就可以劫持控制流。此外，Revery为专家提供了一个模板来扩展可利用点的定义，例如，发起unlink攻击的操作。

4.4.2可利用状态搜索。因此，这个问题变成了识别操作数受异常对象影响的敏感指令。污点分析是一个简单的解决方案。

Revery将每个对象创建操作标记为污染源，并为其附加唯一的污染标签。每个操作将所有源操作数的污染标签传播到目标。在每个敏感指令(即，内存写入或函数调用)，目标地址的污染标签将被检查，如果它们包含异常对象的污染标签。如果是，那么这个敏感指令是可利用的。

## 5.利用合成

在本节中，我们将介绍如何从PoC输入和发散输入合成新的漏洞利用。

一旦在路径中发现可利用状态，现有的AEG解决方案通常通过求解路径、漏洞和利用约束来生成利用。然而，正如第4.1节所讨论的，仅仅符号执行在漏洞生成中是无效的。

因此，Revery尽可能少地使用符号执行。它使用轻量级的符号执行作为将崩溃路径和发散路径连接在一起的纽带，并重用PoC输入和发散输入以进一步减少复杂的约束，使符号执行更加实用。

图8显示了漏洞利用合成的一般工作流程。在实际应用中，该算法首先识别拼接点，然后探索拼接点之间的子路径并综合利用路径，最后求解相关约束生成工作漏洞。

### 5.1确定缝合点

我们首先介绍Revery如何在崩溃路径和发散路径中识别拼接点。

5.1.1崩溃路径中的拼接点。为了成功利用受害程序，必须首先触发其漏洞，并且损坏一些异常对象。因此，Revery选择在崩溃路径中异常对象损坏的位置作为拼接点。

如3.2.1节所述，在崩溃路径中，每个写访问冲突都会破坏一个异常对象，因此它是一个候选拼接点。对于UAF漏洞中的每个读访问违反，异常对象是已被释放但仍由悬浮指针指向的对象。这个异常对象的内存区域将被另一个内存分配占用。Revery将新的内存分配操作作为候选拼接点。

由于在一条碰撞路径中可能存在多个违规，因此也可能存在多个拼接点。Revery将尝试用发散路径缝合它们中的每一个。

5.1.2在发散路径上的拼接点。为了成功地利用受害程序，必须对损坏的异常对象或附属对象执行可利用的操作。

什么是好的缝合点?每条指令都可以作为拼接点。但并不是所有的都是好的。一个合适的缝合点应该满足几个标准:

* 不要太靠近入口点。否则，将执行许多作为崩溃路径的重复操作。由于重复的操作(例如，对象初始化)不会在合法的控制流中发生，因此不可能找到一条路径将这个拼接点与崩溃路径中的对应点连接起来。

* 不要太靠近可利用点。否则，需要更长的路径来连接这个拼接点和它的对应点，需要更多的符号执行的努力。拼接点可以在某些操作之前设置，例如，可利用点的操作数的初始化，以节省符号执行的努力。

* 最小的数据依赖。发散路径中拼接点之后的数据流与碰撞路径中拼接点之前的数据流交集较少。

如何找到针点?在较高的级别上，Revery将发散路径的数据依赖与崩溃路径的数据依赖进行匹配，并定位差异。然后将引起发散路径差异的指令作为拼接点。

首先，Revery在发散路径中构建可利用操作的操作数的布局-分配有向图。然后，它将这个有向图与崩溃路径中异常对象的有向图进行匹配。如果前者是后者的子图，则意味着崩溃路径已经为可利用操作设置了所有数据依赖关系。然后，发散路径中的指令，它位于对可利用操作的操作数的最后一次写访问之后，被选为缝合点。

否则，发散路径的有向图中存在不同的节点或边，即发散路径改变了可利用操作的依赖关系。在这种情况下，Revery选择发散路径中最早产生有向图差异的指令(对象创建或写入)作为拼接点。

### 5.2控制流路径拼接

为了将崩溃路径和发散路径缝合在一起，Revery探索了连接这些路径中缝合点的潜在子路径。一般来说，它依赖于符号执行来探索路径。然而，Revery利用几种启发式方法来有效地指导符号执行。

首先，Revery使用函数调用堆栈来指导路径探索。它分别检查两个拼接点的调用堆栈，并找出差异。图9显示了两个示例调用堆栈。调用堆栈中的这些差异指示了路径探索的方向。崩溃路径中的函数调用(例如图中的，g1, g2，…，gM)应先逐一返回，而发散路径上的函数调用(如图中的h1, h2，…，hk )会被依次调用。

也就是说，在探索潜在路径时，Revery会依次添加函数gM，…， g2, g1函数的返回指令作为目标指令，然后添加函数h1, h2，…，hk为目标指令，逐一指示。这些目标指令是两个拼接点之间的支配点。然后Revery将探索这些中间目标指令之间的潜在子路径。

Revery通过重用现有路径进一步减轻了子路径探索。例如，如果在发散路径或崩溃路径中已经有一条连接两个中间目的地的子路径，Revery将重用该子路径。Revery还执行了一个简单的循环识别算法，并尽快找到一个子路径来逃离循环，以减少符号执行的负担。有时，重用的子路径会导致整个路径无法解决，Revery将尝试删除这些子路径并搜索替代子路径。

这样，在探索连接拼接点的子路径时，极大地减少了符号执行的负担

### 5.3漏洞利用生成

一旦找到连接两个拼接点的子路径，就构造一个候选开发路径。Revery还可以求解漏洞约束、路径约束和攻击约束，生成最终的攻击样本。然而，这是不够的。

5.3.1可利用状态约束。简单地求解漏洞利用路径的约束可能不会触发与发散路径相同的漏洞利用状态。因此，Revery向利用路径添加了几个额外的数据约束，以确保程序状态仍然是可利用的。

首先，利用路径中的内存分配大小应与发散路径中相同，以便触发发散路径中的可利用状态。Revery在分析发散路径时记录所有内存分配的具体大小。在利用路径中，如果发散路径中的内存分配具有符号大小，则Revery将添加约束以确保该大小等于发散路径中的具体值。

其次，Revery会将崩溃路径的有向图与发散路径的有向图对齐。发散路径中的某些符号地址在逻辑上与崩溃路径中的对应地址相同。因此，在缝合利用路径中，必须引入额外的约束来声明这些符号地址之间的相等性。

5.3.2payload约束。有了前面提到的可利用状态约束，再加上漏洞和路径约束，Revery就能够生成EXP输入来触发可利用状态和漏洞。这些输入可以帮助安全专家构建一个完整的漏洞。

在某些情况下，Revery能够直接生成有效的漏洞。在可利用点，Revery可以构造有效payload约束，这可能导致控制流劫持。如果可利用点是一个函数调用(例如，间接调用或jmp指令)，并且它的目标是一个符号值，Revery添加一个额外的约束来将目标设置为攻击者控制的值。如果可利用状态是写访问，并且目标地址和要写的内容都是象征性的，那么Revery会增加一个额外的约束，用攻击者控制的值覆盖已知地址(例如，全局偏移表项或全局函数指针)。

通过这种方式，Revery可以在某些情况下生成劫持控制流的漏洞。然而，它并不总是保证成功。

## 6.评价

我们基于二进制分析引擎angr[34]和流行的fuzzer AFL[41]实现了一个Revery的原型。其中1334行代码用于分析漏洞，190行代码用于模糊探测发散路径，1249行代码用于缝合路径并生成漏洞。

在本节中，我们给出了该系统的评估结果。实验在Ubuntu 17.04系统上进行，该系统运行在115G RAM和Intel Xeon (R) CPU E5-2620 @ 2.40GHz*24的服务器上。我们将Revery与从15个CTF(夺旗)竞赛中收集的19个脆弱程序进行了评估，其中14个可以在CTFTIME[1]中找到。

为了彻底评估Revery的有效性，我们根据以下规则从CTF事件中选择目标程序:**(1)这些程序不存在源代码或调试符号;**（2）每个程序必须至少有一个基于堆的漏洞;(3)漏洞类型的多样性必须较大;(4)源CTF事件的质量得到了很好的认可。

所有程序都在常规的现代Linux操作系统(Ubuntu 17.04)中进行了测试，并启用了DEP[9]防御。与传统环境不同，我们在评估中禁用了ASLR[26]。在实践中，需要信息披露漏洞或利用来绕过ASLR。目前的“Revery”原型还不能生成信息泄露漏洞。

### 6.1Revery的利用

表1显示了我们评估的程序列表。在19个程序中，Revery成功地利用了其中的9个，也就是说，能够劫持它们的控制流。Revery可以触发另外5个程序的可利用状态，也就是说，为专家提供了成功发动攻击的攻击原语。它未能分析其余5个程序。稍后将讨论更多细节。

该表还详细显示了每个程序的名称和CTF事件。它显示了每个程序中已知漏洞的类型，包括堆溢出、off-by-one、UAF和double free。此外，它还显示了每个漏洞的崩溃类型，即将PoC输入应用于易受攻击的程序的结果。其中一些是由内存管理器的完整性检查捕获的(在表中表示为堆错误)，其他一些是由于无效的内存读取指令而崩溃的。其中大多数甚至不会崩溃。

此外，它还显示了Revery检测到的每个漏洞的违反类型，Revery触发的最终可利用状态，以及Revery是否可以生成漏洞。Revery可以在19个程序中的16个中检测到安全违规。它可以分别触发3个、6个和5个程序的EIP劫持、任意内存写入和断开链接攻击的可利用状态。Revery可以为前两种可利用状态生成有效的漏洞利用。

此外，它还显示了Revery检测到的每个漏洞的违反类型，Revery触发的最终可利用状态，以及Revery是否可以生成漏洞。Revery可以在19个程序中的16个中检测到安全违规。它可以分别触发3个、6个和5个程序的EIP劫持、任意内存写入和unlink攻击的可利用状态。Revery可以为前两种可利用状态生成有效的漏洞利用。

作为比较，我们还评估了由Shellphish团队提供的开源AEG解决方案Rex[5]和这些程序上的GDB中可利用的插件。如表的最后两列所示，Rex无法解决这些程序中的任何一个，而GDB可利用性只是根据崩溃类型评估可利用性。

### 6.2案例研究

在本节中，我们详细调查了这些程序，并分析了我们的解决方案Revery成功或失败的原因。

6.2.1控制流劫持漏洞。Revery成功地生成了9个程序的控制流劫持漏洞。对于给定的PoC输入，有2个程序破坏堆元数据，并被部署在glibc内存分配器中的完整性检查捕获。另外三个程序因无效的内存读取指令而崩溃，其结果仅由printf等函数转储，这不会导致控制流劫持。其余4个程序甚至不会因提供的PoC而崩溃。

最先进AEG解决方案的极限。可利用性评估工具通常认为这些漏洞是不可利用的。为了成功地利用这些漏洞，我们必须避免被完整性检查捕获的元数据损坏，并在使用符号执行时准确地为内存分配器建模。

因此，最先进的AEG解决方案无法自动为它们生成漏洞。我们用Rex[5]测试了所有这些程序，**Rex[5]是由Shellphish团队开发的自动漏洞生成工具，该团队在CGC中获得了攻击第一名**。但它没有为它们中的任何一个生成漏洞。

Revery的表现。通过探索不同路径中的可利用状态，Revery可以为所有9个程序生成漏洞。例如，WoO2和WoO_fixed会崩溃，因为一个对象被释放两次。为了利用这种漏洞，我们需要堆风水[35]，这对于自动化解决方案来说太复杂了。相反，Revery会回到漏洞点，并找到一条可能导致EIP劫持的发散路径。

**其中三种可利用状态可以劫持程序计数器，另外六种可能导致任意地址写入(AAW)。AAW是一种众所周知的攻击原语，可以实现许多攻击。例如，它可以用来修改全局偏移表(GOT)和劫持控制流。**

6.2.2可利用状态。有时Revery不能生成有效的漏洞，即使它已经找到了可利用的状态并缝合了一个利用路径。如表所示，Revery可以触发可利用状态，但无法为5个程序生成有效的利用。

对于这些程序，在异常对象中没有关键数据字段(例如，函数指针，VTable指针等)，并且自动生成针对它们的漏洞是极具挑战性的。相反，我们必须利用异常对象中损坏的元数据来利用特定的堆分配器。

Revery利用面向布局的模糊测试来找到一条发散路径，从而释放异常对象，并触发一个可利用状态。假定glibc库使用双链表来维护对象，从该链表中取消一个节点的链接(由于某些内存操作)将更新向前和向后节点的指针，从而导致意外的内存写操作。这就是所谓的unlink攻击[6]。

然而，**要成功地利用这种状态，我们必须安排堆布局，使用堆风水等技术，这超出了本文的范围。然而，使用Revery生成的输入，专家可以手动修改堆布局并更快地编写漏洞利用程序。**

6.2.3失败案例。如前所述，Revery不能保证生成有效的漏洞利用或触发可利用状态。在我们的实验中，Revery有5个程序失败了。

漏洞检测的局限性。**对于某些程序，Revery无法检测到安全违规。例如，挑战SimpleMemoPad在对象内部有缓冲区溢出，也就是说，它将破坏邻居数据字段而不是邻居对象。Revery目前只支持对象级别的损坏检测。我们把它作为支持对象内缓冲区溢出检测的未来工作。**

Angr的局限性。我们的解决方案Revery依赖于angr[34]来执行符号执行。**Angr自己模拟所有的系统调用，它还没有完全实现。或者，angr重写Python中的库函数，并钩住原始函数。然而，这还远远没有结束。因此，angr不能支持大多数现实世界的程序。这也是我们只在CTF项目上评估Revery的主要原因。**

例如，要成功攻击childheap，就需要fgets函数的一些特殊特性。这个函数是由angr挂钩的，但所需的功能没有得到正确实现。所以Revery无法找到利用这个漏洞的方法

### 6.3面向布局模糊检测的效率

我们进一步从发散路径探索和可利用状态搜索两方面评估了Revery算法的效率。我们将我们的面向布局的模糊与原始的模糊器AFL进行了比较。为了公平地评估面向布局的模糊测试的效率，我们同时运行Revery和AFL，并使用Revery中相同的可利用状态搜索模块来评估两个模糊测试器生成的测试用例。

图10显示了Revery和AFL查找第一个输入以命中layout-contributor切片中的所有指令所使用的时间间隔。平均而言，Revery比AFL快122%。

Revery也比AFL花更少的时间在发散路径中找到一个可利用的状态。如图11所示，AFL在8小时内未能找到3个程序的可利用状态。相比之下，Revery发现了所有程序的可利用状态。对于AFL和Revery都成功的项目，Revery比AFL平均快247%。

简而言之，通过面向布局的模糊测试，Revery可以比AFL更快地找到发散路径和可利用状态。

我们还比较了面向布局的模糊与Driller[37]。结果表明，Driller在4小时内没有发现所有程序的可利用状态。并且只在一个程序(即note1)中调用了Driller的符号执行引擎。**这可能是因为driller是为CGC程序设计的，对于ELF二进制文件有一些错误。**

### 6.4控制流拼接的效率

给定候选可利用状态，Revery利用一种新颖的控制流拼接解决方案来生成输入，以触发漏洞和可利用状态。理论上，符号执行只能用于探索从漏洞点到可利用状态的路径。为了比较它们之间的效率，我们因此评估了Revery和基于angr的strawman符号执行工具SYMBEX。

6.4.1总体结果。表2显示了angr能够处理的14个程序的评估结果。Revery可以生成EXP输入，在几分钟内触发所有14个程序的可利用状态。但SYMBEX只能解决其中的4个问题。这4个程序的可利用点都在漏洞点之后，崩溃点之前，因此不需要探索路径。SYMBEX在4小时内未能解决程序main，其余9个程序也失败了。

路径复用率。我们用路径复用率来评价Revery找到的拼接点的质量。该复用率是根据从发散路径中重用的基本区块的计数与利用路径中基本区块的计数进行计算的。较高的重用率表明该拼接点更适合于漏洞生成。如表所示，超过一半的程序的路径重用率高于60%。

失效分析。SYMBEX有9个程序失败。指出传统的符号执行无法推断出某些可利用状态约束，因此无法生成漏洞。正如第5节所讨论的，Revery可以从发散路径中推断出这些约束。下面，我们以babyheap和marimo两个程序为例。

```assembly
i = get_int_from_user()
team = team_list[i];
if(team) manage_team(team);
```

例1:babyheap。如清单1所示，目标可利用状态位于函数manage_team中，只有在参数team不为NULL时才会触发。但是这个值被使用来自数组team_list的符号化的索引检索到。

例2:marimo。图12说明了marimo的漏洞。在marimo-0对象中存在溢出，这会破坏对象marimo-1。当且仅当对象marimo-1被传递给edit_marimo函数时，可以触发可利用状态。然而，angr并不知道这些知识，而是从求解器中获得一个随机值。

另一方面，Revery从崩溃路径中了解到这些知识，并添加了可利用状态的额外约束。所以它可以成功地生成漏洞。

## 7.相关工作

### 7.1自动生成漏洞

Revery的目标是自动生成漏洞，这仍然是一个开放的挑战。已经提出了一些解决方案。

7.1.1基于符号执行的AEG。APEG[14]是第一个基于补丁分析的自动化开发解决方案。AEG[11]开发了一种新的预置符号执行和路径优先级技术，以在源代码级别生成漏洞。基于混合符号执行和内存索引建模技术构建的Mayhem[15]可以在二进制级别自动生成漏洞。

这些解决方案象征性地执行整个程序，并且在路径探索中不可扩展。与Revery不同，它们不知道可利用的状态约束。以前的AEG解决方案(如[11])无法解决可衍生性问题。它们通常只支持堆栈溢出(其中可利用点是崩溃点)和格式字符串(其中可利用点是漏洞点)漏洞，而不是基于堆的漏洞。由于可利用点在崩溃路径中，这些解不探索发散路径。

此外，他们将符号价值具体化，使符号执行具有具体性。例如，Mayhem提出了一个优先化的解决方案。如上所述，具体化可能导致不可利用的状态。

7.1.2基于崩溃分析的AEG。Sean Heelan[20]利用动态污染分析和程序验证来生成基于崩溃PoC输入的控制流劫持漏洞。类似地，从崩溃点开始，CRAX[22]**象征性**地执行程序以查找可利用状态，并在二进制级别自动生成可用的漏洞。

**这些解决方案只在崩溃路径中搜索可利用状态。如前所述，可利用状态并不总是存在于崩溃路径中**。因此，他们将受到开发可衍生性问题的阻碍。相比之下，Revery不仅在崩溃路径中探索可利用状态，还在分叉路径中探索可利用状态。

7.1.3面向数据的AEG。FLOWSTITCH[21]通过拼接多个数据流而不破坏控制流，自动生成面向数据的漏洞，能够达到信息泄露和特权升级。

虽然它也使用拼接，但它与Revery有很大不同。首先，它的目标是数据流拼接，而控制流是完整的，使符号执行更容易。其次，它只产生数据攻击的漏洞，而不是控制流劫持攻击。

7.1.4其他AEG解决方案。FUZE[40]是一个简化内核UAF开发过程的新框架。FUSE利用模糊测试来找到悬空指针的不同解引用位置。相比之下，Revery利用面向布局的模糊来探索发散路径并在其中搜索可利用的状态。

Ardilla b[23]和Chainsaw[8]是面向web应用的AEG解决方案。Ardilla可以自动创建SQL注入和跨站点脚本(XSS)攻击。Chainsaw是一个系统地对导航结构进行推理，并利用web应用程序的数据库状态自动生成工作漏洞的系统。它们与二进制应用程序(包括very)的AEG有很大不同。

### 7.2定向模糊测试

Revery利用模糊测试来探索不同的路径。近年来这一领域取得了许多进展。

7.2.1覆盖率引导的模糊测试。有许多工作旨在增加模糊测试的代码覆盖率，称为覆盖率引导的模糊测试。AFL [41]， libFuzzer [30]， honggfuzzer [38]， AFLFast [13]， VUzzer[27]和CollAFL[18]是一些最先进的覆盖率引导的模糊测试器。一般来说，他们优先考虑具有较高代码覆盖率的种子，以便进一步突变。**然而，它们不针对特定的代码或内存状态，因此在探索必须满足某些要求的发散路径时效率不高。**

7.2.2目标导向的模糊测试。与我们的重点最相似的工作是AFLGo[12]，一个灰盒模糊工具。AFLGo[12]优先考虑离预定目标代码更近的种子，从而实现有效的定向模糊测试。在我们的解决方案中，我们感兴趣的是能够触发多个布局-分配指令的种子，而不是一条指令。对于具有多个目标点的发散路径，AFLGo的搜索效果不佳。Revery引导具有布局-分配切片的模糊器有效地探索发散路径并搜索可开发状态

## 7.3漏洞检测

Revery利用内存标记来检测安全违规。为此提出了许多解决方案[2,28,32,36]。例如，ASAN[32]将对象设置为红区，并将释放的对象放入隔离区，从而能够检测到空间和时间违规。Valgrind[7]用自修改的实现替换堆管理函数，这些实现也使用红区来检测内存安全违规。SoftBound[24]将每个指针的基和绑定信息记录为不连接的元数据，以强制C程序的完全空间内存安全。CETS[25]对不相交的元数据空间中的每个指针使用一个key和lock地址，并检查指针的解引用，以加强C程序的临时安全性。

所有这些解决方案都会稍微改变目标程序的内存布局，因此不适合生成漏洞。相比之下，Revery利用影子内存非侵入性地跟踪指针的标记和堆对象的状态。

## 8.讨论

AEG是一个公开的挑战。Revery只向这个目标迈进了一步。它有许多挑战，包括但不限于:

* 先进防御。越来越多的防御措施被提出并部署在实践中，以阻止流行的攻击。这些防御措施不仅提高了人类攻击者的门槛，而且还阻碍了自动化解决方案。例如，**Revery无法绕过ASLR，因为它缺乏信息披露的能力。**它可以触发19个程序中的5个程序的可利用状态，但无法生成有效的防御，因为在堆分配器中部署了完整性检查。

* 堆空间排布。大量基于堆的漏洞只能在特定的内存布局中被利用。由于内存分配器和程序行为的复杂性，生成输入以按预期构建内存布局是非常具有挑战性的。

* 多个漏洞的组合。在实践中，成功利用通常需要多个漏洞。我们必须收集不同的漏洞并利用它们的破坏来制作一个最终的漏洞。

* **程序理解和分析。为了成功地利用一个程序，有必要了解程序的行为，例如，什么输入将导致什么输出，并在运行时做出动态决策。此外，很少有程序分析解决方案可以提取这些信息。如前所述，广泛使用的符号执行也有许多限制。**

## 9.总结

现有的AEG解决方案面临着利用可衍生性问题、符号执行瓶颈和基于堆的漏洞等挑战。我们提出了一个非常能够在发散路径而不是崩溃路径中搜索可利用状态的解决方案，该解决方案采用了一种新颖的面向布局的模糊和控制流拼接解决方案。它可能会触发漏洞和大部分易受攻击的应用程序的可利用状态。它还可以成功地生成针对某些漏洞的有效利用。它向实用的AEG又迈进了一步。但还有很长的路要走。