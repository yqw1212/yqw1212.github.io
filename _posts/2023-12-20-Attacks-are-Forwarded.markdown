---
layout: post
title:  Attacks are Forwarded Breaking the Isolation of MicroVM-based Containers
date:   2023-12-20 00:08:01 +0300
image:  2023-12-20-mushroom.jpg
tags:   [note,paper]
---

# 攻击转发:通过操作转发打破基于micro VM的容器隔离

## 摘要

人们建议使用虚拟化技术来加强容器之间的隔离。在设计中，每个容器在一个轻量级虚拟机(称为microVM)中运行。

基于microVM的容器得益于microVM的安全性和容器的高效率，因此在公共云上得到了广泛的应用。

然而，在本文中，我们展示了一种新的攻击面，可以用来打破基于micro VM的容器的隔离，称为操作转发攻击。我们的主要观察结果是，基于micro VM的容器的某些操作被转发给主机系统调用和主机内核函数。攻击者可以利用操作转发来利用主机内核的漏洞并耗尽主机资源。为了充分了解操作转发攻击的安全风险，我们将基于micro VM的容器组件根据其功能划分为三层，并提出相应的攻击策略，利用每层的操作转发进行攻击。

此外，我们设计了八种针对Kata容器和基于鞭炮容器的攻击，并在本地环境、AWS和阿里云上进行了实验。我们的研究结果表明，攻击者可以触发潜在的特权升级，降低受害者容器93.4%的IO性能和75.0%的CPU性能，甚至使主机崩溃。我们进一步给出了减轻这些攻击的安全建议

## 1.介绍

容器以其较高的资源利用效率在云计算中得到了广泛的应用。根据云原生计算基金会的《2021年云原生调查》，93%的受调查者目前正在使用或计划在他们的产品中使用容器，自2016年以来增长了300%。如今，容器技术已经成为云计算的基础。所有领先的云计算供应商都提供基于容器的云计算服务，例如Azure容器实例和AWS弹性容器服务。

不幸的是，容器的高效率也是有代价的。共享内核的设计不能在容器之间提供强隔离，从而导致信息泄漏[2]、带外工作负载破坏控制组[3]和抽象资源攻击[4]。更糟糕的是，攻击者可以利用内核错误来破坏共享内核，从而攻击同一内核[5]上的所有容器。为了减轻共享内核带来的安全风险，以前的工作已经提出了基于micro VM的容器，它在一个轻量级虚拟机(称为micro VM)中运行每个容器。

基于micro VM的容器提供了专用的客户机内核，并使用硬件虚拟化来强制容器之间的强隔离。因为micro VM的安全性和容器的高效率，它被视为原始共享内核容器的安全替代品。领先的云计算供应商已经开发了多种基于micro VM的容器技术，例如来自Amazon AWS[6]的基于Firecracker的容器和来自阿里云[7]的Kata容器。它们都在公共云上被大量使用。例如，基于Firecracker的容器是AWS无服务器服务的运行时，包括AWS Fargate[8]和Lambda[9]。

与传统的虚拟机类似，基于micro VM的容器使用hypervisor来创建和管理micro VM。在VM之上，它添加容器运行时组件以在micro VM中创建容器。容器的大多数系统调用需求由micro VM的guest内核提供。基于micro vm的容器和host环境可以看作是两个孤立的世界。然而，我们观察到，由于性能和功能需求，基于micro VM的容器的某些操作被转发到host内核(称为操作转发)。不幸的是，现有的对于虚拟机安全的研究工作[10-15]主要关注漏洞、侧信道和隐蔽通道，忽略操作转发。

然而，在本文中，我们证明了可以利用操作转发来打破基于micro VM的容器的隔离。我们发现攻击者可以利用基于micro VM的容器的操作转发来触发特定的host系统调用和内核函数。接下来，攻击者使用这些系统调用和内核函数作为条目来利用host内核的漏洞并耗尽主机资源。我们称这些攻击为操作转发攻击。

为了系统地探索攻击面，我们根据其功能将基于micro VM的容器组件分为三层:容器运行时组件、设备模拟器和主机内核组件。我们针对这三层设计了三种攻击策略。为了证明这些攻击策略的可行性和实用性，我们利用一种半自动方法来识别攻击向量。我们进一步设计了8种针对基于Firecracker容器和Kata容器的攻击，以评估这些攻击的影响并展示这些攻击的安全风险。本工作的贡献总结如下。

* 新的攻击面。我们展示了一种新的基于微虚拟机的容器攻击面，称为操作转发攻击。攻击者可以利用基于micro VM的容器组件的操作转发触发host内核漏洞，耗尽主机资源，从而引发潜在的特权升级和DoS攻击。

* 攻击策略。我们提出了针对所有三层基于micro VM的容器的攻击策略，包括容器运行时组件、设备模拟器和主机内核组件。我们演示了攻击者可以通过所有三层发起操作转发攻击，以打破基于micro VM的容器的隔离。

* 实际的攻击。我们设计了八种针对Kata容器和基于Firecracker容器的攻击，并在本地测试平台、阿里云和AWS上进行了实验。所有这些环境都很容易受到我们的攻击。更具体地说，这些攻击导致特权升级，导致93.4%的IO效率下降和75.0%的CPU效率下降，以及60.0%的数据包丢失。我们已经向相关安全团队报告了所有问题。他们已经确认了这些问题，并分配了一个新的CVE (CVE-2022-0358)[16]给我们。

## 2.背景

在本节中，我们将介绍工作所需的背景知识，包括基于microvm的容器体系结构及其应用场景。

基于microvm的容器架构。基于microvm的容器在专用的轻量级虚拟机中运行本机容器实例，这排除了虚拟机中不必要的设备和面向客户机的功能机器去减少性能开销和攻击面。如图1所示，根据功能，基于microvm的容器的体系结构可以分为三层:(1)容器运行时组件，(2)设备模拟器，(3)主机内核组件。具体来说，引入了容器运行时组件来启动和管理微虚拟机以及在微虚拟机中运行的本地容器。设备模拟器是主机上的用户空间程序，用于模拟各种硬件设备。主机内核组件是主机中可加载的内核模块，用于提供虚拟化功能支持。例如，基于内核的虚拟机(KVM)[17]允许主机内核充当管理程序，vhostnet[18]模块将网络设备从设备模拟器卸载到内核模块。请注意，基于microVM的容器的microVM主要利用virtio[19]框架进行IO虚拟化，该框架在客户机内核中采用前端驱动程序。前端驱动程序通过virtqueues将IO请求从容器传输到容器运行时组件和设备仿真器层中的后端。

因此，有两种流行的基于microvm的容器，即Kata容器[7]和基于爆竹的容器[20]。在容器运行时组件层，Kata运行时为Kata容器创建和管理微虚拟机和隔离容器，爆竹容器[21]在基于爆竹的容器中扮演相同的角色。此外，virtiofs守护进程是Kata Containers的一个独特的容器运行时组件，它支持virtiofs，以便在主机和客户机系统之间共享容器的rootfs和卷。对于设备仿真器层，QEMU是Kata Containers的默认设备仿真器，而爆竹自然是基于爆竹的容器的设备仿真器。

Kata Containers和基于fireacker的容器都使用KVM作为hypervisor，而只有Kata Containers在主机内核组件层引入了vhost-net模块用于网络连接。

应用程序场景。为了加强隔离和安全性，云供应商使用不同的基于microvm的容器来包含每个租户的工作负载。例如，AWS (Amazon Web Services)使用爆竹微虚拟机在多租户环境[22]中隔离工作负载。具体来说，在AWS无服务器环境中，例如Lambda[9]和在[8]中，一个租户的所有本机容器都运行在专用的鞭炮容器微虚拟机中，并由鞭炮容器[23]管理。相比之下，阿里云使用Kata容器提供名为ECI(弹性容器实例)[24]的多租户无服务器环境。在ECI中，一个租户的工作负载被限制在一个单独的Kata容器实例中，该实例默认情况下使用QEMU作为设备模拟器。也就是说，云供应商利用基于microvm的容器来保护多租户环境中不同租户的工作负载。

理想情况下，由于每个基于microvm的容器都隔离在单个虚拟机中，因此通过此类容器的攻击即使不是不可能，也不太可能对主机或其他容器产生安全影响。然而，在本文中，我们证明了基于microvm的容器的隔离在其所有三个层(即容器运行时组件、设备模拟器和主机内核组件)中都存在安全风险。

恶意的云用户可以破坏基于microvm的容器的隔离，从而导致潜在的特权升级、DoS攻击甚至主机崩溃。

## 3.目的和攻击策略

在本节中，我们首先介绍威胁模型和我们工作的假设，然后描述本文的动机，并使用一个真实的例子来说明细节。之后，我们根据基于micro VM的容器架构，介绍三种策略，系统地探索每一层的攻击(如图1所示)。

### 3.1威胁模型与假设

攻击者的目的是破坏基于micro VM的容器的隔离，并破坏在同一主机上运行的其他容器，因为基于micro VM的容器被云供应商广泛使用提供多租户容器服务[8,24]。我们假设攻击者能够通过web或命令行控制台创建一个或多个基于micro VM的容器。攻击者还可以通过控制台与容器运行时交互。此外，攻击者可以在创建的基于micro VM的容器中运行任何程序。这个假设是合理的，因为所有流行的云供应商都为云用户提供控制台，允许他们控制容器的生命周期。此外，云供应商允许用户在他们的容器中上传和执行他们自己的程序。

在限制方面，攻击者基于micro VM的容器受到最严格的安全实践的限制。有两层强制执行来限制基于micro VM的容器。第一层是主机内核使用所有流行的特性来隔离这些微虚拟机。更具体地说，主机内核利用最先进的硬件虚拟化(例如，支持Intel CPU VT-x[25]的KVM)来隔离微虚拟机。同时，host内核使用seccomp[26]来阻止micro VM发起的敏感主机系统调用，并利用控制组(cgroups)[27]来限制micro VM的资源利用率。第二层是客户机内核强制使用尽可能多的名称空间[28]和控制组来限制micro VM中的容器。我们进一步假设主机和guest内核没有已知的漏洞，并且所有安全机制都正常工作。

在本文中，我们证明了即使实施了上述所有隔离和保护，恶意用户仍然可以攻击主机或其他受害容器。

### 3.2目的举例

基于micro VM的容器将操作转发给主机内核，并使用host内核功能来满足其需求。但是，操作转发引入了新的攻击面，使攻击者能够突破micro VM隔离。在下面，我们使用一个真实的攻击来说明攻击面，它是由我们发现并由Kata开发人员确认的(分配了一个新的CVE)。

Kata Containers利用虚拟机在host系统和容器之间共享目录和文件(即容器rootfs映像、容器卷)。virtiofs守护进程的直通设计导致攻击。为了在micro VM和主机之间共享目录，virtiofs将客户机系统调用转发给host用户空间程序(即virtiofs守护进程)，并利用它在共享目录上执行实际操作。在本例中，我们注意到virtiofs将guest open()转发给virtiofs守护进程的open()，而virtiofs守护进程本身具有不适当的权限。因此，恶意容器可以利用virtiofs守护进程的权限来绕过对host内核的检查，并创建一个具有主机根SGID的文件，从而允许在主机上进行权限升级。

具体来说，如果共享目录属于普通用户和主机根组，并且为其设置了SGID (Set group ID)权限[29]位，则恶意容器可以在该目录中创建具有非预期主机SGID权限位的可执行文件。注意，如果为目录设置了SGID权限位，那么在目录中创建的任何文件都将获得与目录相同的组所有权。由于文件的SGID权限允许以文件所属的组执行该文件，因此普通用户在执行恶意容器创建的文件时可以获得主机根组权限。

为了发起攻击，恶意容器请求在共享目录中创建一个具有SGID权限位的新文件，这是通过使用S_ISGID[30]标志进行open()系统调用来实现的。guest内核中的virtiofs驱动程序拦截open()系统调用，并将其转发给virtiofs守护进程，后者请求host的open()系统调用来提供其功能(图2中)。之后，文件创建请求进入主机内核并调用inode_init_owner()函数来初始化创建文件的inode。如图3所示，inode_init_owner()函数确定是否需要清除创建文件的SGID权限位。为此，它首先检查目录是否具有SGID权限位(第4行)，在本例中，SGID将被自然传递。然后，它检查创建进程是否与目录所有者具有相同的补充组。但是，根据virtiofs守护进程的文档[31]，virtiofs守护进程必须以root用户运行，并且在其补充组中具有root组。结果，检查通过了，文件成功地保留了应该被清除的SGID权限。

注意，在上面的过程中，为了完成文件创建的任务，碰巧发生了从guest的open()到host系统open()的系统调用转发操作。我们在本文中主要观察到的是，如果使用不当，操作转发有可能引入(或转发)攻击，如图2的真实示例所示。

我们向虚拟环境的开发小组报告了这个bug。他们确认了这个问题，并通过从virtiofs守护进程的组列表中删除root组来修复它。经过红帽产品团队的进一步评估，我们已经分配了一个新的CVE-2022-0358[16]。

### 3.3攻击策略概述

我们设计了三种攻击策略，分别针对容器运行时组件、设备模拟器组件和主机内核组件发起操作转发攻击如图4所示。这些策略的关键思想是利用操作转发使每一层的组件不正确地调用host系统调用和内核函数。首先，我们在§3.4中展示了攻击者或攻击者控制的容器可以触发容器运行时组件调用host系统来利用host内核的漏洞并耗尽主机资源(图4)。其次，我们在§3.5中展示了恶意容器可以强制设备模拟器调用host系统调用来耗尽主机资源(图4中的9)。第三，我们在§3.6中演示了恶意容器可以通过主机内核组件将其操作转发给内核线程运行的主机内核函数，这消耗了额外的CPU资源(图4)。

### 3.4攻击容器运行时组件

第一种策略是利用容器运行时组件来打破基于micro VM的容器的隔离(图4)。请注意，容器运行时组件将客户机系统调用或容器管理请求转发给host系统调用，没有速率限制和额外的安全检查。恶意容器可以利用这种高速转发操作来耗尽主机资源。此外，攻击者可以利用操作转发来利用主机内核的漏洞并升级特权。

攻击者可以利用两条路径发起操作转发攻击(图4中)。第一，攻击者控制的恶意容器可以调用guest系统。然后，系统调用请求由host内核中的前端驱动程序转发给容器运行时组件的host系统调用。其次，攻击者可以通过管理控制台直接向容器运行时组件发送容器管理请求，以达到相同的目的。

利用上述操作转发，攻击者可以对host进行攻击，耗尽主机资源。例如，容器的write()被转发给host的write()，这会耗尽主机的脏内存。我们将在§4.3.1中介绍更多细节。更糟糕的是，这些组件需要host特权才能执行操作，因此它们都以根用户身份运行。因此，攻击者可以用root权限触发主机系统调用，以逃离基于microvm的容器，我们将在§4.4.1中的爆竹容器升级中演示。

### 3.5攻击设备模拟器

第二种策略是利用设备模拟器(如图4所示)。恶意容器可以利用操作转发反复触发特定的guest系统调用，从而消耗大量主机内核资源，引发DoS攻击。

设备模拟器是一个用户空间程序，用于模拟micro VM的设备行为。为了模拟这些设备，它调用host系统并利用主机内核访问实际的物理设备。如图4所示，当容器在guest内核中进行系统调用时，guest内核的前端驱动程序将请求发送到设备模拟器中的后端设备。之后，设备模拟器调用host系统调用来实现其功能。

因此，恶意容器可以通过反复触发设备模拟器的操作转发来耗尽主机资源。例如，virtio块(又名virtio块)为Firecracker微虚拟机提供了一个虚拟硬盘。将大文件直接写入客户机的磁盘会触发虚拟块设备将磁盘映像文件写入主机，这会占用主机的脏内存。类似地，virtio-net设备利用host内核网络堆栈将容器数据包转发到目的地，这会填满主机连接跟踪表。我们将在§4.4.2和§4.4.3中介绍更多细节

### 3.6攻击主机内核组件

第三种策略是利用host内核组件(如图4中所示)。恶意容器可以利用操作转发在host内核服务上产生带外负载，从而消耗额外的主机资源，导致DoS攻击。

与前两层不同，host内核组件是host内核空间中的内核模块，它们将容器的操作转发给host内核函数。其中一些内核函数在内核线程的上下文中运行，这些内核线程被调度到物理CPU并消耗CPU资源。然而，这些内核线程被附加到主机根组。因此，这些内核线程所消耗的资源不受基于micro VM的容器的限制。

具体来说，KVM和vhost-net内核模块创建几个内核线程来异步模拟硬件设备。例如，KVM创建KVM - PIT内核线程，将可编程间隔定时器(Programmable Interval Timer, PIT)[32]中断注入客户机系统。vhost-net内核模块创建一个vhost内核线程来执行网络设备仿真。这些内核线程将被唤醒以运行内核函数，并消耗大量CPU资源。同时，它们都附加到根组。因此，基于micro VM的容器可以将工作负载委托给host内核线程，消耗额外的主机资源，并打破基于micro VM的容器的隔离性。

## 4.操作转发攻击:实际案例研究

在本节中，我们首先介绍识别攻击向量的方法。然后用实际案例对识别出的攻击向量进行验证，给出了攻击基于micro VM容器具体的攻击步骤。结果表明，我们的攻击策略是切实可行的，并有严重的后果。

### 4.1识别攻击向量

我们的方法。我们根据§3中的策略设计了一种半自动方法来识别攻击向量。我们的方法包括两个步骤。首先，我们结合动态和静态分析来确定从容器到主机的操作转发路径。对于动态分析，我们在容器中运行Linux Test Project (LTP)[33]测试用例来触发guest系统调用。同时，我们使用strace命令跟踪容器运行时组件(例如，virtiofs守护进程)和设备模拟器进程。这些跟踪允许我们在源自设备模拟器或容器运行时组件进程的guest系统调用和host系统调用之间建立转发映射。此外，攻击者可以直接通过gRPC向容器运行时组件发送容器管理请求。因此，我们开发了一个脚本工具，对容器组件的源代码进行静态分析，识别gRPC实现中的主机系统调用，构建从容器管理请求到host系统调用的操作转发路径。其次，我们手动遍历所有操作转发路径，以识别错过权限检查或速率限制的路径。我们称这些转发路径为敏感路径。为了验证利用敏感路径的实用性，我们然后手动设计攻击来触发host漏洞或通过这些路径耗尽主机资源。

让我们使用第3.2节中的virtiofs示例来说明上述步骤。我们首先运行LTP测试用例来触发客户机系统调用，并使用trace来跟踪路径。因此，我们确定了25条从虚拟机开始的操作转发路径。

其次，我们遍历这些转发路径并确定一个敏感路径，virtiofs守护进程在不从其补充组中删除主机root组的情况下触发host系统调用open()。因此，我们遵循这个敏感的路径，绕过host内核的检查，通过virtiofs守护进程创建一个具有主机根SGID的文件，这将导致主机上的特权升级。使用相同的方法，我们进一步确定了基于micro VM的容器的所有三层中的其他七种攻击，如§4.3和§4.4所述。

相关的技术。研究人员提出了多种虚拟机监控程序模糊测试技术来自动发现与虚拟化相关的错误[34-36]。这些工作中的技术可用于触发从容器到主机的路径。然而，这些fuzzers更多地关注内存漏洞，如use-after-free，堆栈(或堆)溢出和段错误，而不是VM和主机之间的操作转发路径。此外，为了确定有意义的转发路径，除了代码覆盖率之外，fuzzer还需要额外的反馈，如资源利用率和权限变化来激励程序突变，这很难实现。

基于microvm的容器和主机环境也可以看作是两个孤立的世界。因此，在基于microvm的容器场景中，SGX enclave和主机[37]之间的清理漏洞也可能存在。但是，本文关注的是由于操作转发引起的特殊问题，而不是由于缺少卫生处理而引起的一般安全问题。

### 4.2实验设置和结果总结

道德考虑。我们在本地测试平台和云供应商平台上进行了实验。对于云供应商平台，请注意我们的攻击可能会影响同一主机上的其他租户。因此，我们选择使用AWS和阿里云的专用裸金属服务器进行实验，仅供我们使用，不与其他租户共享。

环境设置。我们在本地和云供应商平台上设置了基于micro VM的容器环境。在本地环境中，测试机器具有Intel Core i5 CPU，具有8gb内存和256GB SSD，并且运行在Linux内核v5.17.0的20.2.2 Desktop中。我们在本地测试平台上部署基于Firecracker的容器和Kata容器。对于云供应商平台，我们在AWS m5zn上部署了一个基于Firecracker的容器。金属裸机服务器，48vCPU和192GB内存，使用Amazon Linux 2和Linux Kernel v5.10来模拟AWS多租户环境。为了代表阿里云的多租户环境，我们在阿里云etc.ebmc6me.16x large裸机服务器(60vCPU和192GB内存上)部署了Kata容器。，使用Ubuntu 20.04 LTS和Linux内核v5.11。

此外，我们遵循Firecracker容器的文档在本地和AWS裸机服务器上部署基于鞭炮的容器，使用Firecracker容器v1.6.3和Firecracker容器v1.1.0。请注意，Firecracker-containerd是一个不完整的开源项目，缺乏必要的操作文档。我们修改它的源代码来激活它的一些特性。例如，我们执行卷测试[38]来启用容器卷。对于Kata Containers，我们在本地和阿里云裸机服务器上分别部署了v2.4.0-alpha0和基于[39]指导的QEMU v6.1.0。

结果总结。我们发起攻击并进行案例研究以验证已识别的攻击向量。所有案例研究的总体总结如表1所示，包括案例名称(case)、对应的攻击策略(strategy)、操作转发的触发函数(trigger Func)、操作转发的host函数(host Func)、发起攻击的恶意容器数量(Container#)以及攻击案例对应的影响(impact)。

对于Kata Containers环境，除了第3.2节中的virtiofs守护进程升级攻击外，我们还设计了另外三种攻击。1)脏内存攻击。攻击者利用virtiofs守护进程转发的write()操作来耗尽主机上的脏内存，使受害者的IO性能降低93.4%。2) nf_conntrack表攻击。恶意的Kata容器使connect()触发vhost-net内核模块(策略为:通过调用tap_sendmsg()来填满主机的nf_conntrack表，导致受害容器丢失55.0%的网络数据包，无法与典型的应用程序(如Nginx服务器)建立连接。3) vhost-net攻击。客户端sendmsg()或recvmsg()通过vhost-net(策略方)转发给主机handle_tx()或handle_rx()，这可以被恶意的Kata容器利用，使其消耗的资源增加1倍。

对于基于Firecracker的容器，我们设计了四种新的攻击。1) 基于Firecracker的容器提权。攻击者向Firecracker容器发送精心制作的CreateVM()请求(策略注释)。然后，基于Firecracker的容器调用host的chmod()和create()，这可以更改任何主机目录的所有者或清空主机上的任何文件。2)基于Firecracker的容器脏内存攻击。恶意的基于Firecracker的容器利用虚拟块后端设备(策略9)将guest的write()转发给host的write()以占用主机脏内存，这会使受害容器的IO性能降低86.7%。3) nf_conntrack表攻击。恶意容器使用connect()强制虚拟网络后端设备(策略9)调用sendmsg()，这会填满主机的nf_conntrack表，导致60.0%的受害者数据包丢失，使Nginx服务不可用。4) KVM PIT定时器攻击(策略)。基于Firecracker的恶意容器使用outb()使KVM调用pit_do_work()，从而将大量定时器中断注入guest系统，最终使受害者的CPU性能降低75.0%。

### 4.3对Kata容器的攻击

在Kata容器环境中，我们利用三个新的案例研究来展示如何利用§3.3中的攻击策略来打破Kata容器的隔离。我们成功地在本地环境和阿里云上进行了实验。

#### 4.3.1 Kata容器脏内存攻击

第一种是利用主机的脏内存。恶意的Kata容器可以利用virtiofs守护进程将write()系统调用从gurst转发到host(策略见图4)。恶意容器可以通过反复触发write()系统调用来写入共享目录中的文件，从而在主机内核中生成大量脏内存。结果，受害容器的IO性能急剧下降了93.4%。

根本原因分析。主机内核脏内存的大小影响文件的读写性能。Linux内核引入dirty_backgroud_ratio和dirty_ratio作为整个内核空间脏内存的阈值。每当脏内存的大小达到dirty_backgroud_ratio时，内核就会唤醒flusher线程，将脏内存同步到磁盘。此外，如果脏内存的大小持续增加到dirty_ratio，所有进程的写模式将从回写转换为透写。需要注意的是，回写模式只允许将文件数据写入内存，而透写模式需要等待耗时的磁盘IO操作才能将文件数据写入磁盘。如果将写模式从回写更改为透写，则写性能将大大降低。

恶意的Kata容器可以影响内核脏内存的大小。如图5所示，当容器调用guest write()来写入共享目录中的文件时，写入请求由guest内核的VFS(虚拟文件系统)处理。然后，virtiofs驱动程序拦截该请求，并通过virtio将此写请求的元数据传输到host用户空间中的virtiofs守护进程。一旦主机中的virtiofs守护进程接收到请求，它就会触发host的write()系统调用并写入共享目录中的文件，这会增加主机内核中脏内存的大小。因此，如果攻击者在容器中反复生成和写入文件，就有可能占用所有脏内存并达到主机内核中的dirty_ratio阈值。

实验。在一个恶意容器中，我们利用dd if=/dev/zero of=/mnt/test bs=1M count=4096 oflag=direct命令来创建和写入文件。在受害容器中，我们运行相同的命令来测量攻击前后的IO性能。在那之后，我们增加攻击容器的数量，并评估攻击成本(即攻击者数量)与相应降级之间的关系。

在本地环境中，我们分别使用1个、5个和10个恶意容器发起攻击。因此，受害者对dd命令的降级率分别为93.4%、96.7%和98.2%。在阿里云上，机器内存为192GB, dirty_ratio阈值设置为20%。至少需要两个恶意容器才能占用脏内存并达到dirty_ratio阈值。我们使用2个、5个和10个恶意容器进行攻击，受害者的降级率分别为94.6%、97.1%和98.5%。

#### 4.3.2 Kata容器的Nf_conntrack Table攻击

第二种是Kata的容器Nf_conntrack Table类攻击，涉及到策略:在这种情况下，恶意容器调用的connect()系统调用被转发到vhost-net模块，该模块触发host内核中的tap_sendmsg()函数。这个函数向host内核网络堆栈发送帧，这将在主机nf_conntrack表中添加一个项目。因此，攻击者可以利用这种操作转发来填满host内核的nf_conntrack表，这将最终导致受害容器丢失55.0%的网络数据包。

根本原因分析。如果主机的nf_conntrack表被填满，它将导致在host系统上随机丢弃数据包。注意，连接跟踪[40]是Linux内核中netfilter模块的一部分，它在一个名为nf_conntrack表的内存表中维护有关连接的状态信息。

Linux内核引入nf_conntrack_max来表示nf_conntrack表中条目的最大数量。如果表项数达到nf_conntrack_max阈值，则netfilter模块将丢弃接收到的报文，并且不能成功建立新的连接。

恶意容器可以通过connect()系统调用来与其他容器建立TCP连接，从而占用主机nf_conntrack表中的一个条目，如图6所示。由connect()发送的网络数据包被封装成以太网帧并分派给virtionet驱动程序。然后驱动程序通过virtio将帧从guest系统传输到主机系统。之后，主机内核的vhostnet模块从驱动程序接收帧，并调用tun_sendmsg()将帧发送到tap设备[41]。最后，这些帧由主机容器网络接口(CNI)虚拟网桥[42]转发到其他容器，这会触发host内核的nf_conntrack_alloc()函数，并在host内核的nf_conntrack表中添加一个项。因此，恶意容器可以利用这种转发机制来填满host内核中的nf_conntrack表，从而使主机随机丢包。

实验。我们使用10个恶意的Kata容器在本地和阿里云上发起攻击。它们在彼此之间建立了许多TCP短连接。因此，vhost-net主机内核模块将填充nf_conntrack表。此外，我们通过两组实验来评估攻击的影响。首先，我们在受害容器中运行ping命令来测量由于攻击导致的丢包率，然后我们增加恶意容器的数量来评估丢包率的变化。其次，我们在受害容器中运行Nginx服务器，并在另一个容器中使用基准测试工具[43]来测量Nginx服务器的性能下降。我们还增加了恶意容器的数量，以评估攻击成本与Nginx服务器性能下降之间的关系。

一旦nf_conntrack表填满，它就开始随机丢弃数据包。具体来说，对于ping实验集，我们分别使用10、15、20个容器进行攻击，在本地环境下丢包率分别为55.0%、57.0%、61.0%，在阿里云上丢包率分别为45.0%、49.0%、50.0%。而对于Nginx实验集，一旦nf_conntrack表被填满，ab命令无法与Nginx服务器建立连接，并返回“指定的超时时间已过期”。在两个环境中，无论容器的增长数量如何，ab命令都会超时。

#### 4.3.3 Vhost-net内核模块攻击

第三种情况是利用Vhost-net内核模块。在这种情况下，恶意容器的sendmsg()和recvmsg()系统调用被转发到vhost-net内核模块，从而触发handle_rx()和handle_tx()内核函数。因此，vhost-net内核模块唤醒一个vhost工作线程来处理上述内核函数，并发送和接收网络数据包。该进程生成的带外工作负载由主机根cgroups承担。通过产生一个大的网络吞吐量，一个恶意的Kata容器能够强制主机内核中的vhost工作线程转发网络数据包，从而消耗1倍以上的资源(图4中的策略)。

根本原因分析。由vhost-net内核模块创建的vhost-net worker线程消耗CPU资源来处理网络报文转发。作为一个内核模块，引入vhost-net是为了通过减少虚拟网络中涉及的系统调用的数量来提高容器的网络性能。它可以通过调用内核函数而不是系统调用，直接利用主机内核服务来实现其功能。具体来说，为每个虚拟机创建一个名为vhost-\<owner-device-emulator-process-pid\> 的工作线程。工作线程主要负责运行handle_rx()和handle_tx()内核函数。

这两个内核功能在虚拟网络驱动程序和vhost-net内核模块之间传输网络数据包，在网络流量较大的情况下会消耗CPU资源。同时，vhost工作线程被附加到主机根组。因此，工作负载不会计入微虚拟机本身。

实验。我们创建了两个恶意的Kata容器，使用iperf工具产生大量的网络吞吐量，并在它们之间传输大量的网络数据包。

最后，每个容器在两个独立的vhost内核线程上生成工作负载，每个内核线程消耗1倍以上的CPU资源。本地环境和云环境的结果是一样的。

### 4.4对基于爆竹的容器的攻击

在基于爆竹的容器环境中，我们利用四个案例研究来展示如何使用§3中的策略来打破基于爆竹的容器的隔离。我们在本地和AWS裸机环境上进行实验。

#### 4.4.1Firecracker容器提权

基于Firecracker容器的第一种情况是利用Firecracker容器实现权限升级和主机崩溃。具体来说，恶意用户发送的容器管理请求可以触发Firecracker容器进行host chown()和create()系统调用，它们在启动Firecracker微虚拟机之前准备卷目录。由于不小心检查了上述两个系统调用的参数，攻击者可以在容器创建请求中定制精心制作的卷路径，从而欺骗Firecracker容器用不正确的参数调用这些系统调用。此外，Firecracker容器以root用户运行，这有两个后果。首先，基于Firecracker的容器将文件父目录的所有者更改为特定用户(例如，主机中的普通用户)。换句话说，攻击者可以更改任何主机目录的所有者，这会引入特权升级。其次，文件可以被截断到长度为0。因此，通过清空主机的基本系统文件(如ld.so)，由于动态链接器崩溃，主机无法再运行任何应用程序。

根本原因分析。由于引入了runc-jailer 2，所以基于Firecracker的容器需要调用一些系统调用来为microvm的启动做准备。特别地，runc-jailer2在运行在主机用户空间中的runc容器中启动Firecracker进程，该容器使用容器隔离和限制机制来监禁Firecracker进程。启用runc狱狱器后，基于Firecracker的容器首先在主机上创建一个目录作为runc-jailer2的根目录。然后，基于Firecracker的容器复制Firecracker二进制文件、guest内核二进制文件、microVM的根文件系统映像、容器的rootfs映像和容器卷放到创建的目录中，这确保了jailer中的Firecracker进程可以访问它们。最后，Firecracker容器启动一个runc jailer，并在jailer中执行Firecracker二进制文件。

当用户创建基于Firecracker的容器时，他/她可以指定并以主机普通用户的身份运行runc jailer。此外，用户可以指定卷的配置。如图7所示，prepareBindMounts()函数将文件及其父目录复制到runc jailer的目录中，该目录由主机卷路径指定。首先，prepareBindMounts()函数使用filepath.Join()(第5行)将jailer器的根目录和卷的主机路径连接到一个连接路径。然后，在bindMountFileToJail()函数中，filepath.Dir()获得连接路径的父目录，os.Chown()将目录的所有者更改为runc jailer的用户(第14行)，该用户指定为主机普通用户。最后，os.Create()在jailer的根目录下创建一个空的复制文件(第16行)。需要指出的是，如果os.Create()函数的dst参数指向一个现有文件，那么该文件将被一个新的空文件替换。

但是，对于精心制作的卷的主机路径，filepath.Join()的结果可能指向runc kailer根目录之外的任何主机文件。同时，os.Chown()函数不检查连接的路径是否在狱狱器的根目录下，而只是将文件父目录的所有者更改为指定主机的常规用户。更糟糕的是，os.Create()函数也不执行任何检查。因此，如果dst参数指向主机上现有的重要系统文件(例如，ld.so)，则该文件将被无情地清空。结果，由于文件崩溃，主机无法再运行任何应用程序。

实验。我们将详细介绍如何发动攻击。具体来说,我们指定m.HostPath () /../../../../../../root/FILENAME (FILENAME为/root目录下的常规文件)。如图7所示，filePath.Join()将目录连接到/root/FILENAME(第5行)。然后，在bindMountFiletoJail()函数中，dst参数是/root/FILENAME。由于filePath.Dir()函数获取文件所在目录的位置，因此filePath.Dir()的结果是/root。os.Chown()函数将/root的所有者更改为指定的主机常规用户(第14行)。因此，主机普通用户可以获得访问/root目录的特权。此外,我们指定m.HostPath ()到/../../../../../../lib/x86_64-linux-gnu/ld - 2.27。因此，如图7所示，filePath.Join()将dst参数连接为/lib/x86_64-linux-gnu/ld-2.27.so。因为ld-2.27是主机中的现有文件，os.Create()将其大小截断为0(第16行)，这会导致主机崩溃，因为它无法运行任何新的有意义的应用程序。

#### 4.4.2基于Firecracker的容器脏内存攻击

第二种情况是基于Firecracker的容器脏内存攻击，涉及到策略9。恶意的基于Firecracker的容器可以利用virtio块(virtio- block)将write()操作转发到主机系统。类似于对Kata容器的脏内存攻击，恶意容器可以触发该操作反复转发，耗尽主机的脏内存。结果，受害的基于Firecracker的容器遭受了86.7%的IO性能下降。

根本原因分析。与Kata Containers中的virtiofs守护进程类似，基于Firecracker的容器也可以在virtio- block的帮助下增加host脏内存的大小。基于Firecracker的容器使用virtio- block将容器的rootfs映像挂载到microVM中。如图8所示，当恶意容器生成大量write()系统调用来写入容器中的文件时，文件操作将作为块IO请求传递给guest内核中的虚拟块驱动程序。然后驱动程序通过virtio将块IO请求转发到Firecracker中的虚拟块设备。之后，Firecracker会进行大量的host系统调用write()来修改磁盘映像文件，并迅速占用host的脏内存，达到host内核的dirty_ratio阈值。因此，host内核强制所有写请求直接同步到磁盘，这将大大降低受害容器的IO性能。

实验。在我们的本地环境中，我们使用1、5和10个恶意容器发起攻击，受害容器中的dd命令分别减慢了86.7%、97.4%和98.2%。在AWS环境中，机器有192GB内存和dirty_ratio阈值被设置为20%。它至少需要两个容器来填充脏内存。我们用2个、5个和10个恶意容器进行实验，受害者分别遭受了70.0%、83.1%和92.9%的减速。

#### 4.4.3基于鞭炮的容器Nf_conntrack表攻击

第三种情况是基于鞭炮的容器Nf_conntrack表攻击，涉及到9号策略。恶意容器可以利用fireacker中的virtio-net设备将客户机connect()系统调用转发给主机sendmsg()，并在向主机的nf_conntrack表中写入项目的同时向主机内核网络堆栈发送帧。通过反复触发该机制，恶意容器可以占用主机的nf_conntrack表，造成受害者60.0%的丢包。

根本原因分析。基于鞭炮的容器使用virtio-net设备而不是vhost-net内核模块作为virtio-net驱动程序的后端设备进行网络连接。但是，恶意容器仍然可以利用virtio-net设备来消耗主机nf_conntrack表的条目。如图9所示，首先，当基于爆竹的容器在microVM内重复进行connect()系统调用时，数据链路层从客户机内核中的网络层接收大量数据包。它将它们封装成帧，并通过virtio将它们传输到鞭炮中的虚拟网络后端设备。其次，爆竹设备模拟器在主机内核中进行sendmsg()系统调用，并将帧发送到/dev/net/tap，这是一个向主机用户空间公开的tap设备接口。之后，帧通过主机CNI网桥传输到其他容器。同时，主机上的netfilter调用nf_conntrack_alloc()函数，并在主机内核的nf_conntrack表中写入大量项。因此，基于爆竹的恶意容器可以生成许多连接并填满主机内核的nf_conntrack表，从而使主机随机丢弃数据包。

实验。我们用10个，15个，20个集装箱发动攻击。因此，需要一分钟才能填满主机的nf_conntrack表。一旦nf_conntrack表填满，它就开始随机丢弃数据包。具体来说，在ping实验中，受害者在本地环境下的丢包率分别为60.0%、58.0%和58.0%，在AWS上的丢包率分别为50.0%、52.0%和55.0%。对于Nginx实验，无法访问Nginx服务器，并返回超时错误。

#### 4.4.4 KVM PIT Timer攻击

第四种是利用KVM的PIT (programmable interval Timer)[32]仿真机制，涉及到策略。首先，基于爆竹的容器写入低级I/O端口以创建虚拟PIT定时器，KVM将对其进行模拟。其次，KVM唤醒一个主机内核线程来处理pit_do_work()内核函数，并注入计时器打断Guest。因此，基于鞭炮的恶意容器可以利用这种模拟机制将工作负载委托给内核线程，这会消耗主机68.0%的CPU，并显著降低其他容器的性能，最高可达87.8%。

根本原因分析KVM创建的内核线程消耗CPU，将PIT定时器中断注入客户机。PIT(Intel 8253/8253)[32]是一个计数器，当它达到编程计数时产生输出信号，输出信号将触发中断。写0x40-0x43 I/O端口可以创建周期PIT定时器并设置周期。为了模拟基于microvm的容器中的PIT计时器，KVM利用主机Linux内核的高分辨率计时器(hrtimers)[44]作为虚拟计数器。此外，它还为每个VM创建一个名为kvm-pit/的内核线程。每当hrtimer达到编程计数时，为hrtimer注册的回调函数将pit_do_work()排队到内核线程的工作列表中，并唤醒线程。

如果可以重复写I/O端口来创建PIT定时器，并设置一个小值作为定时器的周期，内核线程将保持调度到物理CPU，并运行pit_do_work()将定时器中断注入客户机。此外，kvm-pit内核线程附加到Linux内核中的根组。其工作负载消耗的资源数量计入目标内核线程，而不是用户空间进程。因此，基于micro VM的恶意容器可能会产生带外工作负载，消耗主机资源，并攻击其他基于micro VM的容器。

实验。在我们的实验中，我们使用outb()函数在恶意容器中写入0x43端口，触发虚拟机退出，KVM唤醒内核线程注入定时器中断。通过生成许多写请求来设置PIT定时器，恶意容器可以迫使kvm-pit线程在主机内核中运行带外工作负载，并消耗68.0%的主机CPU资源。我们使用sysbench来测量对受害容器的影响。我们用1个，10个，20个容器发动攻击。受害者在CPU基准测试中遭受3.3%、75.0%和86.6%的降级。内存性能下降5.3%、80.1%、87.8%，IO读性能下降4.6%、26.3%、64.6%，IO写性能下降5.0%、26.7%、64.6%。

### 4.5实用性讨论

对传统虚拟机的攻击。传统的虚拟机也容易受到操作转发攻击，因为虚拟机依赖于host内核来提供其功能。为了验证它，我们选择QEMU/KVM来运行虚拟机，并假设攻击者完全控制了恶意虚拟机。然后我们在本地环境中执行攻击。结果表明，脏内存攻击和nf_conntrack表攻击可以成功地引发DoS攻击。如果我们为VM网络启用vhost-net，并利用virtiofs在guest和host系统之间共享目录，那么vhost-net攻击和virtiofs守护进程升级攻击都可以达到与基于micro VM的容器相同的影响。令人惊讶的是，我们还发现virtiofs守护进程升级攻击也可以在9pfs[45]中实现特权升级，这也是一个在host和guest之间共享目录的直通文件系统，类似于virtiofs。但是，由于QEMU使用HPET (High Precision Event Timer)[46]来代替PIT定时器，因此在QEMU/KVM环境中无法对KVM的PIT定时器进行攻击。

负责任的披露。本研究中提出的所有8种攻击都已向Kata Containers、Firecracker和virtis团队负责任地披露。我们在附录a的表2中总结了我们的报告。具体来说，所有的攻击都得到了证实。此外，virtiofs守护进程升级、Firecracker容器升级和nf_conntrack表攻击(Firecracker)已经修复，补丁已经合并。而对于脏内存攻击(Kata)、nf_conntrack表攻击(Kata)、vhost-net攻击、脏内存攻击(Firecracker)和KVM PIT定时器攻击，开发人员已经给出了多种方法来降低这些风险。我们在图10和图11中列出了相关团队对每个公开攻击的所有响应。

## 5.缓解的讨论

在下面，我们给出了多个建议来缓解由容器运行时组件、设备模拟器和主机内核组件分别引入的操作转发攻击。这些建议是基于我们与相关安全团队的沟通。

### 5.1通过监控工具检测攻击行为

通过VMI (Virtual Machine Introspection)[47]等监控工具可以检测到基于micro VM的容器的异常行为。可以利用VMI监视由基于micro VM的容器发起的敏感guest系统调用，并通过不同的规则配置防御guest系统调用触发的攻击。然而，VMI技术带来了额外的性能开销，这在某些场景中可能是不可接受的。

### 5.2保护容器运行时组件

监禁容器运行时组件。监禁技术(即名称空间和cgroup)可以应用于容器运行时组件，以强制执行额外的资源隔离和限制。特别是，mount命名空间可以防止Firecrack容器修改其工作目录之外的文件，从而击败Firecrack容器升级攻击。此外，可以通过将virtiofs守护进程添加到cgroups中来限制virtiofs对脏内存的使用。

然而，确保容器运行时的正常功能需要付出努力。例如，virtiofs社区参与了关于使用用户名称空间启动非根virtiofs守护进程而不影响用户体验的激烈讨论3。

禁用共享文件系统。我们还建议禁用virtiofs文件系统，以避免多个操作转发路径，并减轻virtiofs引入的所有漏洞。然而，virtiofs旨在提供本地文件系统语义和高性能。在Kata Containers[49]中，文件系统性能下降，但无虚拟。

### 5.3保护设备模拟器

使用SR-IOV直通设备保护设备模拟器。我们建议为每个基于micro VM的容器使用Single Root I/O Virtualization (SR-IOV) 4直通设备，以便在需要时保护设备模拟器。在SR-IOV场景中，每个虚拟机的I/O请求直接由物理设备处理，绕过主机内核进行处理。具体来说，SRIOV设备可以减轻基于Firecrack的容器nf_conntrack表攻击，因为网络数据包直接由SR-IOV适配器中的虚拟桥接器处理。然而，它需要一个具有SR-IOV功能的适配器，这可能会增加基础设施的成本。例如，根据AWS EC2文档5，用户可以在AWS上的特殊EC2实例中启用SR-IOV。

增加速率限制。还建议通过为特定设备模拟器(即网络和存储设备)启用速率限制功能来限制基于microvm的容器占用的主机资源的访问速率。具体来说，系统操作员可以配置爆竹速率限制器，以减慢产生脏内存和占用主机nf_conntrack表的速度。

### 5.4保护主机内核组件

将工作线程附加到适当的cgroup。容器用户可以通过将相关内核线程移动到基于micro VM的容器的cgroup中来限制主机内核组件的工作负载。例如，如果vhost-net和KVM PIT内核线程附加到基于micro VM的容器的cgroup上，那么它们的工作负载将得到适当的计算和限制。

禁用主机内核组件的功能。如果需要，它可以通过禁用主机的vhost-net内核模块和KVM - PIT仿真来防止vhost-net和KVM - PIT内核线程生成工作负载。从而挫败vhost-net攻击和KVM PIT定时器攻击。

## 6.相关工作

虚拟机安全。由于虚拟机在多租户云环境中被广泛使用，因此对虚拟机安全性的研究也非常广泛。Ristenpart等人利用主机信息(如网络地址)来检测共驻留[10]。

随后，多个作品利用不同级别的缓存构建隐蔽通道[11,14,15,50]，用于共同驻留检测。

Zhang等人证明攻击者可以利用cache和DRAM进行侧通道攻击[12,13,51]，可以从其他vm中提取信息，甚至进行特权升级。Yelam等人基于内存总线争用[52]成功检测了AWS无服务器环境中的共驻留。此外，[53-56]利用硬件争用造成拒绝服务攻击。然而，它们主要针对共享硬件，而忽略了vm的组件依赖于主机内核并将操作从客户机转发到主机。

Huang等人演示了一种称为级联攻击的DoS攻击，它耗尽Xen共享域的处理能力，从而影响其他共同居住vm的性能[57]。Varadarajan等人提出了资源释放攻击来帮助提高攻击者VM[58]的性能。Zhou等人利用Xen信用调度器中的boost机制获得额外的CPU资源[59]。然而，他们的作品利用了Xen管理程序或Xen的共享域。但是，我们的目标是基于KVM管理程序上的基于micro VM的容器，我们关注的是基于micro VM容器的组件带来的操作转发。

容器安全。除了虚拟机安全之外，还有容器安全方面的研究。Luo等人识别了几种针对Docker的隐蔽通道，并展示了相关的信息泄漏攻击[60]。Gao等在/proc和/sys目录[2]中系统地识别了容器的信息泄漏通道。Gao等人演示了突破Linux控制组[3]的资源限制的利用策略。Yang等揭示了容器共享内核中的抽象资源以及相关的抽象资源攻击[4]。然而，这些论文主要集中在原生容器上，而没有系统地研究基于微虚拟机的容器的潜在风险。

还有保护集装箱的工作。Arnautov等使用Intel SGX的安全容器[61]。Lei等人揭示了一种名为SPEAKER的安全机制，用于减少容器的可用系统调用[62]。Sun等人提出了一种新的Linux命名空间，称为安全命名空间，用于隔离容器的安全策略[63]。然而，这些工作主要集中在保护本地容器上，这与我们的工作是正交的。

## 7.总结

在本文中，我们证明了基于micro VM的容器的组件将用户的操作转发给主机系统调用或主机内核函数，这可以被利用来打破基于micro VM的容器的隔离。

我们根据功能将基于micro VM的容器组件分为三层。我们说明了攻击者可以利用每一层的组件来转发他们的操作来发起攻击。我们进一步分别提出了针对Kata容器和基于爆竹的容器的四种攻击，并在本地测试平台和云裸机物理服务器上进行了实验。结果表明，这些攻击可以进行权限升级、DoS攻击和产生带外工作负载。最后，我们为基于micro VM的容器用户和开发人员提供了一些建议，以减轻操作转发攻击。